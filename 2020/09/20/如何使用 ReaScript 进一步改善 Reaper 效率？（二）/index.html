<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="补完 Reaper 效率链的最后一环（二）使用 reapy"><meta name="keywords" content=""><meta name="author" content="溪夜,undefined"><meta name="copyright" content="溪夜"><title>补完 Reaper 效率链的最后一环（二）使用 reapy | 溪夜的音频博客</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#缘起：对暴雪声音设计师工作流的思考"><span class="toc-number">1.</span> <span class="toc-text">缘起：对暴雪声音设计师工作流的思考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Wwise-Tour-2016-Blizzard-Overwatch"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. Wwise Tour 2016 - Blizzard Overwatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-我的思索"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. 我的思索</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要用-reapy？"><span class="toc-number">2.</span> <span class="toc-text">为什么要用 reapy？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-ReaScript-支持的三种脚本语言对比"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. ReaScript 支持的三种脚本语言对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-reapy-的优势"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. reapy 的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#配置开发环境"><span class="toc-number">3.</span> <span class="toc-text">配置开发环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Windows-下配置"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. Windows 下配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安装-Anaconda"><span class="toc-number">3.1.1.</span> <span class="toc-text">安装 Anaconda</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置-Anaconda"><span class="toc-number">3.1.2.</span> <span class="toc-text">配置 Anaconda</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置-VS-Code-开发环境"><span class="toc-number">3.1.3.</span> <span class="toc-text">配置 VS Code 开发环境</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-macOS-下配置"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. macOS 下配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安装-Anaconda-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">安装 Anaconda</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置-Anaconda-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">配置 Anaconda</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置-VS-Code开发环境"><span class="toc-number">3.2.3.</span> <span class="toc-text">配置 VS Code开发环境</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-在-Reaper-中配置-Python-的路径"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. 在 Reaper 中配置 Python 的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-安装-reapy-并测试"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.4. 安装 reapy 并测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reapy-解析"><span class="toc-number">4.</span> <span class="toc-text">reapy 解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-开发理念"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. 开发理念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-简单实例"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. 简单实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-reapy-文档的阅读方法-Translation-Table"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. reapy 文档的阅读方法 - Translation Table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-reapy-文档的阅读方法-Module-Index"><span class="toc-number">4.4.</span> <span class="toc-text">4.4. reapy 文档的阅读方法 - Module Index</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现一个根据制表符文件导入-Reaper-的-GUI-程序"><span class="toc-number">5.</span> <span class="toc-text">实现一个根据制表符文件导入 Reaper 的 GUI 程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-抽象功能逻辑"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. 抽象功能逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-选用-API"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. 选用 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-实现功能代码"><span class="toc-number">5.3.</span> <span class="toc-text">5.3. 实现功能代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-绘制-GUI-原型"><span class="toc-number">5.4.</span> <span class="toc-text">5.4. 绘制 GUI 原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-实现-GUI-代码"><span class="toc-number">5.5.</span> <span class="toc-text">5.5. 实现 GUI 代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-连接-GUI-代码与功能代码"><span class="toc-number">5.6.</span> <span class="toc-text">5.6. 连接 GUI 代码与功能代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-运行结果"><span class="toc-number">5.7.</span> <span class="toc-text">5.7. 运行结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接下来讲什么？"><span class="toc-number">6.</span> <span class="toc-text">接下来讲什么？</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">溪夜</div><div class="author-info__description text-center">得意时不骄傲，失意时不堕落。</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">15</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">2</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.cnn.com/cnnnext/dam/assets/170407220916-04-iconic-mountains-matterhorn-restricted.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">溪夜的音频博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">补完 Reaper 效率链的最后一环（二）使用 reapy</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-20</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 14 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>大家好，我是溪夜。<br>在《补完 Reaper 效率链的最后一环（一）ReaScript 基础》中，我们从头学习了如何编写 ReaScript 脚本。并通过实例，<strong>把从抽象逻辑到最终的 GUI 脚本程序这一条开发的流程跑通了一遍。</strong><br>在此相信读者已经有了一定的脚本开发基础，哪怕还没动手学习，最起码也对脚本开发有了个模糊的认识。<br>本系列教程的第二篇中，我们要讨论一下如何用 reapy 在 Reaper 外部对 ReaScript API 进行调用，这在某些需要用户避免接触 Reaper 而又需要其功能的场景下会有些用处。</p>
<blockquote>
<p>本系列文章阅读需要的前置知识：</p>
<ul>
<li>有一定的英文基础，能够看懂 ReaScript 文档。最好有在 Cockos 论坛上搜索答案的能力。</li>
<li>有 Python 基础，并会配置相应的开发环境。</li>
<li>对 Reaper 的功能比较了解。</li>
</ul>
</blockquote>
<p>本文目录：</p>
<p>[toc]</p>
<h2 id="缘起：对暴雪声音设计师工作流的思考"><a href="#缘起：对暴雪声音设计师工作流的思考" class="headerlink" title="缘起：对暴雪声音设计师工作流的思考"></a>缘起：对暴雪声音设计师工作流的思考</h2><h3 id="1-1-Wwise-Tour-2016-Blizzard-Overwatch"><a href="#1-1-Wwise-Tour-2016-Blizzard-Overwatch" class="headerlink" title="1.1. Wwise Tour 2016 - Blizzard Overwatch"></a>1.1. Wwise Tour 2016 - Blizzard Overwatch</h3><p>在 Wwise Tour 2016，守望先锋的开发者们分享了关于音频设计的内容。<br>在演示 TED 引擎时，通过按住 Record 录制语音，引擎就自动完成了一系列调用。所执行的步骤分别是完成录音、调用 Reaper 进行处理、调用 LMB（现在的 AMB）进行响度处理、调用 Wwise 生成 WEM。<br>去年我对自动化还不太熟悉，这种流畅的工作流显然令我印象深刻。</p>
<h3 id="1-2-我的思索"><a href="#1-2-我的思索" class="headerlink" title="1.2. 我的思索"></a>1.2. 我的思索</h3><p>他们调用 Reaper 的方法我非常感兴趣，因当时知识有限，不知这些软件还有 Command Line 的用法（Reaper、LMB、Wwise 都支持 Command Line），所以甚至想到了会不是走 Win32 API 调用 Reaper 隐藏页面再调 ReaScript API 来做到的……<br>因为去年只会 Python，所以<strong>在探索过程中找到了 reapy，</strong>意外发现它大大增加了 ReaScript 的易用性。<br><strong>这段探索故事的结果，也正是本篇文章的来源。</strong></p>
<h2 id="为什么要用-reapy？"><a href="#为什么要用-reapy？" class="headerlink" title="为什么要用 reapy？"></a>为什么要用 reapy？</h2><h3 id="2-1-ReaScript-支持的三种脚本语言对比"><a href="#2-1-ReaScript-支持的三种脚本语言对比" class="headerlink" title="2.1. ReaScript 支持的三种脚本语言对比"></a>2.1. ReaScript 支持的三种脚本语言对比</h3><p>在上篇文章中我们提到，除了支持 C/C++，<strong>ReaScript 还支持的三门脚本语言分别是自有的 EEL、Lua 及需要自行配置的 Python。</strong><br>对于使用 Python 来进行 ReaScript 开发来说，会性能略差于 EEL 和 Lua。但我们也知道，<strong>Python 有着海量的第三方资源，reapy 正是我挖掘到的一个很棒的 ReaScript Wrapper。</strong><br>我们来看看这三种脚本语言的 API 调用名称，它们是略有区别的，比如测试 API 连通性的 API test 举例：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EEL2:</span><br><span class="line">APITest();</span><br><span class="line"></span><br><span class="line">Lua:</span><br><span class="line">reaper.APITest()</span><br><span class="line"></span><br><span class="line">Python:</span><br><span class="line">RPR_APITest()</span><br></pre></td></tr></table></figure></p>
<p>可以发现，只有 EEL 保持了最简略的 API 调用名称。而 Lua 需要加入 <code>reaper.</code> 的前缀。当然，对于 Lua 我们可以通过加入一行 <code>local r = reaper</code> 让脚本写法变成 <code>r.APITest()</code>，<strong>这也是 Moy 老师文章中所提到的小技巧</strong>。<br>但是对于 Python 的 API 而言，这个 RPR_ 的讨厌前缀就很难在使用时去掉了。而我所介绍的 reapy 却可以轻松去掉这个前缀，这也是它最基本的设计之一。</p>
<h3 id="2-2-reapy-的优势"><a href="#2-2-reapy-的优势" class="headerlink" title="2.2. reapy 的优势"></a>2.2. reapy 的优势</h3><p>就像上面提到的，使用 reapy 可以让 Python 调用 ReaScript 变的更为简单，它有这些优势：</p>
<ol>
<li><strong>API 名称更简单，ReaScript 中令人无语的 RPR_ 前缀被去掉了，</strong>而且对 ReaScript 进行了优雅且 Pythonic 的装饰。同样的调用控制台输出消息功能，以前需要使用 <code>RPR_ShowConsoleMsg(&quot;Hello world!&quot;)</code>，现在只需一句 <code>reapy.print(&quot;Hello world!&quot;)</code> 即可做到。<strong>这里涉及到了 API 重命名，请参考第四章的 reapy 介绍。</strong></li>
<li><strong>在 Reaper 内外均可调用，并解决了在 Reaper 外调用 ReaScript 性能差的问题。</strong>因为 Reaper 的外部 API 调用是运行在 defer loop 当中，这会严重影响复杂脚本的性能。为此，reapy 提供了环境管理器 <code>reapy.inside_reaper</code> 来解决它。</li>
<li><strong>更新及时</strong>，另一个 ReaScript Python 装饰器 beyond.Reaper 在 V27 后已经多年不更新，ReaPyLib 也是停更很久，而 reapy 在本文写作的上一个月还在更新最新的 API 支持。</li>
<li><strong>具有结构分类</strong>，原始的 ReaScript API 就是一团乱麻，而 reapy 为其进行了完善的分类排布。</li>
<li>外部调用会更稳定，因为 Reaper 的代码架构原因，用 Python 在 Reaper 内部引用外部库会有些小问题。</li>
</ol>
<h2 id="配置开发环境"><a href="#配置开发环境" class="headerlink" title="配置开发环境"></a>配置开发环境</h2><p>老规矩，请大家自行参考这些优质文章配置相关开发环境。对于开发工具也并非强求，用自己喜欢的开发工具均可，如果嫌麻烦也可直接装好 Python 后用自带的 IDLE。</p>
<h3 id="3-1-Windows-下配置"><a href="#3-1-Windows-下配置" class="headerlink" title="3.1. Windows 下配置"></a>3.1. Windows 下配置</h3><h4 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h4><p><a href="https://segmentfault.com/a/1190000022797661" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022797661</a></p>
<h4 id="配置-Anaconda"><a href="#配置-Anaconda" class="headerlink" title="配置 Anaconda"></a>配置 Anaconda</h4><p><a href="https://zhuanlan.zhihu.com/p/25198543" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25198543</a></p>
<h4 id="配置-VS-Code-开发环境"><a href="#配置-VS-Code-开发环境" class="headerlink" title="配置 VS Code 开发环境"></a>配置 VS Code 开发环境</h4><p><a href="https://zhuanlan.zhihu.com/p/30324113" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30324113</a></p>
<h3 id="3-2-macOS-下配置"><a href="#3-2-macOS-下配置" class="headerlink" title="3.2. macOS 下配置"></a>3.2. macOS 下配置</h3><h4 id="安装-Anaconda-1"><a href="#安装-Anaconda-1" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h4><p><a href="https://blog.csdn.net/lq_547762983/article/details/81003528" target="_blank" rel="noopener">https://blog.csdn.net/lq_547762983/article/details/81003528</a></p>
<h4 id="配置-Anaconda-1"><a href="#配置-Anaconda-1" class="headerlink" title="配置 Anaconda"></a>配置 Anaconda</h4><h4 id="配置-VS-Code开发环境"><a href="#配置-VS-Code开发环境" class="headerlink" title="配置 VS Code开发环境"></a>配置 VS Code开发环境</h4><p>此两步可参考上面的链接，操作类似。</p>
<h3 id="3-3-在-Reaper-中配置-Python-的路径"><a href="#3-3-在-Reaper-中配置-Python-的路径" class="headerlink" title="3.3. 在 Reaper 中配置 Python 的路径"></a>3.3. 在 Reaper 中配置 Python 的路径</h3><p><strong>注意，reapy 声称能够帮助用户配置 Reaper 中的 Python 路径，所以可先执行 3.4. 中的内容，如果未出现配置再执行本步骤。</strong><br>在 Reaper 中想使用 Python 需要配置一些参数:</p>
<ol>
<li>打开 Options - Preferences 中的 ReaScript，在窗口中勾选 Enable Python to use with ReaScript，以打开 Python 支持。</li>
<li>因为 Reaper 并不知道 Python 的所在地，自动检测如果未检测 Python 成功，所以还需在右边指定你的 Python 安装路径。</li>
</ol>
<p>下面是我分别在 Windows 和 macOS 的配置截图，供大家参考。其中使用的环境都是 Anaconda 中的 Python，直接安装的 Python 也可按照相同的方法指定环境路径并定位所需的 Python 文件。<br><img src="/images/macOS%20%E9%85%8D%E7%BD%AE.png" alt="macOS 配置"><br>macOS 配置<br><img src="/images/Windows%20%E9%85%8D%E7%BD%AE.png" alt="Windows 配置"><br>Windows 配置</p>
<h4 id="3-4-安装-reapy-并测试"><a href="#3-4-安装-reapy-并测试" class="headerlink" title="3.4. 安装 reapy 并测试"></a>3.4. 安装 reapy 并测试</h4><p>因为 conda-forge 中没有 reapy，所以 reapy 可以通过以下两种方式安装：</p>
<ol>
<li>没有 Conda 的话，直接执行 <code>pip install python-reapy</code> 在本地 pip 环境中安装 reapy</li>
<li>有 Conda 的话，同样执行上述命令，在 Conda 的 pip 环境中安装 reapy</li>
</ol>
<p>安装完毕之后，打开 Reaper，在终端中执行 <code>python -c &quot;import reapy; reapy.configure_reaper()&quot;</code>。这一步的目的是为了初始化 reapy，同时添加脚本 activate_reapy_server.py，它是 reapy 在 Reaper 外部使用的前提。</p>
<p>作为测试，你可以在 Reaper 内外分别执行以下语句观察执行效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reapy</span><br><span class="line">reapy.test_api()</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/%E5%9C%A8%E5%86%85%E5%A4%96%E5%90%8C%E6%97%B6%E6%89%A7%E8%A1%8C.png" alt="在内外同时执行"><br>在 VS Code 和 Reaper 内分别执行同样的代码</p>
<p>我们会发现，都得到了一样的返回结果，如图所示：<br><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-09-18%2002.13.46.png" alt="屏幕快照 2020-09-18 02.13.46"></p>
<h2 id="reapy-解析"><a href="#reapy-解析" class="headerlink" title="reapy 解析"></a>reapy 解析</h2><h3 id="4-1-开发理念"><a href="#4-1-开发理念" class="headerlink" title="4.1. 开发理念"></a>4.1. 开发理念</h3><p>介绍一下开发者，reapy 由 Roméo Després 开发。他现在是法国华纳音乐的数据分析师，也曾在 IRCAM 工作过。<br>reapy 的开发理念基于 ReaScript 在 Python 下糟糕的使用体验，以及毫无 Pythonic 的 API 样式，同时开发者完善了的面向对象层的设计。这也是目前唯一一个活跃的 Python 版 ReaScript 装饰器项目了，其余的几个项目要么断更要么不完善。<br><strong>对于普通用户而言，最直观的感受就是部分常用 API 变的简单了，</strong>因为增加了 API 翻译（重命名）。而未经过处理的 API 的也可继续使用原来的名字进行调用，当然，是不带愚蠢的 RPR_ 前缀的版本。<br>对于不想学习 EEL 和 Lua 的 Python 程序员来说，reapy 是个非常友善的切入点。</p>
<h3 id="4-2-简单实例"><a href="#4-2-简单实例" class="headerlink" title="4.2. 简单实例"></a>4.2. 简单实例</h3><p>在 3.4. 小节中讲到了测试 API 的用法，在原生的 Python 版 ReaScript 中的 <code>RPR_APITest()</code>，在 reapy 中只需写成 <code>reapy.test_api()</code> 即可。<br>下面通过一条实例，体验一下 reapy 在实际脚本中的应用。<br>上一篇文章中用脚本复刻了一条 Action 的功能 <code>Item edit: Move position of item under mouse to edit cursor</code>，这是之前的 Lua 版代码：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> r = reaper</span><br><span class="line"></span><br><span class="line">r.Undo_BeginBlock()</span><br><span class="line"></span><br><span class="line">item = r.BR_GetMouseCursorContext_Item()</span><br><span class="line">cursor_pos = r.GetCursorPosition()</span><br><span class="line">r.SetMediaItemInfo_Value(item, <span class="string">"D_POSITION"</span>, cursor_pos)</span><br><span class="line"></span><br><span class="line">r.Undo_EndBlock()</span><br></pre></td></tr></table></figure></p>
<p>如果它用 Python 版的原生 ReaScript API 来写会是这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RPR_Undo_BeginBlock()</span><br><span class="line"></span><br><span class="line">item = BR_GetMouseCursorContext_Item()</span><br><span class="line">cursor_pos = RPR_GetCursorPosition()</span><br><span class="line">RPR_SetMediaItemInfo_Value(item, <span class="string">"D_POSITION"</span>, cursor_pos)</span><br><span class="line"></span><br><span class="line">RPR_Undo_EndBlock()</span><br></pre></td></tr></table></figure></p>
<p>现在我们用 reapy 在 Reaper 内重写一遍代码，看看与之的版本有什么区别。为了方便理解，我给代码写上注释。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reapy <span class="keyword">as</span> r</span><br><span class="line"><span class="keyword">from</span> reapy <span class="keyword">import</span> reascript_api <span class="keyword">as</span> rpr</span><br><span class="line"><span class="comment"># 获取当前工程</span></span><br><span class="line">proj = r.Project()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Undo Block 开始</span></span><br><span class="line">proj.begin_undo_block()</span><br><span class="line"><span class="comment"># reapy 中使用第三方 API 有些问题（虽然老版文档说 reascript_api 中可用），所以这里使用 Main_OnCommand 执行 Action（Item: Select item under mouse cursor）获取鼠标下的对象</span></span><br><span class="line">r.perform_action(<span class="number">40528</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取鼠标下的对象并对返回值加以处理为 str，给 SetMediaItemInfo_Value 的参数做好准备</span></span><br><span class="line">item = str(proj.get_selected_item(<span class="number">0</span>))</span><br><span class="line">item = eval(item.strip(<span class="string">'Item()'</span>))</span><br><span class="line"><span class="comment"># 获取当前游标位置</span></span><br><span class="line">cursor_pos = proj.cursor_position</span><br><span class="line"></span><br><span class="line"><span class="comment"># 未进行装饰的 API 可在 reascript_api 直接引用</span></span><br><span class="line">rpr.SetMediaItemInfo_Value(item, <span class="string">"D_POSITION"</span>, cursor_pos)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Undo Block 结束</span></span><br><span class="line">proj.end_undo_block()</span><br></pre></td></tr></table></figure></p>
<p>我们从这段重写的代码中可看出：</p>
<ol>
<li>大多数 API 都被装饰过了，调用起来更符合 Python 的风格，也更加面向对象。</li>
<li>对于没装饰的 API，也提供了去除恼人前缀方便管理的调用方式。</li>
</ol>
<p>对于一个还在持续开发中的第三方库来说，我还是非常期待它做到 V1.0 能达到什么样的高度，是否会把所有的 API 全部装饰，那样使用体验就更加友好。</p>
<h3 id="4-3-reapy-文档的阅读方法-Translation-Table"><a href="#4-3-reapy-文档的阅读方法-Translation-Table" class="headerlink" title="4.3. reapy 文档的阅读方法 - Translation Table"></a>4.3. reapy 文档的阅读方法 - Translation Table</h3><p><strong>大家都知道，ReaScript 的文档非常杂乱无章，</strong>很多时候只能靠搜索碰运气，所以第一篇文中我们提到了优化版文档以供大家更快的查询所需 API。而对于 reapy，它也有一套自己的文档。<br>地址：<a href="https://python-reapy.readthedocs.io/en/latest/api_table.html" target="_blank" rel="noopener">https://python-reapy.readthedocs.io/en/latest/api_table.html</a><br><img src="/images/reapy%20%E6%96%87%E6%A1%A3.png" alt="reapy 文档"></p>
<p><strong>在文档左边可以看到入门指南的 Api guide、安装指南、模块索引等章节，通常查询 API 需要面对的章节就是我给出的 Translation Table。</strong><br>reapy 的 API 分类是根据 Mespotine 的 ReaScript API 分类而定，不过可惜 Mespotine 的原网页已经失效，目前只能单纯参考 reapy 这里的分类方法了。<br>往下翻，我们会看到 API 中存在对应关系，<strong>右边的列代表了 reapy 中的装饰 API</strong>，而左边代表 ReaScript 中的原 API。<br><img src="/images/%E6%96%87%E6%A1%A3%E5%AE%9E%E4%BE%8B2.png" alt="文档实例2"></p>
<p>使用 reapy 来开发脚本，请在 Translation Table 中优先使用 reapy 版的 API 以获得更好的 Python 编程体验。<br>目前的 reapy 还没有完成全部的 API 装饰，不过绝大多数常用的都已完成。其中的函数有两种简单用法：</p>
<ol>
<li>已经具有 reapy 装饰的，执行 <code>reapy.function_name()</code>。当然，也可以重命名 reapy 后执行诸如 <code>r.function_name()</code> 这样的语句。</li>
<li>还没有 reapy 装饰的，执行 <code>from reapy import reascript_api</code> 从 reascript_api 中导入子模块后再使用。因为此子模块名字较长，可根据自己的喜好重命名，比如命名为 rpr，那么函数的调用就是 <code>rpr.raw_function_name()</code>。</li>
</ol>
<h3 id="4-4-reapy-文档的阅读方法-Module-Index"><a href="#4-4-reapy-文档的阅读方法-Module-Index" class="headerlink" title="4.4. reapy 文档的阅读方法 - Module Index"></a>4.4. reapy 文档的阅读方法 - Module Index</h3><p><strong>此外，reapy 的设计重点是让 ReaScript 更加的 Pythonic，</strong>所以使用时会发现它存在一种分层级的 API 管理逻辑。我目前的使用习惯，还是以 Translation Table 为主要参考，Module Index 作为对某一类对象进行操作时的参考，比如对 audio 或 midi 执行大量的操作时，会直接从 Module Index 取用功能，这也是 reapy 的一个设计目的。<br><img src="/images/%E6%96%87%E6%A1%A3%E5%B1%82%E7%BA%A7.png" alt="文档层级"><br>文档中的 Module Index</p>
<p><strong>初次接触这个层级分布时可能会有点晕，其实按照层级理解就好。</strong>下面通过实例看看这些层级的使用，我引用一些比较常用的 API 以供参考。<br>reapy 层级，会默认导入 reapy.core.reaper.reaper 内所有的函数，是常见工程级操作的顶层层级。<br><strong>事实上它的层级位置是 reaper.core.reaper，所以以此开头的 audio、defer、midi、ui 等需通过 reaper.audio、reaper.midi 的方法来调用。</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reapy <span class="keyword">as</span> r</span><br><span class="line"></span><br><span class="line"><span class="comment"># reapy.core.reaper.reaper</span></span><br><span class="line">r.print(<span class="string">"Hello Reaper!"</span>) <span class="comment"># 控制台输出</span></span><br><span class="line">r.clear_console() <span class="comment"># 清除控制台</span></span><br><span class="line">r.perform_action(action_id) <span class="comment"># 调用 Action</span></span><br><span class="line">r.open_project(filepath) <span class="comment"># 打开工程</span></span><br><span class="line">r.get_reaper_version() <span class="comment"># 获取 Reaper 版本</span></span><br><span class="line">r.set_global_automation_mode(mode) <span class="comment"># 设置全局 Automation 模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># reapy.core.reaper.midi</span></span><br><span class="line">r.midi.get_active_editor() <span class="comment"># 返回活动的 MIDI 编辑器</span></span><br><span class="line">r.midi.get_input_names() <span class="comment"># 获得所有 MIDI 输入通道名</span></span><br><span class="line">r.midi.get_n_inputs() <span class="comment"># 返回 MIDI 输入通道数</span></span><br><span class="line">r.midi.reinit() <span class="comment"># 重置所有 MIDI 设备</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># reapy.core.Envelope</span></span><br><span class="line">r.Envelope.name() <span class="comment"># 返回包络线名字</span></span><br><span class="line">r.Envelope.get_value(time, raw=<span class="keyword">False</span>) <span class="comment"># 获取包络线指定时间点上的值</span></span><br><span class="line">r.Envelope.n_points() <span class="comment"># 获取包络线中的点位数</span></span><br><span class="line">r.Envelope.add_item(position=<span class="number">0.0</span>, length=<span class="number">1.0</span>, pool=<span class="number">0</span>) <span class="comment"># 创建新的包络线对象</span></span><br></pre></td></tr></table></figure></p>
<p><strong>reapy.tools，其中的用于提高外部调用 ReaScript 时的性能。</strong>因为 ReaScript 外部引用是运行在 defer loop 之中的，执行效率与 Native ReaScript 无法相比，只有每秒不到60次的执行效率，在执行繁重操作时会有很大影响。为了解决这个问题，需要使用 <code>reapy.tools.inside_reaper</code> 模块。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reapy <span class="keyword">as</span> r</span><br><span class="line"></span><br><span class="line">project = r.Project() <span class="comment"># 获取当前工程对象</span></span><br><span class="line"></span><br><span class="line">bpms = [project.bpm <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>)] <span class="comment"># 求1000次工程的 BPM，需要半分钟以上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> r.inside_reaper():</span><br><span class="line">     bpms = [project.bpm <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>)] <span class="comment"># 使用 inside_reaper() 后命令会从内部运行，只需0.1秒</span></span><br></pre></td></tr></table></figure></p>
<p><code>reapy.config</code> 内定义了有关 reapy 开关和 Web 接口的内容，普通用户可以不用在意。<br><code>reapy.errors</code> 包括各种报错信息，可与 Python 的异常处理语句合用。</p>
<h2 id="实现一个根据制表符文件导入-Reaper-的-GUI-程序"><a href="#实现一个根据制表符文件导入-Reaper-的-GUI-程序" class="headerlink" title="实现一个根据制表符文件导入 Reaper 的 GUI 程序"></a>实现一个根据制表符文件导入 Reaper 的 GUI 程序</h2><p>我们都知道，批量的文件处理（比如对于游戏语音对白来说）所需的导入文件，均匀设置对象间隔及按区域导出对于 Reaper 来说是非常简单的。<br>为了演示 reapy 在外部的完整运行效果，<strong>我们假设一个需求，需要使用 ReaScript 导入文件，并能够要根据需求设定不同的属性值及效果器。</strong>通过让录音师进行规范的命名，在导入 Reaper 的时候可以轻松做到这件事。<strong>在这里设定文件名的格式为 <code>&lt;ItemName&gt;_&lt;Volume&gt;_&lt;FXChain&gt;.wav</code></strong></p>
<ul>
<li>注意：出于篇幅限制，只在示例文件名中定义一个属性和一个效果器链，有更多的需求只需扩展代码即可。并且演示中的代码不会考虑 Windows 和 macOS 中路径斜杠不同的问题，也不会讨论不同文件格式的支持。</li>
</ul>
<h3 id="5-1-抽象功能逻辑"><a href="#5-1-抽象功能逻辑" class="headerlink" title="5.1. 抽象功能逻辑"></a>5.1. 抽象功能逻辑</h3><p>为了演示，建立两个示例文件：<br><code>UI_Bright_Button_01_-5_C1.wav</code><br><code>Player_Heavy_Hit_12_-3_C2.wav</code><br>音效文件的命名对于下划线使用的非常广泛，这里假设在已有文件名的最后加入两个下划线后缀，分别指定为音量与效果器链的要求，以增加字符串处理时的乐趣。<br>于是我们抽象出功能逻辑：</p>
<ol>
<li>使用 Python 读取文件名中的信息，暂存到一个提取好信息的字典中</li>
<li>使用 Reaper 在当前工程中插入新轨道，相同 FX Chain 的放到同一轨，否则放到不同轨</li>
<li>对轨道或 Take 设置属性</li>
<li>对轨道或 Take 设置 FX Chain</li>
<li>导出文件</li>
</ol>
<h3 id="5-2-选用-API"><a href="#5-2-选用-API" class="headerlink" title="5.2. 选用 API"></a>5.2. 选用 API</h3><ol>
<li>使用 Python 读取文件名中的信息，暂存到一个提取好信息的字典中</li>
<li>使用 Reaper 在当前工程中插入新轨道，相同 FX Chain 的放到同一轨，否则放到不同轨</li>
<li>对轨道或 Take 设置属性</li>
<li>对轨道或 Take 设置 FX Chain</li>
<li>导出文件</li>
</ol>
<h3 id="5-3-实现功能代码"><a href="#5-3-实现功能代码" class="headerlink" title="5.3. 实现功能代码"></a>5.3. 实现功能代码</h3><p>使用 Python 读取文件名中的信息，暂存到一个提取好信息的字典中<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input_path = <span class="string">"user_defined_path"</span> <span class="comment"># 例如 /Users/xiye/Downloads/UI_Bright_Button_01_-5_C1.wav</span></span><br><span class="line"><span class="comment"># 源文件名</span></span><br><span class="line">raw_file_name = input_path.split(<span class="string">"/"</span>)[<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># 指定音量</span></span><br><span class="line">volume = raw_file_name.split(<span class="string">"_"</span>)[<span class="number">-2</span>]</span><br><span class="line"><span class="comment"># 指定效果器链</span></span><br><span class="line">chain = raw_file_name.split(<span class="string">"."</span>)[<span class="number">0</span>].split(<span class="string">"_"</span>)[<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># 原文件名中的完整文件名</span></span><br><span class="line">new_file_name = raw_file_name.rsplit(<span class="string">'_'</span>, <span class="number">2</span>)[<span class="number">0</span>] + <span class="string">"."</span> + input_path.split(<span class="string">"."</span>)[<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># 参数字典</span></span><br><span class="line">param_dict = &#123;<span class="string">"new_file_name"</span>: new_file_name, <span class="string">"volume"</span>: volume, <span class="string">"chain"</span>: chain&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 Reaper 在当前工程中插入新轨道，相同 FX Chain 的放到同一轨，否则放到不同轨<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>对轨道或 Take 设置属性<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>对轨道或 Take 设置 FX Chain<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>导出文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="5-4-绘制-GUI-原型"><a href="#5-4-绘制-GUI-原型" class="headerlink" title="5.4. 绘制 GUI 原型"></a>5.4. 绘制 GUI 原型</h3><h3 id="5-5-实现-GUI-代码"><a href="#5-5-实现-GUI-代码" class="headerlink" title="5.5. 实现 GUI 代码"></a>5.5. 实现 GUI 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-6-连接-GUI-代码与功能代码"><a href="#5-6-连接-GUI-代码与功能代码" class="headerlink" title="5.6. 连接 GUI 代码与功能代码"></a>5.6. 连接 GUI 代码与功能代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-7-运行结果"><a href="#5-7-运行结果" class="headerlink" title="5.7. 运行结果"></a>5.7. 运行结果</h3><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">溪夜</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://xiye.art/2020/09/20/如何使用 ReaScript 进一步改善 Reaper 效率？（二）/">http://xiye.art/2020/09/20/如何使用 ReaScript 进一步改善 Reaper 效率？（二）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://xiye.art" target="_blank">溪夜的音频博客</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/09/20/如何使用 ReaScript 进一步改善 Reaper 效率？（一）/"><i class="fa fa-chevron-left">  </i><span>补完 Reaper 效率链的最后一环（一）ReaScript 基础</span></a></div><div class="next-post pull-right"><a href="/2020/09/20/PySimpleGUI  第三篇/"><span>写给声音设计师的敏捷 GUI 开发大法（三）WAAPI Database</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC80MDk4Ny8xNzUxMg=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By 溪夜</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>