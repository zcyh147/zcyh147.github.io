<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="补完 Reaper 效率链的最后一环（二）使用 reapy"><meta name="keywords" content="Reaper"><meta name="author" content="溪夜,undefined"><meta name="copyright" content="溪夜"><title>补完 Reaper 效率链的最后一环（二）使用 reapy | 溪夜的音频博客</title><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#缘起：对暴雪声音设计师工作流的思考"><span class="toc-number">1.</span> <span class="toc-text">缘起：对暴雪声音设计师工作流的思考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Wwise-Tour-2016-Blizzard-Overwatch"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. Wwise Tour 2016 - Blizzard Overwatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-我的思索"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. 我的思索</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要用-reapy？"><span class="toc-number">2.</span> <span class="toc-text">为什么要用 reapy？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-ReaScript-支持的三种脚本语言对比"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. ReaScript 支持的三种脚本语言对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-reapy-的优势"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. reapy 的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#配置开发环境"><span class="toc-number">3.</span> <span class="toc-text">配置开发环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Windows-下配置"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. Windows 下配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安装-Anaconda"><span class="toc-number">3.1.1.</span> <span class="toc-text">安装 Anaconda</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置-Anaconda"><span class="toc-number">3.1.2.</span> <span class="toc-text">配置 Anaconda</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置-VS-Code-开发环境"><span class="toc-number">3.1.3.</span> <span class="toc-text">配置 VS Code 开发环境</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-macOS-下配置"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. macOS 下配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#安装-Anaconda-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">安装 Anaconda</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置-Anaconda-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">配置 Anaconda</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置-VS-Code开发环境"><span class="toc-number">3.2.3.</span> <span class="toc-text">配置 VS Code开发环境</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-在-Reaper-中配置-Python-的路径"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. 在 Reaper 中配置 Python 的路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-安装-reapy-并测试"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.4. 安装 reapy 并测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reapy-解析"><span class="toc-number">4.</span> <span class="toc-text">reapy 解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-开发理念"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. 开发理念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-简单实例"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. 简单实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-reapy-文档的阅读方法-Translation-Table"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. reapy 文档的阅读方法 - Translation Table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-reapy-文档的阅读方法-Module-Index"><span class="toc-number">4.4.</span> <span class="toc-text">4.4. reapy 文档的阅读方法 - Module Index</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现一个简单的根据文件名导入-Reaper-的-GUI-程序"><span class="toc-number">5.</span> <span class="toc-text">实现一个简单的根据文件名导入 Reaper 的 GUI 程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-抽象功能逻辑"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. 抽象功能逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-选用-API"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. 选用 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-实现功能代码"><span class="toc-number">5.3.</span> <span class="toc-text">5.3. 实现功能代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-实现-GUI-代码"><span class="toc-number">5.4.</span> <span class="toc-text">5.4. 实现 GUI 代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-连接-GUI-代码与功能代码"><span class="toc-number">5.5.</span> <span class="toc-text">5.5. 连接 GUI 代码与功能代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-运行结果"><span class="toc-number">5.6.</span> <span class="toc-text">5.6. 运行结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接下来讲什么？"><span class="toc-number">6.</span> <span class="toc-text">接下来讲什么？</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">溪夜</div><div class="author-info__description text-center">一个 Technical Sound Designer / Sound Engineer / iOS Music Maker / Gearslut / Synth-Lover / Extreme Metal Vocalist / Guitarist / LLer / 惠海人 / 明日香老缠粉 / 音频行业恐怖分子</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">22</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">1</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友情链接</div><a class="author-info-links__name text-center" href="https://sololand.moe/" target="_blank">zpan的独奏乡</a><a class="author-info-links__name text-center" href="http://jazzlost.me/" target="_blank">李AA的博客</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.cnn.com/cnnnext/dam/assets/170407220916-04-iconic-mountains-matterhorn-restricted.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">溪夜的音频博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/about">About Me</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a></span></div><div id="post-info"><div id="post-title">补完 Reaper 效率链的最后一环（二）使用 reapy</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-21</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.2k</span><span class="post-meta__separator">|</span><span>阅读时长: 18 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>大家好，我是溪夜。<br>在《补完 Reaper 效率链的最后一环（一）ReaScript 基础》中，我们分析了如何使用 Lua 编写脚本的全过程。并通过一个实例，<strong>把从抽象逻辑到最终的 GUI 脚本程序这一条开发的流程完整的跑通了一遍。</strong><br>在此相信读者已经有了一定的脚本开发基础，哪怕还没动手学习，应该也对脚本开发的流程有了大概的认知。<br>本系列教程的第二篇中，会讨论一下如何用 reapy 在 Reaper 外部对 ReaScript API 进行调用。通过使用 reapy，我们<strong>一方面能够获得更加 Python 的脚本开发体验。另一方面在某些需要用户避免接触 Reaper 而又需要其功能的场景下，可通过把脚本调用外置来解决这个需求。</strong></p>
<blockquote>
<p>本系列文章阅读需要的前置知识：</p>
<ul>
<li>有一定的英文基础，能够看懂 ReaScript 文档。最好有在 Cockos 论坛上搜索答案的能力。</li>
<li>有 Python 基础，会配置相应的开发环境，了解 PySimpleGUI 使用。</li>
<li>对 Reaper 的功能比较了解。</li>
</ul>
</blockquote>
<p>本文目录：</p>
<p>[toc]</p>
<h2 id="缘起：对暴雪声音设计师工作流的思考"><a href="#缘起：对暴雪声音设计师工作流的思考" class="headerlink" title="缘起：对暴雪声音设计师工作流的思考"></a>缘起：对暴雪声音设计师工作流的思考</h2><h3 id="1-1-Wwise-Tour-2016-Blizzard-Overwatch"><a href="#1-1-Wwise-Tour-2016-Blizzard-Overwatch" class="headerlink" title="1.1. Wwise Tour 2016 - Blizzard Overwatch"></a>1.1. Wwise Tour 2016 - Blizzard Overwatch</h3><p>在 Wwise Tour 2016 中，守望先锋的开发者分享了关于音频设计的内容。<br>当他们演示 TED 引擎时，通过按住 Record 按钮录制语音，引擎就自动完成了一系列调用。其所执行的步骤大概是是完成录音、调用 Reaper 进行处理、调用 LMB（现在的 AMB）进行响度处理、调用 Wwise 生成 WEM 等。要知道去年我对这种自动化流程还不太熟悉，这种流畅的工作流让我印象非常深刻。</p>
<h3 id="1-2-我的思索"><a href="#1-2-我的思索" class="headerlink" title="1.2. 我的思索"></a>1.2. 我的思索</h3><p>他们调用 Reaper 的方法我非常感兴趣，因当时知识有限，不知还有命令行的用法（Reaper、LMB、Wwise 都支持 Command Line），所以甚至想到了会不是走 Win32 API 调用 Reaper 时做到隐藏页面再调 ReaScript API 来做到的……<br>因为去年只会 Python，就想着怎么用它来玩 ReaScript，所以<strong>在探索过程中找到了 reapy</strong>，发现它大大增加了 Python 程序员使用 ReaScript 时的易用性。<br><strong>这段探索故事的结尾，正是本篇文章的来源。</strong></p>
<h2 id="为什么要用-reapy？"><a href="#为什么要用-reapy？" class="headerlink" title="为什么要用 reapy？"></a>为什么要用 reapy？</h2><h3 id="2-1-ReaScript-支持的三种脚本语言对比"><a href="#2-1-ReaScript-支持的三种脚本语言对比" class="headerlink" title="2.1. ReaScript 支持的三种脚本语言对比"></a>2.1. ReaScript 支持的三种脚本语言对比</h3><p>在上篇文章中我们提到，除了支持 C/C++，<strong>ReaScript 支持的三门脚本语言分别是自有的 EEL、Lua 及 Python。</strong><br>对于使用 Python 来进行 ReaScript 开发来说，除了会性能略差于 EEL 和 Lua，使用 Tkinter 这种 GUI 框架也容易出现问题（尤其是 macOS 中）。但我们也知道，<strong>Python 有着海量的第三方资源，reapy 正是我挖掘到的一个很棒的 ReaScript Wrapper。</strong><br>首先我们来看看这三种脚本语言的 API 调用名称，它们是略有区别的，拿测试 API 连通性的 <code>APITest()</code> 举例：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EEL2:</span><br><span class="line">APITest();</span><br><span class="line"></span><br><span class="line">Lua:</span><br><span class="line">reaper.APITest()</span><br><span class="line"></span><br><span class="line">Python:</span><br><span class="line">RPR_APITest()</span><br></pre></td></tr></table></figure></p>
<p>可以发现，只有 EEL 保持了最简略的 API 调用名称。而 Lua 需要加入 <code>reaper.</code> 的前缀（当然，对于 Lua 我们可以通过加入一行 <code>local r = reaper</code> 让脚本写法变成 <code>r.APITest()</code>，<strong>这也是 Moy 老师文章中所提到的小技巧，与 Python 的 as 重命名同理</strong>）。<br>但是对于 Python 的 API 而言，这个 RPR_ 的讨厌前缀就很难在使用时去掉了。而这篇文章所介绍的 reapy 却可以轻松去掉这个前缀，这只是它的一个小优点。</p>
<h3 id="2-2-reapy-的优势"><a href="#2-2-reapy-的优势" class="headerlink" title="2.2. reapy 的优势"></a>2.2. reapy 的优势</h3><p>就像上面提到的，使用 reapy 可以让 Python 调用 ReaScript 变的更为简单，因为它有这些优势：</p>
<ol>
<li><strong>API 调用名称更简单，ReaScript 中毫无用处的 RPR_ 前缀被去掉了，</strong>而且对 ReaScript 进行了优雅且 Pythonic 的装饰。同样的调用控制台输出消息功能，以前需要使用 <code>RPR_ShowConsoleMsg(&quot;Hello world!&quot;)</code>，现在只需一句 <code>reapy.print(&quot;Hello world!&quot;)</code> 即可做到。更加简单，也更加的面向对象。</li>
<li><strong>在 Reaper 内外均可调用，并解决了在 Reaper 外调用 ReaScript 性能差的问题。</strong>因为 ReaScript 通过外部 API 调用时会运行在 defer loop 当中，这会严重影响复杂脚本的性能。为此，reapy 提供了环境管理器 <code>reapy.inside_reaper</code> 来解决这个问题。</li>
<li><strong>更新及时</strong>，另一个 ReaScript Python 装饰 beyond.Reaper 在 V27 后已经多年不更新，ReaPyLib 也是停更很久，而 reapy 在本文写作的上一个月还在持续更新。</li>
<li><strong>具有结构分类</strong>，原始的 ReaScript API 就是一团乱麻，而 reapy 为其进行了逻辑完善的分类排布。</li>
<li>外部调用会更稳定，因为 ReaScript 的设计原因，用 Python 在 Reaper 内部引用外部库会有或多或少的问题。</li>
</ol>
<h2 id="配置开发环境"><a href="#配置开发环境" class="headerlink" title="配置开发环境"></a>配置开发环境</h2><p>老规矩，请大家自行参考这些优质文章配置相关开发环境。对于开发工具也并非强求，用自己喜欢的开发工具均可。</p>
<h3 id="3-1-Windows-下配置"><a href="#3-1-Windows-下配置" class="headerlink" title="3.1. Windows 下配置"></a>3.1. Windows 下配置</h3><h4 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h4><p><a href="https://segmentfault.com/a/1190000022797661" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022797661</a></p>
<h4 id="配置-Anaconda"><a href="#配置-Anaconda" class="headerlink" title="配置 Anaconda"></a>配置 Anaconda</h4><p><a href="https://zhuanlan.zhihu.com/p/25198543" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25198543</a></p>
<h4 id="配置-VS-Code-开发环境"><a href="#配置-VS-Code-开发环境" class="headerlink" title="配置 VS Code 开发环境"></a>配置 VS Code 开发环境</h4><p><a href="https://zhuanlan.zhihu.com/p/30324113" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30324113</a></p>
<h3 id="3-2-macOS-下配置"><a href="#3-2-macOS-下配置" class="headerlink" title="3.2. macOS 下配置"></a>3.2. macOS 下配置</h3><h4 id="安装-Anaconda-1"><a href="#安装-Anaconda-1" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h4><p><a href="https://blog.csdn.net/lq_547762983/article/details/81003528" target="_blank" rel="noopener">https://blog.csdn.net/lq_547762983/article/details/81003528</a></p>
<h4 id="配置-Anaconda-1"><a href="#配置-Anaconda-1" class="headerlink" title="配置 Anaconda"></a>配置 Anaconda</h4><h4 id="配置-VS-Code开发环境"><a href="#配置-VS-Code开发环境" class="headerlink" title="配置 VS Code开发环境"></a>配置 VS Code开发环境</h4><p>此两步可参考上面的链接，操作类似。</p>
<h3 id="3-3-在-Reaper-中配置-Python-的路径"><a href="#3-3-在-Reaper-中配置-Python-的路径" class="headerlink" title="3.3. 在 Reaper 中配置 Python 的路径"></a>3.3. 在 Reaper 中配置 Python 的路径</h3><p><strong>注意，reapy 声称能够帮助用户配置 Reaper 中的 Python 路径，所以可先执行 3.4. 中的提到的 <code>reapy.configure_reaper()</code>，如果配置未成功再按本段内容手工配置。</strong><br>在 Reaper 中想使用 Python 需要配置一些参数:</p>
<ol>
<li>打开 Options - Preferences 中的 ReaScript，在窗口中勾选 Enable Python to use with ReaScript，以打开 Python 支持。</li>
<li>因为 Reaper 并不知道 Python 的所在，自动检测如果未检测出 Python，可能还需指定你的 Python 文件。</li>
</ol>
<p>下面是在 Windows 和 macOS 的配置截图，供大家参考。其中使用的环境都是 Anaconda 中的 Python，直接安装的 Python 也可按照相同的方法指定环境路径并定位所需的 Python 文件。<br><img src="/images/macOS%20%E9%85%8D%E7%BD%AE.png" alt="macOS 配置"><br>macOS 配置<br><img src="/images/Windows%20%E9%85%8D%E7%BD%AE.png" alt="Windows 配置"><br>Windows 配置</p>
<h4 id="3-4-安装-reapy-并测试"><a href="#3-4-安装-reapy-并测试" class="headerlink" title="3.4. 安装 reapy 并测试"></a>3.4. 安装 reapy 并测试</h4><p>因为 conda-forge 中没有 reapy，所以 reapy 可以通过以下两种方式安装：</p>
<ol>
<li>没有 Conda 的话，直接执行 <code>pip install python-reapy</code> 在本地 pip 环境中安装 reapy。</li>
<li>有 Conda 的话，同样执行上述命令，在 Conda 的 pip 环境中安装 reapy。</li>
</ol>
<p>安装完毕之后，打开 Reaper，在终端中执行 <code>python -c &quot;import reapy; reapy.configure_reaper()&quot;</code>。这一步的目的是为了初始化 reapy，同时添加脚本 activate_reapy_server.py，它是 reapy 在 Reaper 外部使用的前提，会在外部调用的时候持续保持运行。<br>作为测试，在 Reaper 内外均可执行以下语句观察执行效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reapy</span><br><span class="line">reapy.test_api()</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/%E5%9C%A8%E5%86%85%E5%A4%96%E5%90%8C%E6%97%B6%E6%89%A7%E8%A1%8C.png" alt="在内外同时执行"><br>在 VS Code 和 Reaper 内分别执行同样的代码<br>我们会发现，都得到了一样的返回结果，这代表 reapy 已经配置成功：<br><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-09-18%2002.13.46.png" alt="屏幕快照 2020-09-18 02.13.46"><br>测试结果</p>
<h2 id="reapy-解析"><a href="#reapy-解析" class="headerlink" title="reapy 解析"></a>reapy 解析</h2><h3 id="4-1-开发理念"><a href="#4-1-开发理念" class="headerlink" title="4.1. 开发理念"></a>4.1. 开发理念</h3><p>reapy 由 Roméo Després 开发，他现在是华纳音乐（法国）的数据分析师，也曾在 IRCAM 工作过。<br>reapy 的核心开发理念就是为了解决 ReaScript 在 Python 下糟糕的使用体验，比如毫不 Pythonic 的 API 设计，通过修饰完成了面向对象层的重设计。这也是目前唯一一个活跃的 Python 版 ReaScript 项目。<br><strong>对于普通用户而言，最直观的感受就是部分常用 API 变的简单易用了，</strong>因为 API 经过装饰后的易用性变的非常好。而未经过处理的 API 的也可继续使用不带 RPR_ 前缀的原名进行调用，<br>对于不想费时间学习 EEL 或 Lua 的 Python 程序员来说，reapy 是个非常友善的切入点。<br><strong>当然，reapy 也有缺点。</strong>因为现在都没开发到 V1.0 版本，所以只有主要的 API 完成了装饰，根据需求复杂程度可能还需混合使用新旧 API。</p>
<h3 id="4-2-简单实例"><a href="#4-2-简单实例" class="headerlink" title="4.2. 简单实例"></a>4.2. 简单实例</h3><p>在 3.4. 小节中我们提到了测试 API 的用法，在原生的 Python 版 ReaScript 中的 <code>RPR_APITest()</code>，在 reapy 中只需写成 <code>reapy.test_api()</code> 即可。<br>大家还记得，上一篇文章中用脚本复刻了一条 Action 的功能 <code>Item edit: Move position of item under mouse to edit cursor</code>，这是之前的 Lua 版代码：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> r = reaper</span><br><span class="line"></span><br><span class="line">r.Undo_BeginBlock()</span><br><span class="line"></span><br><span class="line">item = r.BR_GetMouseCursorContext_Item()</span><br><span class="line">cursor_pos = r.GetCursorPosition()</span><br><span class="line">r.SetMediaItemInfo_Value(item, <span class="string">"D_POSITION"</span>, cursor_pos)</span><br><span class="line"></span><br><span class="line">r.Undo_EndBlock()</span><br></pre></td></tr></table></figure></p>
<p>如果用 Python 配合原生 ReaScript API 来写会是这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RPR_Undo_BeginBlock()</span><br><span class="line"></span><br><span class="line">item = BR_GetMouseCursorContext_Item()</span><br><span class="line">cursor_pos = RPR_GetCursorPosition()</span><br><span class="line">RPR_SetMediaItemInfo_Value(item, <span class="string">"D_POSITION"</span>, cursor_pos)</span><br><span class="line"></span><br><span class="line">RPR_Undo_EndBlock()</span><br></pre></td></tr></table></figure></p>
<p>现在我们用 reapy 在 Reaper 内重写一遍代码，看看与之的版本有什么区别。当然，这段代码在 Reaper 外执行也是可以的，只是在外面执行时 <code>r.perform_action(40528)</code> 这句是没有意义的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reapy <span class="keyword">as</span> r</span><br><span class="line"><span class="keyword">from</span> reapy <span class="keyword">import</span> reascript_api <span class="keyword">as</span> rpr</span><br><span class="line"><span class="comment"># 获取当前工程</span></span><br><span class="line">proj = r.Project()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Undo Block 开始</span></span><br><span class="line">proj.begin_undo_block()</span><br><span class="line"><span class="comment"># reapy 中使用第三方 API 有些问题（虽然老版文档说 reascript_api 中可用所有的第三方 API），所以这里使用 reapy 装饰后的 Main_OnCommand 执行 Action（Item: Select item under mouse cursor）以获取鼠标下的对象</span></span><br><span class="line">r.perform_action(<span class="number">40528</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取鼠标下的对象并对返回值加以处理为 str，给 SetMediaItemInfo_Value 的参数做好准备。</span></span><br><span class="line">item = str(proj.get_selected_item(<span class="number">0</span>))</span><br><span class="line">item = eval(item.strip(<span class="string">'Item()'</span>))</span><br><span class="line"><span class="comment"># 获取当前游标位置</span></span><br><span class="line">cursor_pos = proj.cursor_position</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以前的 API 也可在 reascript_api 直接引用，目前 reapy 还没加入 item.set_info_value(param_name, param_value)语法，所以这步略显麻烦</span></span><br><span class="line">rpr.SetMediaItemInfo_Value(item, <span class="string">"D_POSITION"</span>, cursor_pos)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Undo Block 结束</span></span><br><span class="line">proj.end_undo_block()</span><br></pre></td></tr></table></figure></p>
<p>从这段重写的代码中可看出：</p>
<ol>
<li>大多数 API 都被装饰过了，调用起来更符合 Python 的风格，也更加面向对象。</li>
<li>对于没装饰的 API，也提供了去除恼人前缀的调用方式。</li>
</ol>
<p>对于一个还在持续开发中的第三方库来说，我还是非常期待它做到 V1.0 能做到多么完善。但即使是如此，现在的使用体验也很不错。</p>
<h3 id="4-3-reapy-文档的阅读方法-Translation-Table"><a href="#4-3-reapy-文档的阅读方法-Translation-Table" class="headerlink" title="4.3. reapy 文档的阅读方法 - Translation Table"></a>4.3. reapy 文档的阅读方法 - Translation Table</h3><p><strong>ReaScript 的文档非常杂乱无章，</strong>很多时候只能靠搜索碰运气，所以第一篇文中我们提到了优化版文档以供大家更快的查询所需 API。而对于 reapy，它也有一套自己的文档。<br>地址：<a href="https://python-reapy.readthedocs.io/en/latest/api_table.html" target="_blank" rel="noopener">https://python-reapy.readthedocs.io/en/latest/api_table.html</a><br><img src="/images/reapy%20%E6%96%87%E6%A1%A3.png" alt="reapy 文档"></p>
<p><strong>在文档左边可以看到入门指南的 Api guide、安装指南、模块索引等章节，通常查询 API 需要面对的章节就是我给出的 Translation Table。</strong><br>reapy 的 API 分类是根据 Mespotine 的 ReaScript API 分类而定，不过可惜 Mespotine 的 API 分类原网页已经失效。<br>往下翻，我们会看到 API 中存在对应关系，<strong>右边的列代表了 reapy 中的装饰 API</strong>，而左边代表 ReaScript 中的原 API。<br><img src="/images/%E6%96%87%E6%A1%A3%E5%AE%9E%E4%BE%8B2.png" alt="文档实例2"></p>
<p>使用 reapy 来开发脚本，在 Translation Table 中应优先使用 reapy 版的 API 以获得更好的 Python 编程体验。<br>目前的 reapy 还没有完成全部的 API 装饰，不过绝大多数常用的都已完成。其中的函数有两种简单用法：</p>
<ol>
<li>已经具有 reapy 装饰的，执行 <code>reapy.function_name()</code>。当然，也可以重命名 reapy 后执行如 <code>r.function_name()</code> 这样的语句。</li>
<li>还没有 reapy 装饰的，可执行 <code>from reapy import reascript_api</code> 以从 reascript_api 中导入子模块后再使用。因为此子模块名字较长，可根据自己的喜好重命名，比如命名为 rpr，那么函数的调用就是 <code>rpr.raw_function_name()</code>。</li>
</ol>
<h3 id="4-4-reapy-文档的阅读方法-Module-Index"><a href="#4-4-reapy-文档的阅读方法-Module-Index" class="headerlink" title="4.4. reapy 文档的阅读方法 - Module Index"></a>4.4. reapy 文档的阅读方法 - Module Index</h3><p><strong>此外，reapy 的设计重点是让 ReaScript 更加的 Pythonic，</strong>所以使用时会发现它存在一种分层级的 API 管理逻辑。比如当你对 audio 或 midi 类对象执行的操作时，可以直接从 Module Index 找到对应的对象看看它都封装了什么方法，之后直接对对象执行相应的方法即可，不必再像传统的 ReaScript 设计流程那样把 Get 出的对象反复的作为参数传递。<br>我目前的使用习惯是以 Translation Table 为主要 API 搜索页面，Module Index 则在对某一类对象进行操作时去参考它目前封装的功能。<br><img src="/images/%E6%96%87%E6%A1%A3%E5%B1%82%E7%BA%A7.png" alt="文档层级"><br>文档中的 Module Index</p>
<p>下面通过实例看看这些层级的使用，我引用一些比较常用的 API 以供参考。<br>当执行 <code>import reapy</code>，会默认导入 reapy.core.reaper.reaper 内所有的函数，是常见工程级操作的顶层层级。<strong>事实上 reapy 的层级位置在文档中是 reaper.core.reaper，所以以此开头的 audio、defer、midi、ui 等需通过 reapy.audio、reapy.midi 的方法来调用。</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reapy <span class="keyword">as</span> r</span><br><span class="line"></span><br><span class="line"><span class="comment"># reapy 顶层封装的功能</span></span><br><span class="line">r.print(<span class="string">"Hello Reaper!"</span>) <span class="comment"># 控制台输出</span></span><br><span class="line">r.clear_console() <span class="comment"># 清除控制台</span></span><br><span class="line">r.perform_action(action_id) <span class="comment"># 调用 Action</span></span><br><span class="line">r.open_project(filepath) <span class="comment"># 打开工程</span></span><br><span class="line">r.get_reaper_version() <span class="comment"># 获取 Reaper 版本</span></span><br><span class="line">r.set_global_automation_mode(mode) <span class="comment"># 设置全局 Automation 模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一种常见用法，以轨道对象举例，首先要获取一个轨道对象，可通过名字或轨道编号获取</span></span><br><span class="line">track = r.proj.tracks[num <span class="keyword">or</span> name]</span><br><span class="line"><span class="comment"># 获取轨道对象后，就可对它执行 reapy.core.Track() 类中封装的所有方法了。对 Item 对象来说也是同理</span></span><br><span class="line">track.GUID <span class="comment"># 获取 GUID</span></span><br><span class="line">track.add_item(start=<span class="number">0</span>, end=<span class="keyword">None</span>, length=<span class="number">0</span>) <span class="comment"># 添加 item 对象并返回它</span></span><br><span class="line">track.delete() <span class="comment"># 删除轨道</span></span><br><span class="line">track.get_info_value(param_name) <span class="comment"># 获取指定属性值</span></span><br><span class="line">track.set_info_value(param_name, param_value) <span class="comment"># 设置指定属性值</span></span><br><span class="line">track.solo() <span class="comment"># Solo 轨道</span></span><br><span class="line">track.mute() <span class="comment"># Mute 轨道</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 MIDI 对象进行各种操作</span></span><br><span class="line">r.midi.get_active_editor() <span class="comment"># 返回活动的 MIDI 编辑器</span></span><br><span class="line">r.midi.get_input_names() <span class="comment"># 获得所有 MIDI 输入通道名</span></span><br><span class="line">r.midi.get_n_inputs() <span class="comment"># 返回 MIDI 输入通道数</span></span><br><span class="line">r.midi.reinit() <span class="comment"># 重置所有 MIDI 设备</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对包络线对象进行各种操作</span></span><br><span class="line">r.Envelope.name() <span class="comment"># 返回包络线名字</span></span><br><span class="line">r.Envelope.get_value(time, raw=<span class="keyword">False</span>) <span class="comment"># 获取包络线指定时间点上的值</span></span><br><span class="line">r.Envelope.n_points() <span class="comment"># 获取包络线中的点位数</span></span><br><span class="line">r.Envelope.add_item(position=<span class="number">0.0</span>, length=<span class="number">1.0</span>, pool=<span class="number">0</span>) <span class="comment"># 创建新的包络线对象</span></span><br></pre></td></tr></table></figure></p>
<p><strong>reapy.tools，其中的 <code>inside_reaper()</code> 用于提高外部调用 ReaScript 时的性能。</strong>因为 ReaScript 外部引用是运行在 defer loop 之中的，执行效率比 Native ReaScript 差很多，只有每秒不到60次的执行效率，在进行重复次数很多的操作时会有很大性能影响。<br>为了解决这个问题，需要使用 <code>reapy.tools.inside_reaper</code> 模块，它的功能是把这部分代码通过自带的服务器脚本放到 Reaper 内部环境执行，再把结果取回外部。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reapy <span class="keyword">as</span> r</span><br><span class="line"></span><br><span class="line">project = r.Project() <span class="comment"># 获取当前工程对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求1000次工程的 BPM，直接在外部调用需要半分钟以上</span></span><br><span class="line">bpms = [project.bpm <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 inside_reaper() 后命令会从内部运行这段代码，只需0.1秒</span></span><br><span class="line"><span class="keyword">with</span> r.inside_reaper():</span><br><span class="line">     bpms = [project.bpm <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br></pre></td></tr></table></figure></p>
<p><code>reapy.config</code> 内定义了有关 reapy 开关和 Web 接口的内容，普通用户可以不用在意。<br><code>reapy.errors</code> 包括各种报错信息，可与 Python 的异常处理语句合用。</p>
<h2 id="实现一个简单的根据文件名导入-Reaper-的-GUI-程序"><a href="#实现一个简单的根据文件名导入-Reaper-的-GUI-程序" class="headerlink" title="实现一个简单的根据文件名导入 Reaper 的 GUI 程序"></a>实现一个简单的根据文件名导入 Reaper 的 GUI 程序</h2><p>我们都知道，批量的文件处理（比如对于游戏语音对白）所需的导入文件，均匀设置对象间隔及按区域导出这些功能对于 Reaper 来说是非常简单就能做到的。<br>为了演示 reapy 在外部的完整运行效果，<strong>假设一个需求，使用 ReaScript 导入文件，并能够要根据需求设定不同的属性值及效果器。</strong>通过让录音师进行规范的命名，在导入 Reaper 的时候可以轻松做到这件事。<strong>在这里设定文件名的格式为 <code>&lt;ItemName&gt;_&lt;Volume&gt;_&lt;FX&gt;.wav</code></strong></p>
<ul>
<li>注意：出于篇幅限制，只在示例文件名中定义一个属性和一个效果器，有更多的需求只需扩展代码即可。对于直接引入效果器链的方法不加以讨论，有兴趣的朋友可以自行改写 ReaPack 中的脚本 <code>mpl_Add FXChain to selected track</code>，将其从文件浏览器中选择效果器链的方法改成引入用户指定的效果器链文件名即可。</li>
</ul>
<h3 id="5-1-抽象功能逻辑"><a href="#5-1-抽象功能逻辑" class="headerlink" title="5.1. 抽象功能逻辑"></a>5.1. 抽象功能逻辑</h3><p>为了演示，首先建立两个示例文件：<br><code>Player_Heavy_Hit_12_-3_ReaEQ.wav</code><br><code>UI_Bright_Button_01_-5_ReaDelay.wav</code><br>音效文件的命名对于下划线使用的非常广泛，这里假设在已有文件名的最后加入两个下划线后缀，分别指定为音量与效果器的属性。<br>于是我们抽象出功能逻辑：</p>
<ol>
<li>使用 Python 读取文件名中的信息，并且暂存到容器中</li>
<li>使用 Reaper 在当前工程中插入新轨道</li>
<li>对轨道设置属性</li>
<li>对轨道设置 FX</li>
</ol>
<h3 id="5-2-选用-API"><a href="#5-2-选用-API" class="headerlink" title="5.2. 选用 API"></a>5.2. 选用 API</h3><ol>
<li>使用 Python 读取文件名中的信息，并且暂存到容器中：略</li>
<li>使用 Reaper 在当前工程中插入新轨道：InsertMedia()</li>
<li>对轨道设置属性：set_info_value()</li>
<li>对轨道设置 FX：add_fx()</li>
</ol>
<h3 id="5-3-实现功能代码"><a href="#5-3-实现功能代码" class="headerlink" title="5.3. 实现功能代码"></a>5.3. 实现功能代码</h3><p>使用 Python 读取文件名中的信息，暂存到一个提取好信息的字典中，并把所有字典放进一个列表中方便管理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">dict_list = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每一个文件进行参数获取，并存为一个字典</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dict</span><span class="params">(input_path)</span>:</span></span><br><span class="line">    <span class="comment"># 源文件名，如 `UI_Bright_Button_01_-5_C1.wav`</span></span><br><span class="line">    raw_file_name = input_path.split(os.sep)[<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># 指定音量</span></span><br><span class="line">    volume = raw_file_name.split(<span class="string">"_"</span>)[<span class="number">-2</span>]</span><br><span class="line">    <span class="comment"># 指定效果器链</span></span><br><span class="line">    fx = raw_file_name.split(<span class="string">"."</span>)[<span class="number">0</span>].split(<span class="string">"_"</span>)[<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># 原文件名中的完整文件名，如 `UI_Bright_Button_01.wav`</span></span><br><span class="line">    new_file_name = raw_file_name.rsplit(<span class="string">'_'</span>, <span class="number">2</span>)[<span class="number">0</span>] + <span class="string">"."</span> + input_path.split(<span class="string">"."</span>)[<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># 参数字典</span></span><br><span class="line">    info_dict = &#123;<span class="string">"path"</span>: input_path, <span class="string">"new_file_name"</span>: new_file_name, <span class="string">"volume"</span>: volume, <span class="string">"fx"</span>: fx&#125;</span><br><span class="line">    dict_list.append(info_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对文件夹内所有 wav 文件执行操作，并调用 get_dict() 函数提取信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file</span><span class="params">(input_folder)</span>:</span></span><br><span class="line">    file_end = []</span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(input_folder):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(input_folder):</span><br><span class="line">            file_end.append(os.path.splitext(file)[<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">'.wav'</span>):</span><br><span class="line">                get_dict(input_folder + os.sep + file)</span><br><span class="line">        insert_media(dict_list)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'.wav'</span> <span class="keyword">in</span> file_end:</span><br><span class="line">            sg.popup(<span class="string">'Processing Complete.'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sg.popup(<span class="string">'No wave file be found!'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sg.popup(<span class="string">'Check your input!'</span>)</span><br></pre></td></tr></table></figure></p>
<p>从该文件夹的字典列表分别读出每个文件的属性，准备对对应的属性进行设置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reapy</span><br><span class="line"><span class="keyword">from</span> reapy <span class="keyword">import</span> reascript_api <span class="keyword">as</span> rpr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_media</span><span class="params">(dict_list)</span>:</span></span><br><span class="line">    <span class="comment"># 获取当前工程</span></span><br><span class="line">    proj = reapy.Project()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> dict <span class="keyword">in</span> dict_list:</span><br><span class="line">        <span class="comment"># 从列表中的每个字典里读取相应数据</span></span><br><span class="line">        path = dict[<span class="string">"path"</span>]</span><br><span class="line">        new_file_name = dict[<span class="string">"new_file_name"</span>]</span><br><span class="line">        volume = dict[<span class="string">"volume"</span>]</span><br><span class="line">        fx = dict[<span class="string">"fx"</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 插入媒体到新轨道</span></span><br><span class="line">        rpr.InsertMedia(path, <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取轨道对象</span></span><br><span class="line">        num = proj.n_tracks - <span class="number">1</span></span><br><span class="line">        track = proj.tracks[num]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置轨道名，音量（含分贝换算及取小数），增加效果器</span></span><br><span class="line">        track.name = new_file_name.split(<span class="string">"."</span>)[<span class="number">0</span>]</span><br><span class="line">        track.set_info_value(<span class="string">"D_VOL"</span>, round((<span class="number">10</span> ** (int(volume) / <span class="number">20</span>)), <span class="number">2</span>))</span><br><span class="line">        track.add_fx(fx)</span><br></pre></td></tr></table></figure></p>
<p>设置 Render Matrix 并自动导出文件：<br>略，如感兴趣可参考 X-Raym 的 ReaScripts: Render Region Matrix Pack，他的脚本是图形界面中键鼠选取对象后再执行的，想在纯代码层面实现只需把这个多轨选择做到 API 里就行了。</p>
<h3 id="5-4-实现-GUI-代码"><a href="#5-4-实现-GUI-代码" class="headerlink" title="5.4. 实现 GUI 代码"></a>5.4. 实现 GUI 代码</h3><p>这里做一个最简单的文件夹选择器，并通过 popup 窗口以显示成功及报错信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gui</span><span class="params">()</span>:</span></span><br><span class="line">    layout = [  [sg.Text(<span class="string">'Browse Folders'</span>)],</span><br><span class="line">                [sg.Input(), sg.FolderBrowse(<span class="string">'Browse'</span>, key=<span class="string">'folder'</span>)],</span><br><span class="line">                [sg.Button(<span class="string">'Import'</span>), sg.Button(<span class="string">'Cancel'</span>)] ]</span><br><span class="line">    </span><br><span class="line">    window = sg.Window(<span class="string">'Reaper Importer'</span>, layout)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        event, values = window.read()</span><br><span class="line">        <span class="keyword">if</span> event <span class="keyword">in</span> (<span class="keyword">None</span>, <span class="string">'Cancel'</span>): </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> event == <span class="string">'Import'</span>:</span><br><span class="line">            <span class="keyword">if</span> values[<span class="string">'folder'</span>]:</span><br><span class="line">                get_file(values[<span class="string">'folder'</span>])</span><br><span class="line">                sg.popup(<span class="string">'Done!'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sg.popup(<span class="string">'Choose some folder first!'</span>)</span><br><span class="line">    </span><br><span class="line">    window.close()</span><br></pre></td></tr></table></figure></p>
<h3 id="5-5-连接-GUI-代码与功能代码"><a href="#5-5-连接-GUI-代码与功能代码" class="headerlink" title="5.5. 连接 GUI 代码与功能代码"></a>5.5. 连接 GUI 代码与功能代码</h3><p>为了节省篇幅，函数体省略。因为这个程序比较简单，所以可不通过 <code>inside_reaper()</code> 改善性能。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"><span class="keyword">import</span> reapy</span><br><span class="line"><span class="keyword">from</span> reapy <span class="keyword">import</span> reascript_api <span class="keyword">as</span> rpr</span><br><span class="line">dict_list = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file</span><span class="params">(input_folder)</span>:</span></span><br><span class="line">    Function body</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dict</span><span class="params">(input_path)</span>:</span></span><br><span class="line">    Function body</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_media</span><span class="params">(list)</span>:</span></span><br><span class="line">    Function body</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gui</span><span class="params">()</span>:</span></span><br><span class="line">    Function body</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>    </span><br><span class="line">    gui()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<h3 id="5-6-运行结果"><a href="#5-6-运行结果" class="headerlink" title="5.6. 运行结果"></a>5.6. 运行结果</h3><p>建立一个新的工程并执行程序，可看到程序窗口已打开。<br><img src="/images/%E6%89%A7%E8%A1%8C%E5%89%8D.png" alt="执行前"><br>执行前<br>接下来浏览到测试文件的文件夹，并点击 Import。发现文件已经自动被导入（这两个文件是粘贴自同一文件，所以波形相同），并且已设置了音量（可见音量旋钮略往左）和挂载了设置的效果器。<br><img src="/images/%E6%89%A7%E8%A1%8C%E5%90%8E.png" alt="执行后"><br>执行后</p>
<h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2><p>目前的两篇文章已经把 ReaScript 大概过了一遍，读者看后应该已有足够的基础去开发自己的脚本了。因为我暂时不准备在 EEL 上投入时间，所以这部分暂时不会涉及。<br>接下来《补完 Reaper 效率链的最后一环》专栏会有以下几个更新方向：</p>
<ol>
<li>开发技巧补遗，关于 API 的选用和复杂的脚本设计技巧还有很多值得谈的部分。</li>
<li>拆解优质脚本，与大家共同分析它们的代码。</li>
<li>分享我的自制脚本。</li>
</ol>
<p>如果大家有兴趣，欢迎持续关注！</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">溪夜</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://xiye.art/2020/09/21/如何使用 ReaScript 进一步改善 Reaper 效率？（二）/">http://xiye.art/2020/09/21/如何使用 ReaScript 进一步改善 Reaper 效率？（二）/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://xiye.art" target="_blank">溪夜的音频博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Reaper/">Reaper</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/09/25/WAAPI 一文通（三）/"><i class="fa fa-chevron-left">  </i><span>人人都能用 WAAPI（三）wwise.ui、wwise.waapi、wwise.debug、soundengine 分支</span></a></div><div class="next-post pull-right"><a href="/2020/09/20/如何使用 ReaScript 进一步改善 Reaper 效率？（一）/"><span>补完 Reaper 效率链的最后一环（一）ReaScript 基础</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC80MDk4Ny8xNzUxMg=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By 溪夜</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>