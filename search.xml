<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>iOS 音乐制作导论</title>
      <link href="/2020/12/05/iOS%20%E9%9F%B3%E4%B9%90%E5%88%B6%E4%BD%9C%E5%AF%BC%E8%AE%BA/"/>
      <url>/2020/12/05/iOS%20%E9%9F%B3%E4%B9%90%E5%88%B6%E4%BD%9C%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>在去年的模块合成器交流方式上我结识了 Dancing K 老师，除了在传统音乐制作领域的成就（IK、CME、Arturia 品牌推广大使，前 Novation 代言人），他在 iOS 音乐制作领域更是深耕多年。<br>基于在 iOS 移动音乐制作上的兴趣，我决定利用业余时间与 DK 老师合作，共同推广移动音乐制作技术。<br><strong>国内似乎并没有一个像样的 iOS 音乐制作导论类介绍，我把上半年整理学习的 iOS 音乐制作相关内容写为一篇文章与大家分享，希望能为移动音乐制作领域添砖加瓦。</strong></p><p>本文目录：</p><p>[toc]</p><h2 id="iOS-音乐制作与电脑平台音乐制作的区别"><a href="#iOS-音乐制作与电脑平台音乐制作的区别" class="headerlink" title="iOS 音乐制作与电脑平台音乐制作的区别"></a>iOS 音乐制作与电脑平台音乐制作的区别</h2><h2 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h2><h2 id="插件间的数据交换方式"><a href="#插件间的数据交换方式" class="headerlink" title="插件间的数据交换方式"></a>插件间的数据交换方式</h2><h2 id="iOS-端音乐制作软件概览"><a href="#iOS-端音乐制作软件概览" class="headerlink" title="iOS 端音乐制作软件概览"></a>iOS 端音乐制作软件概览</h2><h3 id="常见宿主"><a href="#常见宿主" class="headerlink" title="常见宿主"></a>常见宿主</h3><h3 id="常见效果器"><a href="#常见效果器" class="headerlink" title="常见效果器"></a>常见效果器</h3><h3 id="常用音源"><a href="#常用音源" class="headerlink" title="常用音源"></a>常用音源</h3><h3 id="软硬结合调音台"><a href="#软硬结合调音台" class="headerlink" title="软硬结合调音台"></a>软硬结合调音台</h3><h3 id="必备网站"><a href="#必备网站" class="headerlink" title="必备网站"></a>必备网站</h3><h2 id="iOS-如何与电脑端宿主实现工程交换？"><a href="#iOS-如何与电脑端宿主实现工程交换？" class="headerlink" title="iOS 如何与电脑端宿主实现工程交换？"></a>iOS 如何与电脑端宿主实现工程交换？</h2><h2 id="为什么要玩-iOS？"><a href="#为什么要玩-iOS？" class="headerlink" title="为什么要玩 iOS？"></a>为什么要玩 iOS？</h2><h2 id="接下来将什么"><a href="#接下来将什么" class="headerlink" title="接下来将什么"></a>接下来将什么</h2>]]></content>
      
      
      
        <tags>
            
            <tag> iOS 音乐制作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我所理解的技术音频技能路线</title>
      <link href="/2020/12/01/%E6%8A%80%E6%9C%AF%E9%9F%B3%E9%A2%91%E7%9A%84%E6%8A%80%E8%83%BD%E8%B7%AF%E7%BA%BF/"/>
      <url>/2020/12/01/%E6%8A%80%E6%9C%AF%E9%9F%B3%E9%A2%91%E7%9A%84%E6%8A%80%E8%83%BD%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br><strong>游戏技术音频领域一直是我非常感兴趣的方向</strong>，这也是在书单《游戏音频与声音设计相关书籍推荐》文中专门列出技术音频相关书目的原因。<br>近日有感于希辰老师的<strong>《游戏音频设计师、技术音频设计师和音频程序员》</strong>一文，想谈谈我认为的“游戏技术音频”相关定义和技能路线。<br>这篇文章包含我最近一年多对技术音频职业的思考，及已经掌握和正准备学习的技能。希望能在国内这个相对较新的职业领域中分享一份我自己的总结，如有遗漏欢迎指出，期待与大家共同交流。</p><blockquote><p>附《游戏音频设计师、技术音频设计师和音频程序员》阅读地址：<a href="https://zhuanlan.zhihu.com/p/295783076" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/295783076</a></p></blockquote><p>本文目录：</p><p>[toc]</p><h2 id="职业定义的思索"><a href="#职业定义的思索" class="headerlink" title="职业定义的思索"></a>职业定义的思索</h2><h3 id="1-1-Technical-Audio-Designer-或-Technical-Sound-Designer（技术音频设计师）"><a href="#1-1-Technical-Audio-Designer-或-Technical-Sound-Designer（技术音频设计师）" class="headerlink" title="1.1. Technical Audio Designer 或 Technical Sound Designer（技术音频设计师）"></a>1.1. Technical Audio Designer 或 Technical Sound Designer（技术音频设计师）</h3><p>这两者都可指代技术音频设计师，第一次见到 Technical Audio Designer 的说法是在育碧的 JD 中，而见到 Technical Sound Designer 则是在 Damian Kastbauer 老师的书名中。<br>在这里默认两者都指代技术音频设计师，不讨论是否存在谁偏向资源制作，谁偏向音频播放规则设计的话题。<br>我想反思的是技术音频的“职责“，把职业方向定位为技术音频设计师<strong>不应是对其他工种的逃避或看这职业缺人就急着扎进来，而应该是因为有着对掌握更全面的游戏音频技能的追求。</strong>希辰老师在文章中就曾说到“这种分工可能会把游戏音频设计变得没那么好玩了”，这点我深以为然。<br>因为对技术有更深入的追求，不是仅仅做资源了事，而是想把制作、整合、Debug、效率提升的整套流程全部跑通，所以才自然而然的走到了游戏技术音频领域，私以为这才是一个比较正常的职业发展路线。</p><h3 id="1-2-Game-Audio-Programmer（音频程序员）"><a href="#1-2-Game-Audio-Programmer（音频程序员）" class="headerlink" title="1.2. Game Audio Programmer（音频程序员）"></a>1.2. Game Audio Programmer（音频程序员）</h3><p>普遍意义上的 Audio Programmer 会更偏向底层一些，工作中会涵盖 DSP、音频算法、效果器和虚拟乐器的实现等知识。<strong>这也是为什么我用 Game Audio Programmer 而不是 Audio Programmer 称呼的原因，</strong>对于游戏音频程序员来说，这样描述更加准确。<br>个人认为 Game Audio Programmer 与 Technical Sound Designer 的工作界限可能更为接近于“渐变”的关系，即 Technical Sound Designer 应该是 Game Audio Programmer 的过度。停留在开发小工具和做声音设计师与程序之间的润滑油可以是一个中间态，<strong>不停止对更完善的技术进行探索才是有趣的前进方向。</strong></p><h2 id="游戏引擎及中间件技能"><a href="#游戏引擎及中间件技能" class="headerlink" title="游戏引擎及中间件技能"></a>游戏引擎及中间件技能</h2><h3 id="2-1-游戏引擎"><a href="#2-1-游戏引擎" class="headerlink" title="2.1. 游戏引擎"></a>2.1. 游戏引擎</h3><h4 id="2-1-1-引擎使用"><a href="#2-1-1-引擎使用" class="headerlink" title="2.1.1. 引擎使用"></a>2.1.1. 引擎使用</h4><p>常见商业引擎的使用绝对是最基础的要求，除非自我定位为只做资源的“音效资源机器“，否则至少根据项目要求 Unity 与 Unreal Engine 其一需要掌握完整的使用方法。此外并非了解简单的操作就完了，而应该找个小游戏项目从制作、整合、打包完全跑一遍。<br>在此之外闲暇之余看看 CryEngine、Godot 乃至 Armory、Defold、GameMaker 等引擎中的音频实现无疑也是有趣的事，不过还是以项目为主，着重在当前项目所使用的的目标中发力，这也是音频集成的基础。</p><h4 id="2-1-2-无中间件的音频集成"><a href="#2-1-2-无中间件的音频集成" class="headerlink" title="2.1.2. 无中间件的音频集成"></a>2.1.2. 无中间件的音频集成</h4><p>这里谈到的音频实现是指<strong>用引擎本身的音频功能完成游戏声音整合</strong>，虽然不少项目都上了音频中间件，但我认为传统手艺不能丢，万一赶上简单的项目需要全盘用引擎本身的音频功能实现岂不抓瞎？<br>本人的音频进阶计划中就包括如何用各大引擎自带的音频功能，去复刻中间件可复刻的一些实现以此加强对引擎本身音频整合的了解。</p><h4 id="2-1-3-热更新"><a href="#2-1-3-热更新" class="headerlink" title="2.1.3. 热更新"></a>2.1.3. 热更新</h4><p>对于手游项目，热更新是离不开的问题。如何根据项目现有热更新框架，实现音频资源和代码的热更新是必须了解的。<br>这也是技术音频设计师全局观的体现，提交完当前的版本后还需考虑后续的小版本更新与大版本迭代如何搞定，并在过程中 Debug 以保证正常的版本交接。</p><h3 id="2-2-音频中间件"><a href="#2-2-音频中间件" class="headerlink" title="2.2. 音频中间件"></a>2.2. 音频中间件</h3><h4 id="2-2-1-中间件使用"><a href="#2-2-1-中间件使用" class="headerlink" title="2.2.1. 中间件使用"></a>2.2.1. 中间件使用</h4><p>三大商业音频中间件 Wwise、FMOD、CRIWARE ADX2 一定要根据项目所需学透，把文档整体过一遍更是必须完成的工作。<br><strong>泛读并非为了显摆自己的学习能力，而是通过泛读并整理后知道一些“不知道自己不知道”的知识，从而扩大自己的“知识视野”</strong>，以便于在工作中出现疑惑时脑子里蹦出一个关键词提醒自己这个问题还可以这么解决。<br>在使用 Wwise 的时候我就发现太多问题是因为自己没通读文档、官方 Blog、没勤翻问答区的常见问题等，这些都是提升中间件掌握的好途径。<br>除此之外，Fabric 作为一个相对以上三者来说，授权费更便宜一些的音频中间件，也可以作为“茶余饭后”去了解一下的中间件甜点。</p><h4 id="2-2-2-音频整合与优化"><a href="#2-2-2-音频整合与优化" class="headerlink" title="2.2.2. 音频整合与优化"></a>2.2.2. 音频整合与优化</h4><p>整合音频无疑是最重要的，中间件提供的集成包本身会提供方便的音频部署机制。<br>但自定义脚本乃至调用底层 SDK 仍然是要掌握的部分，<strong>了解集成包底层的调用规则对理解中间件工作原理与 Debug 无疑很有帮助。</strong>从这点来说，看一下集成包的实现代码也是有必要的。<br>此外，如果想要作出更为复杂的音频效果，尤其是音频或音乐驱动的游戏。对音频 SDK 有深入的认知也是必要的，总有些工作需要直接对着底层发力。</p><h4 id="2-2-3-语音对白"><a href="#2-2-3-语音对白" class="headerlink" title="2.2.3. 语音对白"></a>2.2.3. 语音对白</h4><p>对于游戏中人物对白来说，在大型项目中需要通过 TTS 产生语音临时文件进行占位，也需清楚地记录录制情况，自动化后期处理和批量集成时的繁琐工作。<br>掌握当前技术方案下的 Lip Sync 实现也是一个重要的方向（如果角色有嘴且能动的话）。</p><h2 id="效率优化技能"><a href="#效率优化技能" class="headerlink" title="效率优化技能"></a>效率优化技能</h2><h3 id="3-1-游戏引擎脚本工具开发"><a href="#3-1-游戏引擎脚本工具开发" class="headerlink" title="3.1. 游戏引擎脚本工具开发"></a>3.1. 游戏引擎脚本工具开发</h3><h4 id="3-1-1-Unity-Editor-Scripting"><a href="#3-1-1-Unity-Editor-Scripting" class="headerlink" title="3.1.1. Unity Editor Scripting"></a>3.1.1. Unity Editor Scripting</h4><p>在 Unity 中开发自己的工具需要使用 Editor Scripting，需要在 UnityEditor 命名空间上做文章，实现的工具也是以脚本形式存在的。<br>无论是简单的 Unity 中实现中间件的播放功能预览，或是创建一个独立的音频 Profiler，这些都需要了解如何在 Unity Editor 中创建自定义脚本并为其加上 GUI 以方便用户使用。</p><h4 id="3-1-2-Unreal-Engine-Editor-Scripting"><a href="#3-1-2-Unreal-Engine-Editor-Scripting" class="headerlink" title="3.1.2. Unreal Engine Editor Scripting"></a>3.1.2. Unreal Engine Editor Scripting</h4><p>与 Unity 只能用 C# 开发工具不同，<strong>Unreal Engine 除了可使用本家的 C++，还可以使用蓝图或 Python 来创建脚本工具。</strong><br>对于 C++ 水平尚且一般的我来说，支持其他两种开发方式在跨引擎迁移想法时会减少很多阻力。</p><h3 id="3-2-中间件效率开发"><a href="#3-2-中间件效率开发" class="headerlink" title="3.2. 中间件效率开发"></a>3.2. 中间件效率开发</h3><h4 id="3-2-1-WAAPI-Wwise-Authoring-API"><a href="#3-2-1-WAAPI-Wwise-Authoring-API" class="headerlink" title="3.2.1. WAAPI (Wwise Authoring API)"></a>3.2.1. WAAPI (Wwise Authoring API)</h4><p>WAAPI 作为 Wwise 重要的进阶功能，<strong>它允许用户通过代码快速完成 Wwise 中大多数鼠标键盘才能完成的重复工作，为大家提供了多样的工作流定制的可能性。</strong><br>在我的系列文章《人人都能用 WAAPI》中对 WAAPI 的重要与使用方法进行了讲解，对于技术音频设计师来说，就是要通过 WAAPI 把中间件跟其他音频工作分离的工作尽量整合并提高效率。<br><strong>帮助大家快速对项目所需的工作流完成工具定制，这也是 WAAPI 系列文章的写作目的。</strong></p><h4 id="3-2-2-FMOD-Scripting"><a href="#3-2-2-FMOD-Scripting" class="headerlink" title="3.2.2. FMOD Scripting"></a>3.2.2. FMOD Scripting</h4><p>FMOD 中也有效率提高相关的脚本支持，但与 FMOD API 进行整合时可用的四种编程语言不同，<strong>FMOD Scripting 只能使用 JavaScript 驱动</strong>。<br>对标 WAAPI 的分类，FMOD 的脚本 API 也对应着从全局到细节的各个部分，对于各种效率优化想法都能提供很好的支持可能性。</p><h3 id="3-3-DAW-效率开发"><a href="#3-3-DAW-效率开发" class="headerlink" title="3.3. DAW 效率开发"></a>3.3. DAW 效率开发</h3><h4 id="3-3-1-REAPER-ReaScript"><a href="#3-3-1-REAPER-ReaScript" class="headerlink" title="3.3.1. REAPER + ReaScript"></a>3.3.1. REAPER + ReaScript</h4><p>作为性价比、可扩展性、工作效率都超强的现代宿主，REAPER 在游戏音频行业中现在用户群体愈发壮大。本着一切均可优化的原则，ReaScript 作为 REAPER 的脚本语言支持自然也需要被拿出来提高工作效率。<br>在我的系列文章《补完 REAPER 效率链的最后一环》中，详细的介绍了 ReaScript 的来龙去脉，以及 Python 程序员想要以更 Pythonic 的方式调用 ReaScript，欢迎大家参考。</p><h4 id="3-3-2-Cubase-Nuendo-Logical-Editor"><a href="#3-3-2-Cubase-Nuendo-Logical-Editor" class="headerlink" title="3.3.2. Cubase / Nuendo + Logical Editor"></a>3.3.2. Cubase / Nuendo + Logical Editor</h4><p>虽然 Cubase 没有脚本语言支持，但 Logical Editor 也能提供一部分自动化的解决方案。<br>局部的 <strong>Logical Editor</strong> 可以对 MIDI 进行操作，如一键完成设定好规则的 MIDI 音符操作。全局的 <strong>Project Logical Editor</strong>也可对工程级别进行操作，如一键隐藏所有 MIDI Track 只保留 Audio Track。<br>与 ReaScript 能提供的全范围 API 相比，Logical Editor 更多的是对使用 Cubase / Nuendo 的声音设计师自己的工作流进行优化。所以在进行工具链开发时，Logical Editor 相对而言是无法被集成进去的。</p><h3 id="3-4-通用工具开发"><a href="#3-4-通用工具开发" class="headerlink" title="3.4. 通用工具开发"></a>3.4. 通用工具开发</h3><h4 id="3-4-1-Python-GUI-开发"><a href="#3-4-1-Python-GUI-开发" class="headerlink" title="3.4.1. Python GUI 开发"></a>3.4.1. Python GUI 开发</h4><p>Python 是一门易学难精的语言，但不妨碍它提供给了初学者极快的上手速度。对于技术音频设计师而言，快速敏捷的开发出工具且加上同事都看得懂的 GUI 无疑是很重要的技能。<br>除了在我的系列文章《写给声音设计师的极速 GUI 开发大法》中提到的 GUI 框架封装 PySimpleGUI 外，入门相对友好的 Python GUI 框架还有 DearPyGui，但我认为 DearPyGui 过于简陋。<br><strong>当然，如果想要用户界面彻底符合现代化设计美学，还是要用 PyQt（PySimpleGUI 有 PyQt 版）或 Kivy 这种界面上更为美观的框架。</strong></p><h4 id="3-4-2-Electron"><a href="#3-4-2-Electron" class="headerlink" title="3.4.2. Electron"></a>3.4.2. Electron</h4><p>在与胡磊老师的聊天中得知了 Electron，作为一个桌面应用程序框架，可以使用 JavaScript, HTML 和 CSS 来构建 GUI。其语言结构本身也决定了 Electron 跨平台方面做得很好，而且代码布局结构比较清晰。<br>相对而言，制作整合多个程序且跨平台的大型工具项目，Electron 比 Python 更为适合一些，PySimpleGUI 还是更适合做一些小型项目。</p><h4 id="3-4-3-MFC-WPF-and-more…"><a href="#3-4-3-MFC-WPF-and-more…" class="headerlink" title="3.4.3. MFC, WPF and more…"></a>3.4.3. MFC, WPF and more…</h4><p>无论是 Windows 上的 MFC、WPF 或是 macOS 的 Cocoa，我认为做小工具开发都颇为笨重，而且还根本无法完成跨平台。鉴于本人对 GUI 框架认知较为浅薄，在此就不妄下断言了。</p><h3 id="3-5-日常工作流改进"><a href="#3-5-日常工作流改进" class="headerlink" title="3.5. 日常工作流改进"></a>3.5. 日常工作流改进</h3><p>所谓“日常工作流改进”，可以理解为是技术音频设计师自己的工作流改进，也可以作为工作流优化布道师对团队内其他成员的效率进行优化。<br><strong>作为保姆级的效率优化大师，我相信除了开发工具，为团队成员提供工作流解决方案也是必备的技能之一。</strong></p><h4 id="3-5-1-StreamDeck"><a href="#3-5-1-StreamDeck" class="headerlink" title="3.5.1. StreamDeck"></a>3.5.1. StreamDeck</h4><p><img src="/images/streamdeck.jpg" alt="streamdeck"><br>StreamDeck<br>其实 StreamDeck 在音频与直播圈子里也算是比较广为人知了，<strong>它的主要工作逻辑就是重定义你的工作流，把一切你需要的功能都做到“一键即达”</strong>。<br>简单来说，可以一键搞定快捷键，打开程序，打开网页。复杂一些的话，可以用 StreamDeck 触发 Python 或其他脚本以实现更复杂的功能。</p><h4 id="3-5-2-Metagrid-Keyboard-Maestro"><a href="#3-5-2-Metagrid-Keyboard-Maestro" class="headerlink" title="3.5.2. Metagrid + Keyboard Maestro"></a>3.5.2. Metagrid + Keyboard Maestro</h4><p><img src="/images/metagrid.jpg" alt="metagrid"><br>Metagrid<br>Metagrid 是一款 iOS 上的类似 StreamDeck 的 App，但相比 StreamDeck 而言，<strong>Metagrid 的功能更为自由且开放，得益于 iPad 大屏幕的支持，可以实现更复杂的功能直通车按键。</strong>它可以对每一个应用程序有一套单独的控制页面，新增的 Omni Space 更可随时切换到全局模式以对系统全局进行操作。<br>对于我等 macOS 用户来说，与 Mac 专属软件 Keyboard Maestro 的深度整合，更可让  Metagrid 用户不需要发送 MIDI 信号即可轻易控制 Keyboard Maestro 中的诸多复杂功能（Keyboard Maestro 简单来说就是把 REAPER 的 Action List 功能搬到了 macOS 全局，是一个极其强大的软件，更可与 Apple Script 等联动）。<br>在使用过程中我与开发者 Przemek 有过不少的邮件往来，对 Metagrid 有着深厚的感情。如果你有 iPad 的话，建议买一个试试看，会获得比 StreamDeck 更为优秀的效率提升体验。<br><strong>新版的 Metagrid 还支持从 DAW 中读取时间码，对 DAW 的走带控制愈发完善</strong>。论坛中还可看到大家分享的诸多控制模板，可以拿来即用。并且在交互上进行了大刀阔斧的改良，现在的手势操作逻辑非常方便。</p><h4 id="3-5-3-TouchOSC-与-MIDI-Designer"><a href="#3-5-3-TouchOSC-与-MIDI-Designer" class="headerlink" title="3.5.3. TouchOSC 与 MIDI Designer"></a>3.5.3. TouchOSC 与 MIDI Designer</h4><p><img src="/images/TouchOSC.jpg" alt="TouchOSC"><br>TouchOSC<br><img src="/images/midi%20designer.jpg" alt="midi designer"><br>MIDI Designer<br>与前两者相对固定的按键排布方式不同，<strong>TouchOSC 和 MIDI Designer 均可按照自己的想象随意绘制控制器控件及布局</strong>，这对于控制 DAW 或合成器进行工作时无疑是及其高效的。<br>其中 TouchOSC 支持 OSC 协议，所以实际上还可以玩很多 MIDI 协议做不到的事情，鉴于这篇主讲音频设计工作流提升，在这里就不展开谈 OSC 的强大了。</p><h4 id="3-5-4-Auto-HotKey"><a href="#3-5-4-Auto-HotKey" class="headerlink" title="3.5.4. Auto HotKey"></a>3.5.4. Auto HotKey</h4><p>Auto HotKey 是一门  Windows 下专属的热键脚本语言，<strong>之所以放它上来，是因为 Metagrid 在 Windows 下没有 Keyboard Maestro 的加持有些工作会不太方便。</strong><br>因为 Metagrid 支持通过 MIDI 信息触发指令，所以可以用 Auto HotKey 的很多用户分享的扩展库实现 MIDI IN 的获取，以此让 Metagrid 触发脚本从而实现更为复杂的功能。</p><h2 id="项目管理技能"><a href="#项目管理技能" class="headerlink" title="项目管理技能"></a>项目管理技能</h2><h3 id="4-1-工程架构创建"><a href="#4-1-工程架构创建" class="headerlink" title="4.1. 工程架构创建"></a>4.1. 工程架构创建</h3><p>为新工程创建架构，构建命名规则等宏观的工作，会从要求技术音频设计师有全局观的设计能力。在我看来，这还应该有对可能出现的坑和技术栈需求有一定的预判能力，才是一个完整的大局观的体现。</p><h3 id="4-2-技术文档与-Wiki-写作"><a href="#4-2-技术文档与-Wiki-写作" class="headerlink" title="4.2. 技术文档与 Wiki 写作"></a>4.2. 技术文档与 Wiki 写作</h3><h4 id="4-2-1-思维导图"><a href="#4-2-1-思维导图" class="headerlink" title="4.2.1. 思维导图"></a>4.2.1. 思维导图</h4><p>思维导图的好处不必多说，进行自我或团队的头脑风暴都很有用。<br>在执行工程规划和技术路线安排时候，也可轻松的展示出分支的变化。</p><h4 id="4-2-2-印象笔记、OneNote、有道云笔记、为知笔记及-Notion-等"><a href="#4-2-2-印象笔记、OneNote、有道云笔记、为知笔记及-Notion-等" class="headerlink" title="4.2.2. 印象笔记、OneNote、有道云笔记、为知笔记及 Notion 等"></a>4.2.2. 印象笔记、OneNote、有道云笔记、为知笔记及 Notion 等</h4><p>现代的笔记类软件多有团队协作类功能，其中国人开发的 Notion 近些年尤为火热。<br>个人端使用这些软件可能更多的是做 PKM 和 PIM（个人知识管理和个人信息管理），团队的应用场景下更多的是为了项目交流及团队内训。<br>所以在这部分上，也要有足够的认知以便于随时提供团队级的技术解决方案。</p><h4 id="4-2-3-技术-Wiki"><a href="#4-2-3-技术-Wiki" class="headerlink" title="4.2.3. 技术 Wiki"></a>4.2.3. 技术 Wiki</h4><p>书写工具使用文档和公司内部技术 Wiki 也是一个必备的能力，对于公司内部的技术传承无疑是很重要的，这就要考验大家遣词造句的功底了。<br>文笔稍差不可怕，但中英文混排、标点符号使用、代码注释等基本规则一定要谨慎。<strong>不在意这些小细节，文章写得再好读起来体验也是一坨屎。</strong><br>如果要对外不公开，可以折腾 MoinMoin Wiki、DokuWiki 这种框架。<br>如果不在意公开，个人观点是把技术 Wiki 放在 GitBook 上也是很好的体验（当然，一般来说内部技术 Wiki 都没法公开）。</p><h3 id="4-3-版本管理"><a href="#4-3-版本管理" class="headerlink" title="4.3. 版本管理"></a>4.3. 版本管理</h3><p>版本管理是编程中必须掌握的工具，而对于中间件工程而言，使用 Perforce、Subversion、Git 进行版本控制也是开发中必须要进行的流程。<br>为了降低版本控制时每次传递的文件大小，需要选择性的对工程中不重要的文件进行忽略。</p><h2 id="编程技能"><a href="#编程技能" class="headerlink" title="编程技能"></a>编程技能</h2><p>如果说<strong>技术音频</strong>或<strong>音频程序员</strong>需要会编程，为什么听起来和代码毫无关系的<strong>声音设计师</strong>也要学习编程？<br>对于这个问题，可以从两点解释：<br><strong>第一，学编程不是为了成为“一体机”，而是为了解决自己的工作中可能出现的能用编程解决的问题</strong>。没错，随着工作的细化或许公司会配备专职的“技术音频”来完成工具开发的工作，但当技术音频没法帮忙的时候该怎么办？或当在做公司之外的工作时，还要去求“技术音频大佬”帮写小程序吗？<br>如希辰老师所说，这些本质上就是游戏音频设计师分内的工作，虽然工作细化会导致各种职责愈发清晰，但这不是成为<strong>资源内包人员</strong>的借口。<br>拥抱变化是所有优秀人才必备的能力（不仅是程序员），守住自己一亩三分地而沾沾自喜的，那是死人才会有的想法。<br>第二，相信有些人听过 Learning Curve（学习曲线）的概念，学习曲线一般都基于两种模式。<br><strong>其一是对数曲线，在初期学习速度与收益飞快，并逐渐进入平台期</strong>，多见于入门简单技能的学习。其二是指数曲线，初期无论是学习速度还是收益都很差，但<strong>复利</strong>效应强大，后期会获得爆发性的突破。多见于各种产生<strong>睡后收入</strong>的场景，如写文章、教程、创作文艺作品等。<br>而对于为了解决重复而进行脚本编程，常用的语言绝大多数都属于学习曲线是对数的情况（编程语言有个规则即诞生的越晚，一般就更易学更人性化。如 Python（1991）、Lua（1993）、C#（2000）相对 C++（1983）来说分别对应了第一种和第二种学习曲线）。<br><strong>对数形态的学习曲线导致它们的学习体验在初期会让人很快的感受到收益与反馈，所以可以用很短时间就接触到不少其它领域。</strong>而这部分技能往往已经足够你应对一些常见的工作。毕竟如果目标是成为一个 C++ 算法工程师，指数形的学习曲线会让初学者望而却步，但很明显这不是大多数人需要的方向。</p><h3 id="5-1-Python"><a href="#5-1-Python" class="headerlink" title="5.1. Python"></a>5.1. Python</h3><p>Python 对技术音频的工作而言，可以拿来写本文上面提到的诸多脚本，以及能够开发 GUI 工具。无需多说，属于必备且必学的语言之一。<br>但就像上面提到的，入门容易精通难。学习 Python 不能被友好的语法和高容错率蒙蔽了双眼，对数据结构、算法乃至设计模式等 CS 基础知识也要补上。</p><h3 id="5-2-C-与-C"><a href="#5-2-C-与-C" class="headerlink" title="5.2. C# 与 C++"></a>5.2. C# 与 C++</h3><p>C# 与 C++ 除了分别对应 Unity 和 Unreal Engine 的御用语言之外，C# 在 WPF 开发也有很大用处，C 或 C++ 在实现底层的东西或开发插件时也是必备的。<br>虽然小题目中没有列出 C 语言，但它对学习了解 CS 基础知识非常合适。在初中时期看过的谭浩强的《C 程序设计》令我反胃，但确实在很早的时候就为我对计算机原理的了解打下一些基础，不至于在成年后编码时产生过多陌生感。</p><h3 id="5-4-Lua"><a href="#5-4-Lua" class="headerlink" title="5.4. Lua"></a>5.4. Lua</h3><p>Lua 的主要用途有两个，一是作为热更新框架所采用的语言，二是可用在 ReaScript 脚本及工具开发上。<br>因为 Lua 和 Python 类似也是很好入门的脚本语言，参考 Python 对比学习语法是再好不过的了。</p><h3 id="5-5-JavaScript"><a href="#5-5-JavaScript" class="headerlink" title="5.5. JavaScript"></a>5.5. JavaScript</h3><p>JavaScript 的主要用途在本文中也有体现，比如作为 FMOD 的脚本调用语言，或者作为 Electron 框架的开发语言来开发跨平台桌面程序。</p><h3 id="5-4-了解-SDK"><a href="#5-4-了解-SDK" class="headerlink" title="5.4. 了解 SDK"></a>5.4. 了解 SDK</h3><p>了解 SDK 这个说法比较宽泛。就我个人的观点，这代表了技术音频设计师至少要了解这些有 SDK 字样的文档的阅读和使用方法：比如游戏引擎中音频 SDK、中间件的底层 SDK 使用以及在集成包上如何实现的、引用命名空间时清楚不同模块的用途等。<br>费力完成这些最终的目的倒不是为了全部徒手用 SDK 撸完集成，而是有更完善的工作原理理解和 Debug 能力。</p><h2 id="其它基础技能"><a href="#其它基础技能" class="headerlink" title="其它基础技能"></a>其它基础技能</h2><h3 id="6-1-音乐基础、音乐制作、录音混音及声音设计"><a href="#6-1-音乐基础、音乐制作、录音混音及声音设计" class="headerlink" title="6.1. 音乐基础、音乐制作、录音混音及声音设计"></a>6.1. 音乐基础、音乐制作、录音混音及声音设计</h3><p>这部分不值得单独开章节，故扔在这里。有音乐基础，掌握常见的音乐制作及后期处理流程，以及有声音设计能力无疑是技术音频设计师的基础。<br><strong>这些基础知识一方面决定为什么技术音频设计师属于音频设计师而不是纯程序员，也决定了技术音频设计师在交叉技能的掌握和体现了审美能力。</strong></p><h3 id="6-2-DSP"><a href="#6-2-DSP" class="headerlink" title="6.2. DSP"></a>6.2. DSP</h3><p>对数字信号处理（DSP, Digital Signal Processing）有一定认识的话，至少能够遇到相关知识不打怵。作为音频从业人士，连奈奎斯特定理、傅里叶变换等基础知识都不知道，着实有些说不过去。<br>而如果具有一定的技术基础，能够用编程语言复现一些信号处理算法（FFT、DWT），或者根据 DAFX 这类书籍用实现出效果器（如 JUCE 框架），在信号处理领域的理解会更加深刻。</p><h3 id="6-3-英文"><a href="#6-3-英文" class="headerlink" title="6.3. 英文"></a>6.3. 英文</h3><p>英文能力的重要性体现在诸多方面，这里先不讨论是否要对国外接外包或去国外工作，单单日常的工作和学习来说，英文就已是离不开的能力。<br>太多的教程和书籍都是英文原版的，第一手新闻和行业资料（没事可多翻翻 Twitter）也全是英文，中间件，程序代码更是如此。<br>在这个问题上，我跟声音设计师要不要学写代码的地方持一样的看法。与其等待本地化，不如主动出击学好英文。</p><h3 id="6-4-信息检索与解决问题"><a href="#6-4-信息检索与解决问题" class="headerlink" title="6.4. 信息检索与解决问题"></a>6.4. 信息检索与解决问题</h3><p><strong>信息检索和解决问题的能力应该是现代人立足职场之本。</strong><br>我几乎所有的研究与写作都是靠自己完成的，致谢中虽然提到了一些同行老师的名字，但我所获取的更多只是一些“<strong>关键词</strong>”。<br><strong>举个例子，在去年了解有技术音频这个职业名称后，不仅顺藤摸瓜找到了诸如 Guy Somberg、Damian Kastbauer 等老师的书及演讲视频等资料，更是靠自己检索出了整套《游戏音频与声音设计相关书籍推荐》书单（除少数几本是朋友推荐）。</strong><br>而对于解决问题的能力，除了要有极强的文档（RTFM）和 Google 检索能力外，更应该学会如何正确的提问（可参考 <em>How To Ask Questions The Smart Way</em>）。在掌握了解决问题的诸多技巧后，我所遇到的提问题的场景变得越来越少。<strong>相反，在自我提问并自我解答的这个过程中，反而收获了越发广阔的视野。</strong><br>我想这也是元认知、复利、独立思考等思维技巧带来的综合结果，<strong>它们使人愈思考愈智慧，而不是成为一个简单的伸手党。</strong></p><h2 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h2><p>创办亥姆霍兹实验室这个公众号的动机非常简单，就是为了分享自己的一些研究和思考。<strong>不敢自吹自擂说能推动行业进步，但至少挂了之后能给世界留下一点点有用的文字。</strong><br>我的短期计划（两三年内）有一部分，就是<strong>希望把本文中提到但目前没有特别好的文章去讲解的部分技能写成文章与大家分享。</strong>与此同时，随着我对技术音频设计师理解的更加深刻，这份清单的技能树也还会继续完善。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>在这篇文章中包含了直接或间接从同行老师的言谈、文章、朋友圈等地方学到的知识，在这里列出诸位的名字，感谢他们的鼓励与分享！<br>以下排名不分先后（以拼音顺序）：<br><strong>侯晨钟，胡磊（Moy），李AA，沈希辰，岳豪，杨磊，zpan</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 音频编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WAAPI is for Everyone | Part 2 wwise.core</title>
      <link href="/2020/11/28/WAAPI%20is%20for%20Everyone%20P2/"/>
      <url>/2020/11/28/WAAPI%20is%20for%20Everyone%20P2/</url>
      
        <content type="html"><![CDATA[<p>Hello. I’m Thomas Wang (also known as Xi Ye).<br>In Part 1, I used mind maps to summarize WAAPI essentials. With the development environment configured, I wrote several short scripts with Python. And we had a first taste of the power of WAAPI.<br>Starting from Part 2, we will go through all the branches of WAAPI. To make this easier to read, I will do my best to describe them as simply as possible and demonstrate real API use cases.<br>I also created a repository on GitHub for easy access. You will find all the code referred to in this blog series.<br><a href="https://github.com/zcyh147/Everyone-can-use-WAAPI" target="_blank" rel="noopener">https://github.com/zcyh147/Everyone-can-use-WAAPI</a></p><blockquote><p>Before we proceed, there a few things things that I want to clarify:</p><ul><li><strong>The main purpose of listing the APIs here is to clarify their usage, and get you up and running quickly</strong>. It’s recommended that you make your own list according to the description in Part 1.</li><li>This blog assumes that you’ve gone through Part 1, knowing how to use those tips and tricks such as formatting the JSON syntax for better readability, looking up the WAAPI arguments and return values, etc. Still, I suggest you check the online documents while reading this blog.</li><li>For the sake of beginners, I tried to add notes to each line to address more details.</li><li>Try to do some investigation before you raise a question. Wwise documents and Google search are more powerful than you can imagine.</li><li>WAAPI features will be updated over time, make sure you install the latest version of Wwise. <strong>When the “The procedure URI is unknown.” error message occurs, it means your APIs are not supported by the current version of WAAPI.</strong></li></ul></blockquote><h2 id="wwise-core-Overview"><a href="#wwise-core-Overview" class="headerlink" title="wwise.core Overview"></a>wwise.core Overview</h2><p><img src="/images/wwisecore.png" alt="wwise.core"><br><strong>As an essential part of WAAPI, the <code>wwise.core</code> APIs are very powerful.</strong> Aside from <code>wwise.core</code> and <code>soundengine</code>, the remaining execution APIs are relatively simple. In this blog, I will focus on <code>wwise.core</code>.<br>From the mind map shown above, we can see that these APIs are primarily for Wwise audio design instead of sound engine configuration. <strong>If you are interested in optimizing Wwise operations, this blog can be very helpful.</strong><br>Note: As shown above, those with a strikethrough have been replaced by new APIs.</p><h2 id="audio-Importing-Audio-Files-and-Creating-Wwise-Objects"><a href="#audio-Importing-Audio-Files-and-Creating-Wwise-Objects" class="headerlink" title="audio (Importing Audio Files and Creating Wwise Objects)"></a>audio (Importing Audio Files and Creating Wwise Objects)</h2><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><p>There are two APIs under the audio branch: <code>import</code> and <code>importTabDelimited</code>. As their names suggest, they are used to import audio assets. <strong>The former simply imports audio files and creates Wwise objects. The latter allows you to import audio files based on the rules specified in a tab-delimited file, and execute certain operations.</strong><br>importTabDelimited imports the predefined information from a tab-delimited text file. This information includes the local directories of audio files, different Wwise hierarchies under which the objects are located (containers, Events, Output Busses), and how to make a reference to the property values or use Switches to assign child elements etc.<br>The text file can be generated by Microsoft Excel or other spreadsheet applications. Its first row defines the properties specified by each column heading. Each column determines what will be created in the Wwise project.</p><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>Obviously, <code>audio</code> is the most important branch in terms of asset importing. These APIs eliminate the need for repetitive operations when you manually import a large number of files. With proper information specified, they can automatically set up the hierarchies, properties, streams etc.<br>Using <code>import</code> to import audio files, you need to specify the directories and properties in their filenames. To this end, you must create a dictionary to map the designation indicated by these filenames, reducing the possibility of reporting errors due to long filenames.<br>Operation systems have a certain limit on the filename and path. Technically, the filename in Wwise must be no longer than 256 characters. Otherwise, the importing operation could fail. Taking the system path into account, users usually don’t have many characters to use.<br>In this case, we can use <code>importTabDelimited</code> to import audio files from a tab-delimited text file in which certain rules are specified. In fact, this process can be further optimized. For example, sound designers can build a simple app with VBA to quickly generate tab-delimited files through Excel, or build a more complex GUI app with Python to create these files directly.</p><h2 id="audioSourcePeaks-Getting-Peak-Values"><a href="#audioSourcePeaks-Getting-Peak-Values" class="headerlink" title="audioSourcePeaks (Getting Peak Values)"></a>audioSourcePeaks (Getting Peak Values)</h2><h3 id="Features-1"><a href="#Features-1" class="headerlink" title="Features"></a>Features</h3><p>There are two APIs under this branch: <code>getMinMaxPeaksInRegion</code> and <code>getMinMaxPeaksInTrimmedRegion</code>. They are used to get the peak values and return certain information. The former gets the peak values in the given region of an audio source. The latter gets the peak values in the entire trimmed region of an audio source. <strong>Note that we are not talking about just the Max Peak, but a Min/Max Peak pair specified by the numPeaks argument.</strong><br><code>getMinMaxPeaksInRegion</code> has two arguments: <code>timeFrom</code> and <code>timeTo</code>. They determine the start and end time of the section of the audio source for which peaks are required. For <code>getMinMaxPeaksInTrimmedRegion</code>, you don’t have to specify the start and end time, it just evaluates the values after the SFX object is trimmed.<br>Both of these APIs return base-64 encoded, 16-bit signed integer arrays. They need to be decoded, parsed in a given format (fmt), then converted into dB values.</p><h3 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a>Usage</h3><p>I’m new to Wwise plug-in development. As far as I know, you don’t have to take so many Min/Max Peak values from a single audio source. However, if you do, you can use these two APIs to calculate the peaks globally across channels. They can provide you with up to 14294967295 such values.</p><h2 id="Object-Object-Operations"><a href="#Object-Object-Operations" class="headerlink" title="Object (Object Operations)"></a>Object (Object Operations)</h2><h3 id="Features-2"><a href="#Features-2" class="headerlink" title="Features"></a>Features</h3><h4 id="create-copy-delete-move-Basic-Object-Operations"><a href="#create-copy-delete-move-Basic-Object-Operations" class="headerlink" title="create, copy, delete, move (Basic Object Operations)"></a>create, copy, delete, move (Basic Object Operations)</h4><p>These four APIs are used to execute the most basic object operations. They have arguments to define the object name, type, source path, target path etc.<br><strong><code>create</code> allows you to create massive objects that are listed in the Wwise Objects Reference document. <code>import</code> and <code>importTabDelimited</code>, by contrast, can only create audio-related objects (containers, Events etc.).</strong><br>With <code>create</code>, you can create Sound SFX objects, Work Units, containers, even effects and source plug-ins.</p><h4 id="setReference-setRandomizer-setAttenuationCurve-setName-setNotes-setProperty-Setting-Object-Properties"><a href="#setReference-setRandomizer-setAttenuationCurve-setName-setNotes-setProperty-Setting-Object-Properties" class="headerlink" title="setReference, setRandomizer, setAttenuationCurve, setName, setNotes, setProperty (Setting Object Properties)"></a>setReference, setRandomizer, setAttenuationCurve, setName, setNotes, setProperty (Setting Object Properties)</h4><p><code>create</code> can only set a few object properties (such as notes). To set more object properties, you have to use the APIs listed above.<br><code>setReference</code> sets an object’s reference value. For instance, you may set a reference to an Output Bus for a Sound SFX object.<br>As for <code>setRandomizer</code>, <code>setAttenuationCurve</code>, <code>setName</code> and <code>setNotes</code>, they just do what their names suggest.<br><code>setProperty</code> sets a property value of an object for a specific platform. To learn more about the properties available on each object type, refer to the Wwise Objects Reference doc.<br>For example, if you want to set a property within the Mastering Suite, all you need is provide its location information such as GUID or path, then change the “property” key value to the name of the property that you’d like to modify, and finally specify an appropriate value to replace with.</p><h4 id="get-getTypes-getPropertyInfo-getAttenuationCurve-getPropertyAndReferenceNames-Getting-Object-Properties"><a href="#get-getTypes-getPropertyInfo-getAttenuationCurve-getPropertyAndReferenceNames-Getting-Object-Properties" class="headerlink" title="get, getTypes, getPropertyInfo, getAttenuationCurve, getPropertyAndReferenceNames (Getting Object Properties)"></a>get, getTypes, getPropertyInfo, getAttenuationCurve, getPropertyAndReferenceNames (Getting Object Properties)</h4><p>If you want to get information on the current project, the APIs above will be your solution.<br><code>get</code> is a query-based API. It returns different types of information such as ID, name, size, path, duration etc. You can get what you want by simply setting an appropriate query parameter. As mentioned in Part 1, it can pass in arguments from both tables (Arguments and Options), and get the return result based on what you choose from the Options table.<br><strong>So, what’s the difference between them?</strong><br>In the Arguments table, there are two arguments: <code>from</code> and <code>transform</code>. </p><ol><li><code>from</code> indicates the data source of your query. You can search an object by its name, GUID, path, type etc. Also, you can filter a range of objects by specifying a sub-argument such as <code>ofType</code> or <code>search</code>.</li><li><code>transform</code> is used to transform a selected object. Let’s say we set a Random Container with from, then added select parent in <code>transform</code>. In result, its parent object will be selected instead. So, <code>transform</code> is an important complement to <code>from</code>. It allows you to search the parent, children or reference based on what you set in <code>from</code>.</li></ol><p>In the Options table, there are also two arguments: <code>return</code> and <code>platform</code>. (Note: these arguments can be left empty.)</p><ol><li><code>return</code> specifies what return result you will get after the query process. The GUID and name of the object will be returned if left empty.</li><li><code>platform</code> specifies which platform will be queried. The default platform will be queried if left empty.</li></ol><p><strong>Now, why do we need <code>getTypes</code>, <code>getPropertyInfo</code>, <code>getAttenuationCurve</code>, <code>getPropertyAndReferenceNames</code>?</strong><br>Actually, those APIs are designed differently for various purposes. <code>get</code> queries an object to get its general properties. The other four get the meta properties: <code>getTypes</code> returns the types of all currently registered objects; <code>getPropertyInfo</code> returns specific info about the object properties (such as value range); <code>getAttenuationCurve</code> returns the Attenuation Curve settings of a specific object; <code>getPropertyAndReferenceNames</code> returns the object properties and current reference names.</p><h3 id="Usage-2"><a href="#Usage-2" class="headerlink" title="Usage"></a>Usage</h3><p>There are a variety of situations in which you can use these APIs. Some examples are getting the converted size of an audio file, getting the properties and reference names of an object, querying all the platforms in your project or all the Output Busses in use, etc.<br>It should be easier if you are familiar with the Queries tab in Wwise.</p><h2 id="getInfo-and-log-get-Getting-Project-Info-and-Logs"><a href="#getInfo-and-log-get-Getting-Project-Info-and-Logs" class="headerlink" title="getInfo and log.get (Getting Project Info and Logs)"></a>getInfo and log.get (Getting Project Info and Logs)</h2><h3 id="Features-3"><a href="#Features-3" class="headerlink" title="Features"></a>Features</h3><p>These two APIs are used to simply get certain information. <code>getInfo</code> returns global info of the current project, such as Wwise version, platform info, WAAPI version etc. <code>log.get</code> returns the latest log. In fact, the tabs in the Logs window are linked to the <code>channel</code> argument here.<br>If you want to update the log dynamically within your own app, certain subscription APIs can be helpful. (We will talk about this later.) Take <code>ak.wwise.core.log.itemAdded</code>for example. This API returns info when an object is added.</p><h3 id="Usage-3"><a href="#Usage-3" class="headerlink" title="Usage"></a>Usage</h3><p>You can use these two APIs as needed. For example, using <code>log.get</code> to save each log to the database after you execute certain operations, or carry out further analysis so that you can get more customized feedback reports.</p><h2 id="profiler-Profiler-Operations"><a href="#profiler-Profiler-Operations" class="headerlink" title="profiler (Profiler Operations)"></a>profiler (Profiler Operations)</h2><h3 id="Features-4"><a href="#Features-4" class="headerlink" title="Features"></a>Features</h3><h4 id="startCapture-stopCapture-Switching-On-Off-Capture"><a href="#startCapture-stopCapture-Switching-On-Off-Capture" class="headerlink" title="startCapture, stopCapture (Switching On/Off Capture)"></a>startCapture, stopCapture (Switching On/Off Capture)</h4><p>These two APIs are used to simply start and stop the Profiler Capture process, without having to set any arguments.</p><h4 id="getBusses-getCursorTime-getRTPCs-getVoiceContributions-getVoices-Getting-Info-at-A-Specific-Profiler-Capture-Time"><a href="#getBusses-getCursorTime-getRTPCs-getVoiceContributions-getVoices-Getting-Info-at-A-Specific-Profiler-Capture-Time" class="headerlink" title="getBusses, getCursorTime, getRTPCs, getVoiceContributions, getVoices (Getting Info at A Specific Profiler Capture Time)"></a>getBusses, getCursorTime, getRTPCs, getVoiceContributions, getVoices (Getting Info at A Specific Profiler Capture Time)</h4><p><code>getBusses</code>, <code>getRTPCs</code> and <code>getVoices</code> are similar. They just pass in a time value and get certain information such as bus gain, RTPC ID, RTPC value, voices etc.<br><code>getCursorTime</code> returns the current time of the specified profiler cursor, in milliseconds.<br><code>getVoiceContributions</code> returns all parameters affecting the dry path, such as voice volume, high-pass, low-pass etc.<br>Note that, for <code>getBusses</code> and <code>getVoices</code>, it’s possible to pass in two arguments, with the second defining the query range.</p><h3 id="Usage-4"><a href="#Usage-4" class="headerlink" title="Usage"></a>Usage</h3><p>You can integrate the <code>startCapture</code> and <code>stopCapture</code> features into certain tools for manual or auto control, facilitating more complex capture process. For example, using the Unity WAAPI client to add some profiling capabilities and control the start and stop of capture, then you will get the profiling data for further analysis as needed.</p><h2 id="project-save-Saving-Projects"><a href="#project-save-Saving-Projects" class="headerlink" title="project.save (Saving Projects)"></a>project.save (Saving Projects)</h2><h3 id="Features-5"><a href="#Features-5" class="headerlink" title="Features"></a>Features</h3><p>This API is used to save the current project.</p><h3 id="Usage-5"><a href="#Usage-5" class="headerlink" title="Usage"></a>Usage</h3><p>Instead of simply replacing the Ctrl + S operation, this API automatically saves the project based on certain trigger conditions, without sacrificing the performance.<br>For example, when importing tens of thousands of files at one time or performing other batch processes, you could make a call to this API for every 100 or even 10 files, avoiding potential risks.</p><h2 id="remote-Remote-Connecting-to-Game"><a href="#remote-Remote-Connecting-to-Game" class="headerlink" title="remote (Remote Connecting to Game)"></a>remote (Remote Connecting to Game)</h2><h3 id="Features-6"><a href="#Features-6" class="headerlink" title="Features"></a>Features</h3><h4 id="connect-disconnect-Switch-On-Off-Connection"><a href="#connect-disconnect-Switch-On-Off-Connection" class="headerlink" title="connect, disconnect (Switch On/Off Connection)"></a>connect, disconnect (Switch On/Off Connection)</h4><p>These two APIs are used to remotely connect to and disconnect from a game. By doing this, you have to provide the host IP and optional ports. And that’s why we need <code>getAvailableConsoles</code> listed below. If you want to connect to different game engines, you can use it to get the available clients first.</p><h4 id="getAvailableConsoles-getConnectionStatus-Getting-Available-Consoles-and-Checking-Connection-Status"><a href="#getAvailableConsoles-getConnectionStatus-Getting-Available-Consoles-and-Checking-Connection-Status" class="headerlink" title="getAvailableConsoles, getConnectionStatus (Getting Available Consoles and Checking Connection Status)"></a>getAvailableConsoles, getConnectionStatus (Getting Available Consoles and Checking Connection Status)</h4><p><code>getAvailableConsoles</code> retrieves all consoles available for connecting Wwise Authoring to a Sound Engine instance, then returns the editor name, IP, port, platform etc.<br><code>getConnectionStatus</code> checks the current connection status. Only connected game engines will return their console info and connection status.</p><h3 id="Usage-6"><a href="#Usage-6" class="headerlink" title="Usage"></a>Usage</h3><p>The connection and disconnection features can be integrated into your game menus as described in One Minute Wwise so that you can click and connect to or disconnect from a game quickly. Also, you can use tools like StreamDeck or Metagrid to automatically trigger Python scripts to activate the remote connection, reducing the time wasted on manual operations.<br>You can combine<code>getAvailableConsoles</code> and <code>getConnectionStatus</code> to integrate the Wwise Profiler data into your own app (refer to the “profiler” section). For example, automatically retrieving desired info, or just informing user of the current connection status in your own app, allowing for a better workflow outside of Wwise.</p><h2 id="soundbank-SoundBank-Generation-and-Settings"><a href="#soundbank-SoundBank-Generation-and-Settings" class="headerlink" title="soundbank (SoundBank Generation and Settings)"></a>soundbank (SoundBank Generation and Settings)</h2><h3 id="Features-7"><a href="#Features-7" class="headerlink" title="Features"></a>Features</h3><p><code>generate</code>, as its name suggests, generates a list of SoundBank. In addition to simply generating all SoundBanks, you may check specific SoundBanks, Platforms or Languages and click Generate Selected. Instead of doing this manually, you can let <code>generate</code> do it for you.<br><code>getInclusions</code> retrieves a SoundBank’s inclusion list, including the GUID, name, or path of the SoundBank to add an inclusion to.<br><code>setInclusions</code> modifies a SoundBank’s inclusion list. You may add, remove and replace the SoundBank’s inclusion list.</p><h3 id="Usage-7"><a href="#Usage-7" class="headerlink" title="Usage"></a>Usage</h3><p><code>soundbank</code> 类中如果想对不存在的 SoundBank 进行内容设置，需先通过 <code>create</code> 进行创建 SoundBank 对象和层级，之后才能继续设置包内内容。<br><strong>至此，一套完整的创建工作流就产生了，<code>audio</code> 类负责导入音频并创建音频层级结构，<code>create</code> 类可以创建并构建各种其他层级和 Event 等，最后由 <code>soundbank</code> 类负责收尾创建 SoundBank。</strong>这套工作流可用于根据外部设定的结构文件自动化创建，或在 Wwise 外的控制程序上通过 <code>soundbank</code> 检视工程内部结构。<br>A SoundBank has to be created before you set its inclusion list. And you can use <code>create</code> to create a SoundBank’s objects and hierarchies.</p><p>So to conclude, the <code>audio</code> branch APIs import audio files and create objects; the <code>create</code> branch APIs create and build hierarchies, Events etc.; the <code>soundbank</code> branch APIs create SoundBanks. This workflow can be used to automate the asset creation through externally defined structural files, or inspect the internal structure of a project via <code>soundbank</code> in an app outside of Wwise.</p><h2 id="switchContainer-Switch-Container-Operations"><a href="#switchContainer-Switch-Container-Operations" class="headerlink" title="switchContainer (Switch Container Operations)"></a>switchContainer (Switch Container Operations)</h2><h3 id="Features-8"><a href="#Features-8" class="headerlink" title="Features"></a>Features</h3><p>As mentioned previously, you can use the create branch APIs to create containers, including Switch Containers. <strong>Now why do we need <code>switchContainer</code>?</strong><br>Switch Containers won’t work unless they are assigned to Switch/State Groups, and each Switch/State has objects assigned.<br>You can use the <code>switchContainer</code> branch APIs to make these assignments.<br><code>addAssignment</code> assigns a Switch Container’s child to a Switch. <code>removeAssignment</code> removes an assignment between a Switch Container’s child and a State. All you have to do is provide the GUIDs of objects within a Switch Container and the GUIDs of Switch/States within a Switch/State Group.<br><code>getAssignments</code> returns the list of assignments between a Switch Container’s children and states.</p><h3 id="Usage-8"><a href="#Usage-8" class="headerlink" title="Usage"></a>Usage</h3><p>The <code>switchContainer</code> branch APIs can be used as a complement to the automated import workflow by assigning Switch elements to the containers that you created.</p><h2 id="transport-Transport-Control"><a href="#transport-Transport-Control" class="headerlink" title="transport (Transport Control)"></a>transport (Transport Control)</h2><h3 id="Features-9"><a href="#Features-9" class="headerlink" title="Features"></a>Features</h3><h4 id="create-destroy-executeAction"><a href="#create-destroy-executeAction" class="headerlink" title="create, destroy, executeAction"></a>create, destroy, executeAction</h4><p><code>create</code> creates a transport object for the given Wwise object.<br><code>destroy</code> destroys the given transport object. For create, you need to provide the Wwise object’s GUID. For destroy, you need to provide the transport object’s GUID.<br><strong>So, what is a transport object?</strong> In fact, you are always repeating these two actions in your daily work within Wwise.<br>For example, when you select Event A, the Transport Control stays focused on it. In other words, you created an Event A transport object. If you select Event B, then Event A will be destroyed, and an Event B transport object will be created. If you click the Pin icon in the Transport Control view, the current transport object will persist, and no other transport objects will be created.<br>A Soundcaster Session is actually a collection of transport objects.<br><code>executeAction</code> executes an action on the given transport object. There are five possible action values: play, stop, pause, playStop and playDirectly.</p><h4 id="getList-getState"><a href="#getList-getState" class="headerlink" title="getList, getState"></a>getList, getState</h4><p><code>getList</code> returns the list of transport objects. You can view all of the transport objects unless they are destroyed with destroy.<br><code>getState</code> gets the state of the given transport object. You can query the state with this API after executing an action with executeAction.</p><h3 id="Usage-9"><a href="#Usage-9" class="headerlink" title="Usage"></a>Usage</h3><p>The <code>transport</code> branch APIs can be used to define the playback behavior in an app outside of Wwise. This external app can be your own integration tool. You may use it to preview the sounds in your Wwise project or even replicate a Soundcaster Session outside of Wwise.</p><h2 id="undo-Undo"><a href="#undo-Undo" class="headerlink" title="undo (Undo)"></a>undo (Undo)</h2><h3 id="Features-10"><a href="#Features-10" class="headerlink" title="Features"></a>Features</h3><p>People who are familiar with ReaScript can think of <code>beginGroup</code> and <code>endGroup</code> as <code>Undo_BeginBlock()</code> and <code>Undo_EndBlock()</code> in Reaper. <code>beginGroup</code> begins an undo group. <code>endGroup</code> ends the last undo group. <code>beginGroup</code> can be used repeatedly.<br><code>cancelGroup</code> cancels the last undo group.</p><h3 id="Usage-10"><a href="#Usage-10" class="headerlink" title="Usage"></a>Usage</h3><p>An undo group is used to cancel a sequence of actions at once. Technically, it can also be used to redo these actions. However, WAAPI only supports undo for now. So, we will have to have to wait for future Wwise API updates. The <code>undo</code> branch APIs added the possibility to cancel actions outside of Wwise.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p><strong>You may forget what you’ve learned if you don’t practice</strong>. And this is why I suggest you make your own list according to the description in Part 1.<br>To utilize WAAPI, you should:</p><ol><li>Summarize WAAPI essentials by yourself, with or without mind maps.</li><li>Open your mind and identify the pain-points in your audio design and integration workflow.</li><li>Figure out the basic logics, and determine which APIs to use.</li><li>Write the code to actually implement your ideas.</li></ol><h2 id="Use-Cases"><a href="#Use-Cases" class="headerlink" title="Use Cases"></a>Use Cases</h2><p>Let’s have a look at some real WAAPI use cases.<br><strong>These use cases focus on implementing essential features. Interactive design and GUI are not our main concerns here</strong>. You can refer to these code lines and write your own code as needed.<br>I tried to cover as many <strong>wwise.core</strong> APIs as I could. I encourage you to keep researching those which I haven’t covered.</p><blockquote><p>If you have bugs reported, double check your code, you should be able to pinpoint what the problem is.<br>For simplicity, I encapsulated each API into a function. You may modify the sample code described in the “Execution APIs” section (Part 1) as needed.<br>The directory structure of Wwise on macOS differs from that of Windows. MacOS users should pay attention to the file path. (In the Wwise Launcher, go to PROJECTS &gt; RECENT PROJECTS &gt; show more &gt;&gt;.)</p></blockquote><h3 id="1-You-import-a-Sound-SFX-object-build-the-hierarchies-set-the-properties-create-an-Event-and-set-the-action-type-Then-you-create-a-SoundBank-add-the-newly-created-Event-and-generate-that-SoundBank"><a href="#1-You-import-a-Sound-SFX-object-build-the-hierarchies-set-the-properties-create-an-Event-and-set-the-action-type-Then-you-create-a-SoundBank-add-the-newly-created-Event-and-generate-that-SoundBank" class="headerlink" title="1. You import a Sound SFX object, build the hierarchies, set the properties, create an Event, and set the action type. Then you create a SoundBank, add the newly created Event, and generate that SoundBank."></a>1. You import a Sound SFX object, build the hierarchies, set the properties, create an Event, and set the action type. Then you create a SoundBank, add the newly created Event, and generate that SoundBank.</h3><p><strong>By quickly importing audio files into Wwise and creating proper hierarchies or even Events, you can greatly increase the efficiency of your audio integration</strong>. In the following example, usually we need to populate the arguments with file path, properties and hierarchies by hand. Or, we can just execute these repetitive tasks with WAAPI.<br>In order to quickly import audio assets into the Wwise project, you can utilize certain naming convention, database interaction and/or regular expressions to prepare the meta data first, then use the programming language of your choice to convert the formatted files into JSON arguments required for WAAPI importing.</p><h4 id="Choosing-APIs"><a href="#Choosing-APIs" class="headerlink" title="Choosing APIs"></a>Choosing APIs</h4><ul><li>Importing files: <code>import</code></li><li>Setting properties: <code>setProperty</code></li><li>Creating Events, adding sounds, creating SoundBanks: <code>create</code></li><li>Setting inclusions and generating SoundBanks: <code>setInclusions</code>, <code>generate</code></li></ul><h4 id="Writing-Code"><a href="#Writing-Code" class="headerlink" title="Writing Code"></a>Writing Code</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Import audio files and create hierarchy</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_import</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="comment"># Define file import parameters, which include the file path and target path in the hard disk, and the target path includes the type definition of the created object</span></span><br><span class="line">    <span class="comment"># For non-voice Sound SFX object, importLanguage is set to SFX. importOperation is set to useExisting, which means that if the required container already exists, it will be replaced directly, if not, it will be created</span></span><br><span class="line">    args_import = &#123;</span><br><span class="line">        <span class="string">"importOperation"</span>: <span class="string">"useExisting"</span>, </span><br><span class="line">        <span class="string">"default"</span>: &#123;</span><br><span class="line">            <span class="string">"importLanguage"</span>: <span class="string">"SFX"</span></span><br><span class="line">        &#125;, </span><br><span class="line">        <span class="string">"imports"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"audioFile"</span>: file_path, </span><br><span class="line">                <span class="string">"objectPath"</span>: <span class="string">"\\Actor-Mixer Hierarchy\\Default Work Unit\\&lt;Sequence Container&gt;Test 0\\&lt;Sound SFX&gt;My SFX 0"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># Define the result parameters to only return the information under the Windows, the information includes the GUID and the name of the created object</span></span><br><span class="line">    opts = &#123;</span><br><span class="line">        <span class="string">"platform"</span>: <span class="string">"Windows"</span>,</span><br><span class="line">        <span class="string">"return"</span>: [</span><br><span class="line">            <span class="string">"id"</span>, <span class="string">"name"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> client.call(<span class="string">"ak.wwise.core.audio.import"</span>, args_import, options=opts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Set audio properties</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_property</span><span class="params">(object_guid)</span>:</span></span><br><span class="line">    <span class="comment"># Set the target object in the parameter to the GUID of the object to be modified, the modified attribute is Volume, the platform of the object is Mac, and the value is modified to 10</span></span><br><span class="line">    args_property = &#123;</span><br><span class="line">        <span class="string">"object"</span>: object_guid, </span><br><span class="line">        <span class="string">"property"</span>: <span class="string">"Volume"</span>, </span><br><span class="line">        <span class="string">"platform"</span>: <span class="string">"Windows"</span>, </span><br><span class="line">        <span class="string">"value"</span>: <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client.call(<span class="string">"ak.wwise.core.object.setProperty"</span>, args_property)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Create Event for Sound SFX and set playback rules</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_event</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Create Event for a Sound SFX object and define its play behavior as play</span></span><br><span class="line">    args_new_event = &#123;</span><br><span class="line">        <span class="comment"># The upper half of the attributes are the path, type, name, and processing method when the name conflict is encountered after the event is created</span></span><br><span class="line">        <span class="string">"parent"</span>: <span class="string">"\\Events\\Default Work Unit"</span>, </span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"Event"</span>, </span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"Play_SFX"</span>, </span><br><span class="line">        <span class="string">"onNameConflict"</span>: <span class="string">"merge"</span>, </span><br><span class="line">        <span class="string">"children"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment"># Create a play behavior for it, leave the name blank, use ’@ActionType’ to define its play behavior as Play, '@Target' is the sound object being played</span></span><br><span class="line">                <span class="string">"name"</span>: <span class="string">""</span>, </span><br><span class="line">                <span class="string">"type"</span>: <span class="string">"Action"</span>, </span><br><span class="line">                <span class="string">"@ActionType"</span>: <span class="number">1</span>, </span><br><span class="line">                <span class="string">"@Target"</span>: <span class="string">"\\Actor-Mixer Hierarchy\\Default Work Unit\\Test 0\\My SFX 0"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> client.call(<span class="string">"ak.wwise.core.object.create"</span>, args_new_event&#123;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Create a SoundBank and add Event to it</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_soundbank</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Create a Soundbank in the Default Work Unit in the SoundBanks folder</span></span><br><span class="line">    args_new_event = &#123;</span><br><span class="line">        <span class="string">"parent"</span>: <span class="string">"\\SoundBanks\\Default Work Unit"</span>, </span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"SoundBank"</span>, </span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"Just_a_Bank"</span>, </span><br><span class="line">        <span class="string">"onNameConflict"</span>: <span class="string">"replace"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># Receive return value</span></span><br><span class="line">    soundbank_info = client.call(<span class="string">"ak.wwise.core.object.create"</span>, args_create_soundbank)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add content to the newly created SoundBank, and put the Event created above into it</span></span><br><span class="line">    args_set_inclusion = &#123;</span><br><span class="line">        <span class="string">"soundbank"</span>: <span class="string">"\\SoundBanks\\Default Work Unit\\Just_a_Bank"</span>, </span><br><span class="line">        <span class="string">"operation"</span>: <span class="string">"add"</span>, </span><br><span class="line">        <span class="string">"inclusions"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment"># Here is the content to be put in Just_a_Bank, filter is which data to put into the SoundBank</span></span><br><span class="line">                <span class="string">"object"</span>: <span class="string">"\\Events\\Default Work Unit\\Play_SFX"</span>, </span><br><span class="line">                <span class="string">"filter"</span>: [</span><br><span class="line">                    <span class="string">"events"</span>, </span><br><span class="line">                    <span class="string">"structures"</span>,</span><br><span class="line">                    <span class="string">"media"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> client.call(<span class="string">"ak.wwise.core.soundbank.setInclusions"</span>, args_set_inclusion)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. Generate SoundBank</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_soundbank</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Set the name of the SoundBank to be exported and set it to write to disk</span></span><br><span class="line">    args_generate_soundbank = &#123;</span><br><span class="line">        <span class="string">"soundbanks"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"name"</span>: <span class="string">"Ambient"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"writeToDisk"</span>: <span class="keyword">True</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> client.call(<span class="string">"ak.wwise.core.soundbank.generate"</span>, args_generate_soundbank)</span><br></pre></td></tr></table></figure><h3 id="2-You-get-the-global-info-of-the-current-project-as-well-as-the-Sound-SFX-size-and-SoundBank-path"><a href="#2-You-get-the-global-info-of-the-current-project-as-well-as-the-Sound-SFX-size-and-SoundBank-path" class="headerlink" title="2. You get the global info of the current project as well as the Sound SFX size and SoundBank path."></a>2. You get the global info of the current project as well as the Sound SFX size and SoundBank path.</h3><h4 id="Choosing-APIs-1"><a href="#Choosing-APIs-1" class="headerlink" title="Choosing APIs"></a>Choosing APIs</h4><ul><li>Getting the global info：<code>getInfo</code></li><li>Getting the converted size of the Sound SFX object：<code>get</code></li><li>Getting the SoundBank path：<code>get</code></li></ul><h4 id="Writing-Code-1"><a href="#Writing-Code-1" class="headerlink" title="Writing Code"></a>Writing Code</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Get global information</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_global_info</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Query project information through getInfo</span></span><br><span class="line">    <span class="keyword">return</span> client.call(<span class="string">"ak.wwise.core.getInfo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Get the size of Sound SFX</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sfx_and_event_size</span><span class="params">(sound_sfx_guid)</span>:</span></span><br><span class="line">    <span class="comment"># Set the query parameter to the GUID of the object</span></span><br><span class="line">    args = &#123;</span><br><span class="line">        <span class="string">"from"</span>: &#123;</span><br><span class="line">            <span class="string">"id"</span>: [</span><br><span class="line">                sound_sfx_guid</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set the return value to the object name and transcoded size</span></span><br><span class="line">    opts = &#123;</span><br><span class="line">        <span class="string">"return"</span>: [</span><br><span class="line">            <span class="string">"name"</span>, <span class="string">"totalSize"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> client.call(<span class="string">"ak.wwise.core.object.get"</span>, args, options=opts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Get the size of the generated SoundBank</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_soundbank_size</span><span class="params">(soundbank_guid)</span>:</span></span><br><span class="line">    <span class="comment"># 同上例</span></span><br><span class="line">    args = &#123;</span><br><span class="line">        <span class="string">"from"</span>: &#123;</span><br><span class="line">            <span class="string">"id"</span>: [</span><br><span class="line">                soundbank_guid</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set the return value to the path after the SoundBank is generated under the Windows platform</span></span><br><span class="line">    opts = &#123;</span><br><span class="line">        <span class="string">"platform"</span> : <span class="string">"Windows"</span>,</span><br><span class="line">        <span class="string">"return"</span>: [</span><br><span class="line">            <span class="string">"soundbank:bnkFilePath"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment"># Use os.path.getsize() to get the size of the obtained SoundBank address and convert it to MB</span></span><br><span class="line">    path =  client.call(<span class="string">"ak.wwise.core.object.get"</span>, args, options=opts)[<span class="string">'return'</span>][<span class="number">0</span>]</span><br><span class="line">    size = os.path.getsize(path) / (<span class="number">1024</span> ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> size</span><br></pre></td></tr></table></figure><h3 id="3-You-re-create-a-Soundcaster-Session-and-control-the-playback-behavior"><a href="#3-You-re-create-a-Soundcaster-Session-and-control-the-playback-behavior" class="headerlink" title="3. You re-create a Soundcaster Session and control the playback behavior."></a>3. You re-create a Soundcaster Session and control the playback behavior.</h3><p>Soundcaster has two main purposes: 1. Saving a group of transport objects for reuse (Soundcaster Session); 2. Controlling the Game Syncs, object properties, M/S etc. during playback.<br>Here we look at how to re-create a Soundcaster Session.<br>Note: The transport objects in WAAPI cannot be saved with the Wwise project. To implement the Soundcaster Session features, you need to save the GUID of each session separately for re-creating those transport objects next time.</p><h4 id="Choosing-APIs-2"><a href="#Choosing-APIs-2" class="headerlink" title="Choosing APIs"></a>Choosing APIs</h4><ul><li>Transport control：<code>transport</code></li></ul><h4 id="Writing-Code-2"><a href="#Writing-Code-2" class="headerlink" title="Writing Code"></a>Writing Code</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Create a Transport Object for the object, and the GUID of the transport object will be returned after creation. For management convenience, we put the object name and the GUID of the transport strip object in the same dictionary as the function return value</span></span><br><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transportX</span><span class="params">(object_guid)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> WaapiClient() <span class="keyword">as</span> client:</span><br><span class="line">            <span class="comment"># Set the query parameter to the GUID of the controllable object of the transport</span></span><br><span class="line">            transport_args = &#123;</span><br><span class="line">                <span class="string">"object"</span>: object_guid</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># The return value is the transport object ID in dictionary format, such as &#123;'transport': 12&#125;</span></span><br><span class="line">            result_transport_id = client.call(<span class="string">"ak.wwise.core.transport.create"</span>, transport_args)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Set the conditions through 'object_guid' and get the object name through ʻak.wwise.core.object.get`. Of course, if you directly pass in the object name above to create a transport object, you can also omit this step</span></span><br><span class="line">            args = &#123;</span><br><span class="line">                <span class="string">"from"</span>: &#123;</span><br><span class="line">                    <span class="string">"id"</span>: [</span><br><span class="line">                        object_guid</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            opts = &#123;</span><br><span class="line">                <span class="string">"return"</span>: [</span><br><span class="line">                    <span class="string">"name"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Call 'ak.wwise.core.object.get' to get the object name in dictionary format, such as &#123;'name':'MyObjectName'&#125;</span></span><br><span class="line">            result_dict_name = client.call(<span class="string">"ak.wwise.core.object.get"</span>, args, options=opts)[<span class="string">'return'</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Combine the two dictionaries of object name and transport object ID to obtain a transport strip session with a dictionary structure like &#123;'name':'MyObjectName','transport': 1234&#125;</span></span><br><span class="line">            <span class="keyword">return</span> result_dict_name.update(result_transport_id)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">        print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># After obtaining the data in the 'dictionary + tape ID' format of multiple Transport Objects, you can put them in a list for storage. This structure is already a simple Soundcaster Session, for example:</span></span><br><span class="line"><span class="comment"># env_session = [&#123;'name': 'MyObjectName1', 'transport': 1234&#125;, &#123;'name': 'MyObjectName2', 'transport': 12345&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Obtain the Transport ID dictionary of the transport to be controlled from the Transport Session</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_transport_args</span><span class="params">(env_session, object_name, play_state)</span>:</span></span><br><span class="line">    <span class="comment"># Traverse the list 'env_session' that stores the transport object Session, and get the dictionary 'transport_dict' corresponding to the given object name 'object_name'</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> env_session:</span><br><span class="line">        <span class="keyword">if</span> i[<span class="string">'name'</span>] == object_name:</span><br><span class="line">            transport_dict = i</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Obtain the dictionary corresponding to the ID of the transport object from the transport_dict, merge it with the play behavior dictionary, and prepare to pass it as a parameter</span></span><br><span class="line">    transport_id = &#123;<span class="string">'transport'</span>: transport_dict[transport]&#125;</span><br><span class="line">    args = &#123;<span class="string">"action"</span>: play_state&#125;</span><br><span class="line">    <span class="keyword">return</span> args.update(transport_id)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Take Transport Session, the transport object and playback behavior that need to be played in the Session as function parameters, obtain the parameters through the function in the second step, and remotely call 'executeAction' to control the playback behavior of the transport</span></span><br><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> WaapiClient() <span class="keyword">as</span> client:</span><br><span class="line">        args = get_transport_args(env_session, object_name, play_state)</span><br><span class="line">        client.call(<span class="string">"ak.wwise.core.transport.executeAction"</span>, args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">    print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br></pre></td></tr></table></figure><h3 id="4-You-capture-the-Profiler-data-and-generate-a-report"><a href="#4-You-capture-the-Profiler-data-and-generate-a-report" class="headerlink" title="4. You capture the Profiler data and generate a report."></a>4. You capture the Profiler data and generate a report.</h3><h4 id="Choosing-APIs-3"><a href="#Choosing-APIs-3" class="headerlink" title="Choosing APIs"></a>Choosing APIs</h4><ul><li>Switching on/off the capture: <code>startCapture</code>, <code>stopCapture</code></li><li>Capturing the data: <code>getBusses</code>, <code>getCursorTime</code>, <code>getRTPCs</code>, <code>getVoiceContributions</code>, <code>getVoices</code></li></ul><h4 id="Writing-Code-3"><a href="#Writing-Code-3" class="headerlink" title="Writing Code"></a>Writing Code</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Start profiler data acquisition, and return to the start time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_capture</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> client.call(<span class="string">"ak.wwise.core.profiler.startCapture"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. End Profiler data acquisition and return the time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stop_capture</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> client.call(<span class="string">"ak.wwise.core.profiler.startCapture"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Obtain information from the captured data. Note that the value range of 'cursor_time' needs to be between 'start_capture()' and 'stop_capture()'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">capture_log_query</span><span class="params">(cursor_time)</span>:</span></span><br><span class="line">    <span class="comment"># Set the time point to query</span></span><br><span class="line">    args_times = &#123;</span><br><span class="line">        <span class="string">"time"</span>: cursor_time</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get the name of the voice at the current time point, whether it is a Virtual, and the name and ID of the game object related to it</span></span><br><span class="line">    opts_get_voices = &#123;</span><br><span class="line">        <span class="string">"return"</span>: [</span><br><span class="line">            <span class="string">"objectName"</span>, <span class="string">"isVirtual"</span>, <span class="string">"gameObjectName"</span>, <span class="string">"gameObjectID"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Get the Bus that exists at the current point in time</span></span><br><span class="line">    opts_get_busses = &#123;</span><br><span class="line">        <span class="string">"return"</span>: [</span><br><span class="line">            <span class="string">"objectName"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Returns the currently active RTPC ID and value</span></span><br><span class="line">    log_rtpcs = client.call(<span class="string">"ak.wwise.core.profiler.getRTPCs"</span>, args_times)[<span class="string">"return"</span>]</span><br><span class="line">    log_voices = client.call(<span class="string">"ak.wwise.core.profiler.getVoices"</span>, args_times, options=opts_get_voices)[<span class="string">"return"</span>]</span><br><span class="line">    log_busses = client.call(<span class="string">"ak.wwise.core.profiler.getBusses"</span>, args_times, options=opts_get_busses)[<span class="string">"return"</span>]</span><br></pre></td></tr></table></figure><h2 id="What’s-Next"><a href="#What’s-Next" class="headerlink" title="What’s Next?"></a>What’s Next?</h2><p>In Part 3, we will talk about the remaining execution APIs, including wwise.ui, wwise.waapi, wwise.debug and soundengine.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 音频编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写给声音设计师的极速 GUI 开发大法（二）进阶篇</title>
      <link href="/2020/11/19/PySimpleGUI%20%E7%AC%AC%E4%BA%8C%E7%AF%87/"/>
      <url>/2020/11/19/PySimpleGUI%20%E7%AC%AC%E4%BA%8C%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>在《写给声音设计师的极速 GUI 开发大法（一）》中简单的讨论了 PySimpleGUI 作为一个快速且优雅的 GUI 框架的优点和基础使用方法，并且完成了一个实用的小程序。<br>在进阶篇中会讨论一些深入的内容，选择那些在程序中比较常用的控件元素进行讨论，这样能够方便大家更快的了解这个框架的优秀之处。<br>这系列的文章目的就是让声音设计师和技术音频设计师们能够更快速将自己的工具加上脚本，所以我会规避踩过的坑以分享一套完整的技术使用方案给大家。<br><strong>如同 PySimpleGUI 文档中的逻辑，我们鼓励大家使用现成的设计样例快速完成自己的程序，而不是挣扎于费劲的 GUI 代码设计。</strong><br>在文章的最后，我们通过一个设计样例把这些东西串起来，看一下实际的使用。</p><p><em>本文目录：</em></p><p>[toc]</p><h2 id="PySimpleGUI-原理"><a href="#PySimpleGUI-原理" class="headerlink" title="PySimpleGUI 原理"></a>PySimpleGUI 原理</h2><h3 id="1-1-详解基础工作原理"><a href="#1-1-详解基础工作原理" class="headerlink" title="1.1. 详解基础工作原理"></a>1.1. 详解基础工作原理</h3><p>回到第一篇的示例“小刘鸭之窗”，我为代码加上注释，以此系统解释一下 PySimpleGUI 的工作原理。<br><img src="/images/PySimpleGUI-1.png" alt="PySimpleGUI"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定主题，需以主题名称作为参数</span></span><br><span class="line">sg.theme(<span class="string">'Light Brown 11'</span>)   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建窗体，PySimpleGUI 的窗体是一个二维列表（随复杂程度变化，也可更多维），其中的每个子列表代表布局中的一行元素（即控件），每个元素后的括号内的参数代表该元素的各种属性</span></span><br><span class="line">layout = [  [sg.InputText(size=(<span class="number">30</span>, <span class="keyword">None</span>)), sg.Button(button_text=<span class="string">'Ok'</span>, size=(<span class="number">10</span>, <span class="number">1</span>))]  ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将窗口标题与窗体 layout 作为参数传递给 sg.Window()。此时只创建了 Window 类的一个实例，并没有显示窗口</span></span><br><span class="line">window = sg.Window(<span class="string">'小刘鸭之窗'</span>, layout)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 Event Loop（为了保证窗口事件持续发生，One-Shot 类窗口也可无 Event Loop），在其中对 window 调用 read 方法。此时会显示窗口并读取 window 对象的返回值。因为只有 Button 类元素会触发事件（其他元素在属性中也可设置对点击产生事件响应），所以在本例中只有点击 OK 按钮的时候才会触发窗口的 read 方法</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># read 方法会在此阻塞循环继续运行，以在此等待用户触发事件</span></span><br><span class="line">    event, values = window.read()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当满足 if 循环的条件，如接收到窗口关闭时（event 为 None）会跳出循环</span></span><br><span class="line">    <span class="keyword">if</span> event == sg.WIN_CLOSED:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当 Ok 按钮被按下并触发事件，window.read() 读取的返回值 values 时才会在弹出窗口中显示用户输入值</span></span><br><span class="line">    sg.popup(<span class="string">'Input is '</span> + values[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 跳出 Event Loop 后关闭窗体，close() 方法是窗口能退出的保证，防止程序出错或无法关闭</span></span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure><p>通过这些代码能观察到 PySimpleGUI 的这些特性：</p><ol><li>窗体布局代码和参数指派非常清晰，可读性极好。</li><li>Event Loop 是在程序代码本身内的，用户具有更大的控制权。而 Tkinter 等则是接管了这部分，相对没那么自由。</li><li>通过 <code>print</code> 打印出 <code>window.read()</code> 的返回值，会发现它是一个元组，例如 <code>(&#39;OK&#39;, {0: &#39;User Input&#39;})</code>。<strong>不难看出元组中第一个元素是触发了 <code>window.read()</code> 函数的组件的名称即 Event。第二个元素就是获得的返回值字典，</strong>如果没有在元素属性中指定返回值的索引 <code>key</code>，它会默认从0开始索引，其对应的值也就是我们得到的用户输入值。</li></ol><h3 id="1-2-元素（控件）的常见参数"><a href="#1-2-元素（控件）的常见参数" class="headerlink" title="1.2. 元素（控件）的常见参数"></a>1.2. 元素（控件）的常见参数</h3><p>每个元素的可设定属性需查文档以获得完整的资料，<strong>但常见参数是元素之间通用的，这些也是在设计 UI 时常用到的部分。</strong><br>在这里我把常见属性罗列出来，以方便大家快速检索：</p><ol><li><code>&#39;title&#39;, title=None, text=None</code>：标题或内容</li><li><code>size=(None, None)</code>：尺寸大小</li><li><code>font=None</code>：字体字号</li><li><code>xxx_justification=None</code>：文字或元素的对齐方式</li><li><code>enable_events=Bool</code>：是否触发事件</li><li><code>key=None</code>：自定义触发事件后返回元组中的索引</li><li><code>tooltip=None</code>：鼠标悬停时显示提示</li><li><code>target=None</code>：将值传给指定元素</li></ol><h3 id="1-3-PySimpleGUI-版本区别"><a href="#1-3-PySimpleGUI-版本区别" class="headerlink" title="1.3. PySimpleGUI 版本区别"></a>1.3. PySimpleGUI 版本区别</h3><p>在 import 语句中使用不同的模块名，可以导入不同的 PySimpleGUI 版本。之所以有不同的版本区别，是因为 PySimpleGUI 可以通过代码调用不同的 GUI 库来实现最终的窗口。<br>以下是不同版本之间的区别：</p><ol><li><strong>PySimpleGUI</strong>：最常用的 Python 3 Tkinter 版，是第一个最完整的版本，建议用在 Python 3.7.3及之前最为稳定</li><li><strong>PySimpleGUI27</strong>：已不受支持的 Python 2.7 Tkinter 版</li><li><strong>PySimpleGUIWx</strong>：WxPython 版，GUI 三巨头之二。优点是相对 Qt 版来说，打包 exe 空间占用只有几 MB，且系统托盘功能支持完善。缺点是，并非所有的 Qt 控件都可用</li><li><strong>PySimpleGUIQt</strong>：Qt 版，GUI 三巨头之三。是第二个完整版本，缺点是打包 exe 后空间较大，需要上百 MB。且虽然所有控件都可用，但功能不一定完善</li><li><strong>PySimpleGUIWeb</strong>：Remi 版，即  Web 版。如果想要 PySimpleGUI 创建的程序跑在浏览器中，需要使用这个库。请注意这个模式下支持的元素类型有限，具体需参考（<a href="https://github.com/PySimpleGUI/PySimpleGUI/tree/master/PySimpleGUIWeb#what-works）" target="_blank" rel="noopener">https://github.com/PySimpleGUI/PySimpleGUI/tree/master/PySimpleGUIWeb#what-works）</a></li></ol><h3 id="1-4-简单的-Web-程序"><a href="#1-4-简单的-Web-程序" class="headerlink" title="1.4. 简单的 Web 程序"></a>1.4. 简单的 Web 程序</h3><p>PySimpleGUI 优雅的设计让跨平台变的很友好，而通过上面提到的 Remi 版还可轻易实现 Web 程序。<strong>某些情况下，这对开发轻量的需要运行在手机或平板上的工具而言，无疑是一个很简单的方法。</strong><br>下面我们看实现效果。这里以第一篇文章结尾处的程序 <em>GUI Enemy No. 1</em> 为例，通过修改 <code>import</code> 语句并执行。<strong>为了方便演示，这里只演示布局在浏览器中执行的效果，去掉了多余的功能代码。</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUIWeb <span class="keyword">as</span> sg <span class="comment"># 只修改此处</span></span><br><span class="line"></span><br><span class="line">layout = [  [sg.Text(<span class="string">'Browse Folders'</span>)],</span><br><span class="line">            [sg.Input(), sg.FolderBrowse(<span class="string">'Browse'</span>, key=<span class="string">'folder'</span>)],</span><br><span class="line">            [sg.Output(size=(<span class="number">70</span>, <span class="number">20</span>), font=(<span class="string">"宋体"</span>, <span class="number">10</span>))],</span><br><span class="line">            [sg.Button(<span class="string">'Cock it'</span>), sg.Button(<span class="string">'Cancel'</span>)] ]</span><br><span class="line"></span><br><span class="line">window = sg.Window(<span class="string">'GUI Enemy No. 1'</span>, layout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    event, values = window.read()</span><br><span class="line">    <span class="keyword">if</span> event <span class="keyword">in</span> (<span class="keyword">None</span>, <span class="string">'Cancel'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'Cock it'</span>: </span><br><span class="line">        print(<span class="string">'Work work!'</span>)</span><br><span class="line"></span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure></p><p>执行效果：<br><img src="/images/PySimpleGUI%20Remi.png" alt="PySimpleGUI Remi"></p><p>可以看到，在浏览器中弹出了相同的 GUI 布局，且在点击 Cock it 按钮的时候可正常输出字符串。点击 Cancel 也可关闭程序，再刷新后会发现本机此端口的 Web 程序已被关闭。<br><strong>但因为 Remi 版本 PySimpleGUI 不支持 FolderBrowse 元素，所以点击 Browse 时没有效果。</strong></p><h2 id="一些较为复杂的布局实现"><a href="#一些较为复杂的布局实现" class="headerlink" title="一些较为复杂的布局实现"></a>一些较为复杂的布局实现</h2><p>上篇文章结尾处的小程序虽然略有实用性，<strong>但和日常使用的软件还差了太多</strong>。<br>比如，如何实现菜单？如何让窗口内的布局和数据显示实现变化？如何实现多窗口？甚至实现多线程？？<br>为了解决这些疑惑，本小节要讨论一下如何实现现代软件设计中的必备的那些 UI 元素。<br><strong>既然是设计提高效率的工具，那在满足需求的前提下，交互设计也一定要富有效率的简洁。</strong><br>实际工作中我们把很多分散的功能集成在一起，以避免让用户频繁的在不同程序之间切换，此时如何通过本小节提到的元素进行功能集成就是必须要考虑的问题了。</p><h3 id="2-1-解决单行元素带来的布局限制"><a href="#2-1-解决单行元素带来的布局限制" class="headerlink" title="2.1. 解决单行元素带来的布局限制"></a>2.1. 解决单行元素带来的布局限制</h3><p>PySimpleGUI 的布局定义虽然基于二维列表，<strong>但这不代表程序每行只能有一个元素（控件），这样的话 UI 设计会很死板。</strong>当然，PySimpleGUI 的 GUI 设计哲学就是以行为单位设计元素，<strong>如果你有天马行空的浮动布局构思，可使用 Qt 中的 QWidget，或者使用 Kivy 这类框架完成。</strong><br>在这里要引入 Container Element（容器元素）的概念，它的作用就是在容器内放入一段布局代码，从而实现跟布局中元素的复杂排布。</p><h4 id="2-1-1-通过-Column-元素在布局中创建栏分割"><a href="#2-1-1-通过-Column-元素在布局中创建栏分割" class="headerlink" title="2.1.1. 通过 Column 元素在布局中创建栏分割"></a>2.1.1. 通过 Column 元素在布局中创建栏分割</h4><p><strong>PySimpleGUI 中提供了一种元素来解决这种固定的单行模式，即 <code>Column</code>。</strong><br>观看执行截图，会发现左边的推子和右边的一堆文本输入框之间已经不再是对称的关系了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个 Column 元素，我们会发现它与普通的窗体定义形式一样，也是一个二维列表</span></span><br><span class="line">col = [ [sg.Text(<span class="string">'col Row 1'</span>), sg.Input(<span class="string">'col input 1'</span>)],</span><br><span class="line">        [sg.Text(<span class="string">'col Row 2'</span>), sg.Input(<span class="string">'col input 2'</span>)],</span><br><span class="line">        [sg.Text(<span class="string">'col Row 3'</span>), sg.Input(<span class="string">'col input 3'</span>)],</span><br><span class="line">        [sg.Text(<span class="string">'col Row 4'</span>), sg.Input(<span class="string">'col input 4'</span>)],</span><br><span class="line">        [sg.Text(<span class="string">'col Row 5'</span>), sg.Input(<span class="string">'col input 5'</span>)],</span><br><span class="line">        [sg.Text(<span class="string">'col Row 6'</span>), sg.Input(<span class="string">'col input 6'</span>)],</span><br><span class="line">        [sg.Text(<span class="string">'col Row 7'</span>), sg.Input(<span class="string">'col input 7'</span>)] ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义主窗体，第一行是一个 Slider 元素和我们刚定义好的 Column 元素，后两行分别为普通的文本框和按钮</span></span><br><span class="line">layout = [  [sg.Slider(range=(<span class="number">1</span>,<span class="number">100</span>), default_value=<span class="number">10</span>, orientation=<span class="string">'v'</span>, size=(<span class="number">8</span>,<span class="number">20</span>)), sg.Column(col)],</span><br><span class="line">            [sg.In(<span class="string">'Last input'</span>)],</span><br><span class="line">            [sg.OK()]  ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示窗体，并定义窗口关闭行为</span></span><br><span class="line">window = sg.Window(<span class="string">'第一行使用栏分隔符定义的窗口'</span>, layout)</span><br><span class="line">event = window.read()</span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure></p><p>执行效果：<br><img src="/images/%E4%B8%8D%E5%AF%B9%E7%A7%B0%E5%B8%83%E5%B1%801.png" alt="不对称布局1"></p><p>虽然 <code>Slider</code> 元素和右边的一组元素中间没有显示出分割线，但可看出在布局层面上 <code>Slider</code> 和 <code>Column</code> 两者处于同一行，仍然遵循了 PySimpleGUI 的行布局结构。</p><h4 id="2-1-2-通过-Frame-元素在布局中创建框架分割"><a href="#2-1-2-通过-Frame-元素在布局中创建框架分割" class="headerlink" title="2.1.2. 通过 Frame 元素在布局中创建框架分割"></a>2.1.2. 通过 Frame 元素在布局中创建框架分割</h4><p><code>Frame</code> 元素是大家在软件使用中很常见的一种结构设计，通过外圈框住一部分布局，多用来划分程序之间不同的功能区域。<br>在 PySimpleGUI 中这也是一种实现复杂结构的方法，下面我们来看一段示例代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 Frame 内的结构（框架内的内容），仍是列表套列表的基本窗体结构。第一行为文本，第二行为两个复选框，在这里元素名称使用了缩写</span></span><br><span class="line">frame_layout = [[sg.T(<span class="string">'Frame text content'</span>)],</span><br><span class="line">                [sg.CB(<span class="string">'Check 1'</span>), sg.CB(<span class="string">'Check 2'</span>)]]</span><br><span class="line">               </span><br><span class="line"><span class="comment"># 建立主窗体，第一行为 Frame 元素，可看到传入的第二个参数为刚创建的 Frame 内窗体结构 frame_layout。第二行为两个按钮</span></span><br><span class="line">layout = [  [sg.Frame(<span class="string">'Frame Title'</span>, frame_layout, font=<span class="string">'Any 12'</span>, title_color=<span class="string">'blue'</span>)],</span><br><span class="line">            [sg.OK(), sg.Cancel()]  ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示窗体，并定义窗口关闭行为</span></span><br><span class="line">window = sg.Window(<span class="string">'Frame 元素示例'</span>, layout, font=(<span class="string">"Helvetica"</span>, <span class="number">12</span>))</span><br><span class="line">event = window.read()</span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure></p><p>执行效果：<br><img src="/images/%E4%B8%8D%E5%AF%B9%E7%A7%B0%E5%B8%83%E5%B1%802.png" alt="不对称布局2"></p><h4 id="2-1-3-Column-和-Frame-联用"><a href="#2-1-3-Column-和-Frame-联用" class="headerlink" title="2.1.3. Column 和 Frame 联用"></a>2.1.3. Column 和 Frame 联用</h4><p>下面看一段将上两段代码随便组合而成的布局，这两者可互相套用，以实现更复杂的布局结构。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建三个 Column 元素的内容</span></span><br><span class="line">col1 = [[sg.Text(<span class="string">'col Row 1'</span>), sg.Input(<span class="string">'col input 1'</span>)],</span><br><span class="line">        [sg.Text(<span class="string">'col Row 2'</span>), sg.Input(<span class="string">'col input 2'</span>)],</span><br><span class="line">        [sg.Text(<span class="string">'col Row 3'</span>), sg.Input(<span class="string">'col input 3'</span>)],</span><br><span class="line">        [sg.Text(<span class="string">'col Row 4'</span>), sg.Input(<span class="string">'col input 4'</span>)],</span><br><span class="line">        [sg.Text(<span class="string">'col Row 5'</span>), sg.Input(<span class="string">'col input 5'</span>)],</span><br><span class="line">        [sg.Text(<span class="string">'col Row 6'</span>), sg.Input(<span class="string">'col input 6'</span>)],</span><br><span class="line">        [sg.Text(<span class="string">'col Row 7'</span>), sg.Input(<span class="string">'col input 7'</span>)]]</span><br><span class="line">col2 = <span class="comment"># 与 col1 相同，省略</span></span><br><span class="line">col3 = <span class="comment"># 与 col1 相同，省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组装 Column 元素</span></span><br><span class="line">colall1 = [ [sg.Slider(range=(<span class="number">1</span>,<span class="number">100</span>), default_value=<span class="number">10</span>, orientation=<span class="string">'v'</span>, size=(<span class="number">8</span>,<span class="number">20</span>)), sg.Column(col1)],</span><br><span class="line">           [sg.In(<span class="string">'Last input'</span>)],</span><br><span class="line">           [sg.OK()] ]</span><br><span class="line">colall2 = <span class="comment"># 与 colall1 相同，省略</span></span><br><span class="line">colall3 = <span class="comment"># 与 colall1 相同，省略</span></span><br><span class="line">               </span><br><span class="line"><span class="comment"># 构建布局，并把 Column 分别放到 Frame 元素当中</span></span><br><span class="line">layout = [  [sg.Frame(<span class="string">'Frame Title'</span>, colall1, font=<span class="string">'Any 12'</span>, title_color=<span class="string">'blue'</span>), sg.Frame(<span class="string">'Frame Title'</span>, colall2, font=<span class="string">'Any 12'</span>, title_color=<span class="string">'blue'</span>)],</span><br><span class="line">            [sg.Slider(range=(<span class="number">1</span>,<span class="number">100</span>), default_value=<span class="number">10</span>, orientation=<span class="string">'v'</span>), sg.OK(), sg.Cancel(), sg.Frame(<span class="string">'Frame Title'</span>, colall3, font=<span class="string">'Any 12'</span>, title_color=<span class="string">'blue'</span>)]  ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示窗体，并定义窗口关闭行为</span></span><br><span class="line">window = sg.Window(<span class="string">'元素套用示例'</span>, layout, font=(<span class="string">"Helvetica"</span>, <span class="number">12</span>))</span><br><span class="line">event = window.read()</span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><img src="/images/%E4%B8%8D%E5%AF%B9%E7%A7%B0%E5%B8%83%E5%B1%803.png" alt="不对称布局3"></p><h3 id="2-2-菜单栏"><a href="#2-2-菜单栏" class="headerlink" title="2.2. 菜单栏"></a>2.2. 菜单栏</h3><p>菜单栏几乎是每个现代软件的必备，哪怕看起来隐藏了菜单栏的软件，大多也通过设置类按钮或右键完成了应有的交互。除非做功能相对单一的工具程序，否则一定要考虑菜单栏。<br><strong>通常菜单的功能有：</strong></p><ol><li>打开新的窗口（文件浏览器、设置窗口、帮助文档等）</li><li>执行主窗体中未列出的功能（使用频率比较低的功能）</li></ol><p>下面我们看一下 PySimpleGUI 中简单的菜单实现，因为 <code>Menu</code> 元素在 macOS 下因冲突会有问题，这里在 Windows 下执行代码。<br><strong>为了添加乐趣，我模仿一下 Wwise 的菜单：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg      sg.theme(<span class="string">'Dark Blue 3'</span>)<span class="comment"># 设定菜单的层级结构，仍然是多维列表的形式。其中&amp;代表 Alt + 快捷键，可方便用户使用快捷键触发功能。分隔符代表菜单中的横线，用于分割菜单不同区域</span>menu_def = [[<span class="string">'&amp;Project'</span>],                  [<span class="string">'&amp;Edit'</span>],                  [<span class="string">'&amp;Views'</span>],            [<span class="string">'&amp;Layouts'</span>, [<span class="string">'Designer'</span>, <span class="string">'Profiler'</span>, <span class="string">'SoundBank'</span>, <span class="string">'Mixer'</span>, <span class="string">'Schematic'</span>, <span class="string">'Interactive Music'</span>, <span class="string">'Voice Profiler'</span>, <span class="string">'Game Object Profiler'</span>, <span class="string">'Dynamic Dialogue'</span>, <span class="string">'---'</span>, <span class="string">'Warn When Modifying Docked Layout'</span>, <span class="string">'Reset Facroty Layouts...'</span>]],            [<span class="string">'&amp;Audio'</span>],            [<span class="string">'&amp;Windows'</span>],            [<span class="string">'&amp;Help'</span>, <span class="string">'About...'</span>]]<span class="comment"># Output 元素用来占位，使窗口看得更清晰一些</span>layout = [  [sg.Menu(menu_def)],            [sg.Output(size=(<span class="number">80</span>, <span class="number">30</span>))]  ]      window = sg.Window(<span class="string">"Wwise-like Menu - Wwise 2019.2.4"</span>, layout)        event, values = window.read()      window.close()</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><img src="/images/PySimpleGUI%20Menu-3.png" alt="PySimpleGUI Menu"></p><h3 id="2-3-多窗口"><a href="#2-3-多窗口" class="headerlink" title="2.3. 多窗口"></a>2.3. 多窗口</h3><p>既然我们已经实现了菜单栏，现在就来看一下如何打开新的窗口。<br>PySimpleGUI 中的窗口实现基于 <code>sg.Window()</code> 创建的窗体实例，所以创建一个新窗口是非常简单的。而上面提到的两种不同的窗口设计方法区别，就在于第二个窗口出现时第一个窗口是否要被关闭或隐藏。<br>在实例中我们一切从简，在主窗口中放一个按钮，用来打开另一个窗口。<strong>并设置两种条件，即第二个窗口打开时第一个窗口分是否会被关闭两种情况。</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line">sg.theme(<span class="string">'Dark Blue 3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义三个窗口并封装在函数中，函数的返回值为创建窗口实例，第一个为主窗口</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">window_main</span><span class="params">()</span>:</span></span><br><span class="line">    layout = [  [sg.Button(<span class="string">'Visible'</span>), sg.Button(<span class="string">'Invisible'</span>)],</span><br><span class="line">                [sg.Output(size=(<span class="number">40</span>, <span class="number">20</span>))]  ]</span><br><span class="line">    <span class="keyword">return</span> sg.Window(<span class="string">'Main Window'</span>, layout, finalize=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keep Original 窗口，打开此窗口的话主窗口不会被关闭</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">windows_keep</span><span class="params">()</span>:</span></span><br><span class="line">    layout = [  [sg.Text(<span class="string">'Keep Original'</span>)]  ]</span><br><span class="line">    <span class="keyword">return</span> sg.Window(<span class="string">'Window 1'</span>, layout, finalize=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Kill Original 窗口，打开此窗口的话会把主窗口关闭</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">windows_kill</span><span class="params">()</span>:</span></span><br><span class="line">    layout = [  [sg.Text(<span class="string">'Kill Original'</span>)]  ]</span><br><span class="line">    <span class="keyword">return</span> sg.Window(<span class="string">'Window 2'</span>, layout, finalize=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别创建三个窗口的实例</span></span><br><span class="line">window_main, window_1, window_2 = window_main(), <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 通过 read_all_windows 方法读取窗口、事件等</span></span><br><span class="line">    window, event, values = sg.read_all_windows()</span><br><span class="line">    <span class="comment"># 设定判断条件决定窗口的存留，其中之所以给 window_2 设定跳出循环，是因为 window_2 时主窗口已经关闭，所以无需直接结束程序</span></span><br><span class="line">    <span class="keyword">if</span> event == sg.WIN_CLOSED:</span><br><span class="line">        window.close()</span><br><span class="line">        <span class="keyword">if</span> window == window_1:</span><br><span class="line">            window_1 = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">elif</span> window == window_2:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> window == window_main:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> event == <span class="string">'Visible'</span>:</span><br><span class="line">        window_1 = windows_keep()</span><br><span class="line">    <span class="keyword">elif</span> event == <span class="string">'Invisible'</span>:</span><br><span class="line">        window_2 = windows_kill()</span><br><span class="line">        window_main.hide()</span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><img src="/images/PySimpleGUI%20Multi.png" alt="PySimpleGUI Multi"></p><p>通过执行结果可看出，点击 Visible 后会显示窗口 Keep Original。点击 Invisible 则会关闭主窗口并显示出 Kill Original，这里就不截图了。</p><h3 id="2-4-改变当前布局内的内容"><a href="#2-4-改变当前布局内的内容" class="headerlink" title="2.4. 改变当前布局内的内容"></a>2.4. 改变当前布局内的内容</h3><h4 id="2-4-1-更新数据"><a href="#2-4-1-更新数据" class="headerlink" title="2.4.1. 更新数据"></a>2.4.1. 更新数据</h4><p>更新数据即修改布局中已有元素的属性，以让其显示出不同的内容，在 PySimpleGUI 中只需对窗口使用简单的 <code>update</code> 方法即可完成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line">sg.theme(<span class="string">'Dark Blue 3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建布局，指定第一行第二个 Text 元素的 key 为 '-OUTPUT-'，第二行的 Input 文本框元素的 key 为 '-IN-'，以方便后面通过 update 方法更新数据时找到正确的元素对象</span></span><br><span class="line">layout = [  [sg.Text(<span class="string">'Data you just entered:'</span>), sg.Text(key=<span class="string">'-OUTPUT-'</span>, size=(<span class="number">20</span>, <span class="number">1</span>))],</span><br><span class="line">            [sg.Input(key=<span class="string">'-IN-'</span>)],</span><br><span class="line">            [sg.Button(<span class="string">'Update'</span>)]  ]</span><br><span class="line"></span><br><span class="line">window = sg.Window(<span class="string">'Update Data'</span>, layout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    event, values = window.read()</span><br><span class="line">    <span class="keyword">if</span> event == sg.WIN_CLOSED:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 当点击 Update 按钮后，通过对窗口检索 '-OUTPUT-' 索引以获得第一行第二个 Text 元素，并用 update 方法修改它的值为 '-IN-' 索引对应的 Input 文本框内的值</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'Update'</span>:</span><br><span class="line">        window[<span class="string">'-OUTPUT-'</span>].update(values[<span class="string">'-IN-'</span>])</span><br><span class="line"></span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><img src="/images/Before%20Update.png" alt="Before Update"><br>数据更新前<br><img src="/images/After%20Update.png" alt="After Update"><br>数据更新后</p><h4 id="2-4-2-更新布局"><a href="#2-4-2-更新布局" class="headerlink" title="2.4.2. 更新布局"></a>2.4.2. 更新布局</h4><p>有时我们需要窗口中的布局发生变化，<strong>比如当事件发生时，增减窗口内的按钮或复选框等元素</strong>。<br>与上文中提到的更新数据不同，<strong>更新数据是对已有控件的属性进行修改，而可变布局是在已有布局中创建新的或删除现有的元素，</strong><br>PySimpleGUI 并不支持对已经创建的窗口进行动态改变，但我们可以换个思路来实现。这也是开发者 Mike 的建议，直接创建一个新窗口以显示新布局，同时隐藏或关闭之前的老窗口。<br><strong>在例子中，当按下按钮 Change，会自动在当前布局最下方添加新的元素（从新窗口中体现）。</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line">sg.theme(<span class="string">'Dark Blue 3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 Frame 元素，放入一些元素作为初始布局</span></span><br><span class="line">frame = [   [sg.T(<span class="string">'Fantasy'</span>)],</span><br><span class="line">            [sg.CB(<span class="string">'Scaramouche'</span>), sg.CB(<span class="string">'Fandango'</span>)]   ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义主布局，并创建主窗口</span></span><br><span class="line">layout = [  [sg.Frame(<span class="string">'Original Layout'</span>, frame, title_color=<span class="string">'blue'</span>)],</span><br><span class="line">            [sg.Button(<span class="string">'Change'</span>)]  ]</span><br><span class="line">window = sg.Window(<span class="string">'Layout Changer'</span>, layout, finalize=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment"># 因涉及多窗口管理，需使用 read_all_windows 方法</span></span><br><span class="line">    window, event, values = sg.read_all_windows()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> event == sg.WIN_CLOSED: </span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'Change'</span>:</span><br><span class="line">        <span class="comment"># 此处使用 window.hide() 隐藏窗口也可，取决于是否要关闭之前的窗口</span></span><br><span class="line">        window.close()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 定义新窗口的布局，并生成新窗口</span></span><br><span class="line">        frame_new = [   [sg.T(<span class="string">'Reality'</span>)],</span><br><span class="line">                        [sg.CB(<span class="string">'Bismillah'</span>), sg.CB(<span class="string">'Beelzebub'</span>)]   ]</span><br><span class="line">        layout_new = [  [sg.Frame(<span class="string">'New Layout'</span>, frame_new, title_color=<span class="string">'red'</span>)]  ]</span><br><span class="line">        window_new = sg.Window(<span class="string">'Layout New'</span>, layout_new, finalize=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><img src="/images/Old_Layout.png" alt="Old_Layout"><br>主窗口<br><img src="/images/New_Layout.png" alt="New_Layout"><br>新窗口</p><h3 id="2-5-指定接受信息的目标控件"><a href="#2-5-指定接受信息的目标控件" class="headerlink" title="2.5. 指定接受信息的目标控件"></a>2.5. 指定接受信息的目标控件</h3><p>在第一篇文章最后的根据声道数修改文件名的小程序中，我们构建了如下的布局：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">layout = [  [sg.Text(<span class="string">'Browse Folders'</span>)],</span><br><span class="line">            [sg.Input(), sg.FolderBrowse(<span class="string">'Browse'</span>, key=<span class="string">'folder'</span>)],</span><br><span class="line">            [sg.Output(size=(<span class="number">70</span>, <span class="number">20</span>), font=(<span class="string">"宋体"</span>, <span class="number">10</span>))],</span><br><span class="line">            [sg.Button(<span class="string">'Cock it'</span>), sg.Button(<span class="string">'Cancel'</span>)] ]</span><br></pre></td></tr></table></figure></p><p>如果还记得这个程序的执行效果，会发现 <code>FolderBrowse</code>（文件夹选择器）元素所选择的文件夹路径会自动填入左边的 <code>Input</code>（文本框）元素中。<br>但本着编程所需的严谨，我们应该思考<strong>为什么会发生代码未指定，程序却自动帮用户把数据填入某个文本框了？</strong>事实上这和 PySimpleGUI 的设计细节有关系，在这里不加以讨论。<br>如果对这类选择器元素有数据传输目标的设定，可以在属性中加上 <code>target</code> 参数。例如下例中，具有具有好几个文本框的情况下，<code>FolderBrowse</code> 只会把文件路径数据传入设定好的文本框内。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line">sg.theme(<span class="string">'Dark Blue 3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据代码设置，FolderBrowse 获取的文件夹只会在第二个文本框中显示</span></span><br><span class="line">layout = [  [sg.Text(<span class="string">'Browse Folders'</span>)],</span><br><span class="line">            [sg.FolderBrowse(<span class="string">'Browse'</span>, target=<span class="string">'input'</span>)],</span><br><span class="line">            [sg.Input()],</span><br><span class="line">            [sg.Input(key=<span class="string">'input'</span>)],</span><br><span class="line">            [sg.Input()]  ]</span><br><span class="line"></span><br><span class="line">window = sg.Window(<span class="string">'GUI Enemy No. 1'</span>, layout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    event, values = window.read()</span><br><span class="line">    <span class="keyword">if</span> event <span class="keyword">in</span> (<span class="keyword">None</span>, <span class="string">'Cancel'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure></p><p>执行效果：<br><img src="/images/PySimpleGUI%20Target.png" alt="PySimpleGUI Target"><br>点击 Browse 选择文件夹后，可见按 <code>target</code> 设置放入了指定的文本框中。</p><h3 id="2-6-简单的多线程"><a href="#2-6-简单的多线程" class="headerlink" title="2.6. 简单的多线程"></a>2.6. 简单的多线程</h3><p>在做有点复杂的工具时，多线程是一个离不开的话题。<br>在之前的程序中，一切都是单线程的，一旦陷入死循环或者 PySimpleGUI 本身的阻塞窗口阅读逻辑中，程序就进行不下去了。如果我们需要获得同时进行的程序逻辑，就必须通过多线程来解决。<br><strong>PySimpleGUI 只能在主线程中运行，在进行多线程设计的时候要注意这一点。</strong><br>在下面的程序中，我们让多线程同时进行两个逻辑：</p><ol><li>进行时间统计，让计数器每隔5秒输出字符串 Second Thread Here! 和时间戳</li><li>显示一个简单的窗体，等待 windows.read() 的返回</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建子线程的任务，每隔5秒输出字符串 Second Thread Here!</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">second_thread</span><span class="params">(window)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        localtime = time.asctime(time.localtime(time.time()))</span><br><span class="line">        print(<span class="string">"Second thread here! TIME:"</span>, localtime)</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行子线程，并设置为 daemon 以保证会继承父线程的状态</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">second_thread_function</span><span class="params">()</span>:</span></span><br><span class="line">    threading.Thread(target=second_thread, args=(window,), daemon=<span class="keyword">True</span>).start()</span><br><span class="line"></span><br><span class="line">sg.theme(<span class="string">'Dark Blue 3'</span>)</span><br><span class="line"></span><br><span class="line">layout = [  [sg.Output(size=(<span class="number">50</span>,<span class="number">10</span>))],</span><br><span class="line">            [sg.Button(<span class="string">'Run Second Thread'</span>), sg.Button(<span class="string">'Exit'</span>)]  ]</span><br><span class="line"></span><br><span class="line">window = sg.Window(<span class="string">'Main Thread'</span>, layout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    event, values = window.read()</span><br><span class="line">    <span class="keyword">if</span> event == sg.WIN_CLOSED <span class="keyword">or</span> event == <span class="string">'Exit'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">"Run Second Thread"</span>:</span><br><span class="line">        second_thread_function()</span><br><span class="line"></span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure><p>执行效果：<br><img src="/images/Multi_Thread.png" alt="Multi_Thread"></p><p>当程序运行后，文本框内什么都没有。而在点击按钮后会执行子线程并不断打印出字符串和时间，此时主线程（窗口本身）的功能一切是正常的，可随时退出。<br>如果疯狂点击 Run Second Thread，可以不断增加新的子线程，且不会对主窗口产生什么影响。</p><h3 id="2-7-更多控件"><a href="#2-7-更多控件" class="headerlink" title="2.7. 更多控件"></a>2.7. 更多控件</h3><p>这里再列出一些比较重要的控件，方便大家引用：<br><code>FileBrowse</code>：单文件选择<br><code>FilesBrowse</code>：多文件选择<br><code>Combo</code>：下拉选择菜单<br><code>Radio</code>：单选按钮<br><code>Slider</code>：滚动条<br><code>ProgressBar</code>：进度条<br><code>ButtonMenu</code>：按钮菜单（在 macOS 下可作为替代品）<br><code>Image</code>：图片查看<br><code>TabGroup</code>：选项卡</p><h2 id="使用-QT-Designer-PySimpleGUIDesigner-快速构建布局代码"><a href="#使用-QT-Designer-PySimpleGUIDesigner-快速构建布局代码" class="headerlink" title="使用 QT Designer + PySimpleGUIDesigner 快速构建布局代码"></a>使用 QT Designer + PySimpleGUIDesigner 快速构建布局代码</h2><p>本着“一切均可优化“的思维，我们会想<strong>有没有快速构建 PySimpleGUI 布局代码的工具呢？</strong>所见即所得的布局绘制工具才是王道。<br>nngogol 开发了 PySimpleGUIDesigner，可以把 QtDesigner 创建的布局文件转为 PySimpleGUI 格式的代码，能够大大提高布局部分代码的创建速度。<br>有了它的帮助，我们只需理清并完成 Event Loop 逻辑，就可快速开发想要的小工具了。</p><h3 id="3-1-通过-Qt-Designer-创建布局"><a href="#3-1-通过-Qt-Designer-创建布局" class="headerlink" title="3.1. 通过 Qt Designer 创建布局"></a>3.1. 通过 Qt Designer 创建布局</h3><p>用过 Qt 的朋友对 Qt Designer 会比较熟悉。作为一款双平台可用的 Qt 布局绘制工具，我们只需在其中绘制好布局，再把绘制完成的 .ui 文件（本质上是 XML 格式的布局文件）通过 pyuic5 即可转为 Qt 的 Python GUI 代码。<br><strong>而 PySimpleGUIDesigner 正是巧妙的利用了 .ui 文件方便的中间格式特征，将其直接转为 PySimpleGUI 的代码。</strong><br>关于 Qt Designer 的安装和使用在此不再赘述，可参考以下链接：</p><ul><li><a href="https://build-system.fman.io/qt-designer-download" target="_blank" rel="noopener">https://build-system.fman.io/qt-designer-download</a></li><li><a href="https://doc.qt.io/qt-5/qtdesigner-manual.html" target="_blank" rel="noopener">https://doc.qt.io/qt-5/qtdesigner-manual.html</a></li></ul><p>受限于 PySimpleGUI 的 GUI 设计哲学，我们<strong>仍需要以元素按行排布的逻辑进行布局构建</strong>，即要把控件全都放置到 Qt Designer 的 Layout 内以规则排布，并放置到 Box 或 Frame 容器内。<br>对于控件位置随意的浮动布局，需参考文初提到的其它框架来完成。<br>从实用角度而言，“行布局”这种结构是完全够用的，无需担心功能无法实现。<br>我们在 Qt Designer 中创建一个简单的布局：<br><img src="/images/QT1.png" alt="QT1"></p><h3 id="3-2-安装-PySimpleGUIDesigner"><a href="#3-2-安装-PySimpleGUIDesigner" class="headerlink" title="3.2. 安装 PySimpleGUIDesigner"></a>3.2. 安装 PySimpleGUIDesigner</h3><p>PySimpleGUIDesigner 安装可通过一行简单的 <code>pip install PySimpleGUIDesigner</code> 来完成，并且还需安装 <code>PySide2</code>和 <code>click</code> 两个依赖。<br>安装完成后，在命令行执行 <code>PySimpleGUIDesigner</code> 即可打开图形版本的程序。有点可惜的是，作者的 GUI 设计审美实在不怎么样。<br><img src="/images/PySimpleGUIDesigner.png" alt="PySimpleGUIDesigner"><br>PySimpleGUIDesigner 主页面<br>另外附上 GitHub 地址：<a href="https://github.com/nngogol/PySimpleGUIDesigner" target="_blank" rel="noopener">https://github.com/nngogol/PySimpleGUIDesigner</a></p><h3 id="3-3-转换布局文件为-PySimpleGUI-代码"><a href="#3-3-转换布局文件为-PySimpleGUI-代码" class="headerlink" title="3.3. 转换布局文件为 PySimpleGUI 代码"></a>3.3. 转换布局文件为 PySimpleGUI 代码</h3><p>浏览打开之前我创建的 test.ui 文件，target object name 中选择要进行布局转换的 Qt 容器。在这个例子中因为 UI 元素单一，使用默认的即可。<br>点击 convert 即可看到转换好的代码：<br><img src="/images/PySimpleGUIDesigner%20Code1.png" alt="PySimpleGUIDesigner Code1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成的不含 Event Loop 的纯布局代码</span></span><br><span class="line">sg.Frame(<span class="string">''</span>, layout = [</span><br><span class="line">   [sg.T(<span class="string">'First name'</span>), sg.I(<span class="string">''</span>)],</span><br><span class="line">   [sg.T(<span class="string">'Second name'</span>), sg.I(<span class="string">''</span>)],</span><br><span class="line">   [sg.T(<span class="string">'Age'</span>), sg.Spin(list(range(<span class="number">0</span>, <span class="number">99</span>)), initial_value=<span class="number">0</span>)],</span><br><span class="line">   [sg.T(<span class="string">''</span>), sg.B(<span class="string">'OK'</span>, key=<span class="string">'clickeme__1'</span>)]</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>点击 convert + all events 也可看到包含 Event Loop 的完整源码：<br><img src="/images/PySimpleGUIDesigner%20Code%202.png" alt="PySimpleGUIDesigner Code 2"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成的含 Event Loop 的完整代码</span></span><br><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line">layout = [</span><br><span class="line"> [sg.Frame(<span class="string">''</span>, layout = [</span><br><span class="line">   [sg.T(<span class="string">'First name'</span>), sg.I(<span class="string">''</span>)],</span><br><span class="line">   [sg.T(<span class="string">'Second name'</span>), sg.I(<span class="string">''</span>)],</span><br><span class="line">   [sg.T(<span class="string">'Age'</span>), sg.Spin(list(range(<span class="number">0</span>, <span class="number">99</span>)), initial_value=<span class="number">0</span>)],</span><br><span class="line">   [sg.T(<span class="string">''</span>), sg.B(<span class="string">'OK'</span>, key=<span class="string">'clickeme__1'</span>)]</span><br><span class="line">])]]</span><br><span class="line">window = sg.Window(<span class="string">'App'</span>, layout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    event, values = window.read()</span><br><span class="line">    <span class="keyword">if</span> event <span class="keyword">in</span> (<span class="keyword">None</span>, <span class="string">'Exit'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">''</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> event == <span class="string">'clickeme__1'</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure><h3 id="3-4-执行测试"><a href="#3-4-执行测试" class="headerlink" title="3.4. 执行测试"></a>3.4. 执行测试</h3><p>可以看到，PySimpleGUIDesigner 把一些布局中的空格部分也转换为了相应的代码，我们加以修改并完善一下。<br>其中 <code>Frame</code> 元素主要是为了在 Qt Designer 中进行布局规划，可根据需求去掉。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line">frame = [   [sg.T(<span class="string">'First name'</span>), sg.I(<span class="string">''</span>)],</span><br><span class="line">            [sg.T(<span class="string">'Second name'</span>), sg.I(<span class="string">''</span>)],</span><br><span class="line">            [sg.T(<span class="string">'Age'</span>), sg.Spin(list(range(<span class="number">0</span>, <span class="number">99</span>)), initial_value=<span class="number">0</span>)],</span><br><span class="line">            [sg.T(<span class="string">''</span>), sg.B(<span class="string">'OK'</span>, key=<span class="string">'clickeme__1'</span>)]   ]</span><br><span class="line"></span><br><span class="line">layout = [  [sg.Frame(<span class="string">'Qt Frame'</span>, frame, title_color=<span class="string">'blue'</span>)]]</span><br><span class="line"></span><br><span class="line">window = sg.Window(<span class="string">'PySimpleGUIDesigner Demo'</span>, layout, font=(<span class="string">"Helvetica"</span>, <span class="number">12</span>))</span><br><span class="line"></span><br><span class="line">event = window.read()</span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><img src="/images/PySimpleGUIDesigner%20Result.png" alt="PySimpleGUIDesigner Result"></p><p>容易看出，因为 PySimpleGUIDesigner 在生成代码的时候加入了额外的 <code>sg.T(&#39;&#39;)</code> 等占位符，导致与代码直接书写出的布局略有不同，但这部分后期按需修改去掉即可，在这里就不加以演示了。</p><h2 id="如何阅读-PySimpleGUI-官方文档"><a href="#如何阅读-PySimpleGUI-官方文档" class="headerlink" title="如何阅读 PySimpleGUI 官方文档"></a>如何阅读 PySimpleGUI 官方文档</h2><p>PySimpleGUI 的官方文档总共分为三大板块，与一般的文档不同，PySimpleGUI 的作者比较话痨，所以在技术文档中会少见的看到他所写的散文叙述，这也让看习惯干巴巴技术文档的人可能不太习惯。</p><h3 id="Home"><a href="#Home" class="headerlink" title="Home"></a>Home</h3><p>建议初学者通读这部分，不仅能够在前面的“散文”部分了解作者 Mike 的设计理念，也能一览 PySimpleGUI 的全貌。</p><h3 id="Call-Reference"><a href="#Call-Reference" class="headerlink" title="Call Reference"></a>Call Reference</h3><p>这部分是 PySimpleGUI 的参考手册，建议查找参数时善用页面内搜索以获得想要结果。</p><h3 id="Cookbook"><a href="#Cookbook" class="headerlink" title="Cookbook"></a>Cookbook</h3><p>PySimpleGUI 的特色项目之一，作者鼓励大家多用 Cookbook 中的 Recipe，选择自己需要的设计模式，直接复制粘贴出来，进一步改善 GUI 创建的效率。</p><h2 id="实例程序"><a href="#实例程序" class="headerlink" title="实例程序"></a>实例程序</h2><p>既然这系列文章的标题是《写给声音设计师的极速 GUI 开发大法》，即后期的实例会围绕 WAAPI、ReaScript 等主题展开，也可能涉及些 Python 音频相关库如 pydub、librosa 等。</p><h3 id="5-1-程序需求"><a href="#5-1-程序需求" class="headerlink" title="5.1. 程序需求"></a>5.1. 程序需求</h3><p>在《人人都能用 WAAPI（二）wwise.core 分支》的结尾中有一段根据文件名导入 Wwise 的代码，在这里再加入获取工程信息的功能，并且把导入成功与获取后的信息都打印到程序的文本框中。<br>并且我们加上双语选项，即让当用户点击切换语言按钮时，实现中英文切换以扩大用户群体。</p><h3 id="5-2-原型构建"><a href="#5-2-原型构建" class="headerlink" title="5.2. 原型构建"></a>5.2. 原型构建</h3><p><img src="/images/GUI%20Prototype.png" alt="GUI Prototype"><br>使用 Pencil 绘制原型</p><h3 id="5-3-功能代码"><a href="#5-3-功能代码" class="headerlink" title="5.3. 功能代码"></a>5.3. 功能代码</h3><p>略，请参考《人人都能用 WAAPI（二）wwise.core 分支》。</p><h3 id="5-4-GUI-代码"><a href="#5-4-GUI-代码" class="headerlink" title="5.4. GUI 代码"></a>5.4. GUI 代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line">sg.theme(<span class="string">'Dark Blue 3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">window_eng</span><span class="params">()</span>:</span> <span class="comment"># 封装英文窗口</span></span><br><span class="line">    <span class="comment"># 英文子布局</span></span><br><span class="line">    file_importer_frame_eng = [ [sg.Input(size=(<span class="number">42</span>, <span class="number">1</span>)), sg.FolderBrowse(<span class="string">'Browse'</span>, key=<span class="string">'folder'</span>)],</span><br><span class="line">                                [sg.Button(<span class="string">'Import'</span>)] ]</span><br><span class="line">    language_switch_frame_eng = [   [sg.Radio(<span class="string">'English'</span>, <span class="string">"RADIO1"</span>, default=<span class="keyword">True</span>, size=(<span class="number">10</span>,<span class="number">1</span>))],</span><br><span class="line">                                    [sg.Radio(<span class="string">'Chinese'</span>, <span class="string">"RADIO1"</span>, default=<span class="keyword">False</span>, size=(<span class="number">10</span>,<span class="number">1</span>), key=<span class="string">"-IN1-"</span>)],</span><br><span class="line">                                    [sg.Button(<span class="string">'Switch'</span>)]   ]</span><br><span class="line">    button_column_eng = [   [sg.Button(<span class="string">'Get Project Info'</span>)],</span><br><span class="line">                            [sg.Button(<span class="string">'Exit'</span>)]   ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 英文主布局</span></span><br><span class="line">    layout_eng = [  [sg.Frame(<span class="string">'File Importer'</span>, file_importer_frame_eng, title_color=<span class="string">'blue'</span>, element_justification=<span class="string">"c"</span>), sg.Frame(<span class="string">'Language Switch'</span>, language_switch_frame_eng, title_color=<span class="string">'blue'</span>, element_justification=<span class="string">'c'</span>)],</span><br><span class="line">                    [sg.Output(size=(<span class="number">50</span>,<span class="number">10</span>)), sg.Column(button_column_eng, element_justification=<span class="string">"c"</span>)]  ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回英文主窗口，此处 Window 后忘记了括号</span></span><br><span class="line">    <span class="keyword">return</span> sg.Window(<span class="string">'PySimpleGUI + WAAPI (Multi-Window'</span>, layout_eng, finalize=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">window_zh</span><span class="params">()</span>:</span> <span class="comment"># 封装中文窗口</span></span><br><span class="line">    <span class="comment"># 中文子布局</span></span><br><span class="line">    file_importer_frame_zh = [  [sg.Input(size=(<span class="number">39</span>, <span class="number">1</span>)), sg.FolderBrowse(<span class="string">'浏览文件夹'</span>, key=<span class="string">'folder'</span>)],</span><br><span class="line">                                [sg.Button(<span class="string">'导入'</span>)]  ]</span><br><span class="line">    language_switch_frame_zh = [    [sg.Radio(<span class="string">'英文'</span>, <span class="string">"RADIO2"</span>, default=<span class="keyword">True</span>, size=(<span class="number">10</span>,<span class="number">1</span>), key=<span class="string">"-IN2-"</span>)],</span><br><span class="line">                                    [sg.Radio(<span class="string">'中文'</span>, <span class="string">"RADIO2"</span>, default=<span class="keyword">False</span>, size=(<span class="number">10</span>,<span class="number">1</span>))],</span><br><span class="line">                                    [sg.Button(<span class="string">'切换'</span>)]    ]</span><br><span class="line">    button_column_zh = [    [sg.Button(<span class="string">'获得工程消息'</span>)],</span><br><span class="line">                            [sg.Button(<span class="string">'退出'</span>)]    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 中文主布局</span></span><br><span class="line">    layout_zh = [   [sg.Frame(<span class="string">'导入文件'</span>, file_importer_frame_zh, title_color=<span class="string">'blue'</span>, element_justification=<span class="string">'c'</span>), sg.Frame(<span class="string">'语言选择'</span>, language_switch_frame_zh, title_color=<span class="string">'blue'</span>, element_justification=<span class="string">'c'</span>)],</span><br><span class="line">                    [sg.Output(size=(<span class="number">50</span>,<span class="number">10</span>)), sg.Column(button_column_zh, element_justification=<span class="string">'c'</span>)]   ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回中文主窗口，此处 Window 后忘记了括号</span></span><br><span class="line">    <span class="keyword">return</span> sg.Window(<span class="string">'PySimpleGUI + WAAPI (Multi-Window'</span>, layout_zh, finalize=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先只创建英文主窗口实例</span></span><br><span class="line">window1, window2 = window_eng(), <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    window, event, values = sg.read_all_windows()</span><br><span class="line">    <span class="keyword">if</span> event <span class="keyword">in</span> (<span class="keyword">None</span>, <span class="string">'Exit'</span>, <span class="string">'退出'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 设定判断条件，以响应不同窗口下的语言切换逻辑</span></span><br><span class="line">    <span class="keyword">elif</span> event == <span class="string">"Switch"</span> <span class="keyword">or</span> <span class="string">"切换"</span>:</span><br><span class="line">        <span class="keyword">if</span> window == window1 <span class="keyword">and</span> values[<span class="string">"-IN1-"</span>] == <span class="keyword">True</span>:</span><br><span class="line">            window2 = window_zh()</span><br><span class="line">            window1.Hide()</span><br><span class="line">        <span class="keyword">elif</span> window == window2 <span class="keyword">and</span> values[<span class="string">"-IN2-"</span>] == <span class="keyword">True</span>:</span><br><span class="line">            window1.UnHide()</span><br><span class="line">            window2.Hide()</span><br><span class="line"></span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure><h3 id="5-5-运行效果"><a href="#5-5-运行效果" class="headerlink" title="5.5. 运行效果"></a>5.5. 运行效果</h3><p>当执行英文窗口中选中文选项和中文窗口选英文选项这两个逻辑的时候，可以看到窗口实现了正确切换。<br>而在英文窗口中选英文选项，在中文窗口选中文选项，根据代码，这两条逻辑会让窗口保持在当前语言不切换。<br><img src="/images/%E8%8B%B1%E6%96%87%E7%AA%97%E4%BD%93.png" alt="英文窗口"><br>英文版窗口<br><img src="/images/%E4%B8%AD%E6%96%87%E7%AA%97%E4%BD%93.png" alt="中文窗口"><br>中文版窗口</p><h3 id="5-6-打包为-exe-可执行文件（Windows）"><a href="#5-6-打包为-exe-可执行文件（Windows）" class="headerlink" title="5.6. 打包为 exe 可执行文件（Windows）"></a>5.6. 打包为 exe 可执行文件（Windows）</h3><p>为了打包为 exe 可执行文件，需要安装 <code>PyInstaller</code>，需要在终端或命令行执行 <code>pip install PyInstaller</code>。如果使用 conda，则输入 <code>conda install PyInstaller</code>。<br>随后在命令行执行 <code>pyinstaller -wF program_name.py</code> 即可生成 exe 文件。<br><img src="/images/Win%20EXE.png" alt="Win EXE"><br>Win10 下打包好后的 exe 文件执行图<br>如果想偷懒，也可以使用下面打包好的 exe 生成器来进行操作：</p><ul><li><a href="https://pypi.org/project/pysimplegui-exemaker/#description" target="_blank" rel="noopener">https://pypi.org/project/pysimplegui-exemaker/#description</a></li><li><a href="https://zhuanlan.zhihu.com/p/95222129" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/95222129</a></li></ul><h3 id="5-7-打包为-app-可执行文件（macOS）"><a href="#5-7-打包为-app-可执行文件（macOS）" class="headerlink" title="5.7. 打包为 app 可执行文件（macOS）"></a>5.7. 打包为 app 可执行文件（macOS）</h3><p>对于生成 macOS App 的需求，根据官网文档可使用 <code>pyinstaller --onefile --add-binary=&#39;/System/Library/Frameworks/Tk.framework/Tk&#39;:&#39;tk&#39; --add-binary=&#39;/System/Library/Frameworks/Tcl.framework/Tcl&#39;:&#39;tcl&#39; your_program.py</code> 或添加 <code>--windowed</code> 参数到 pyinstaller 的命令行中。<br>不过遗憾的是 pyinstaller 在 macOS 下生成 PySimpleGUI 的程序没有反应，只能在终端打开的情况下运行。<br>为解决这个问题，我们要使用另外一个打包工具 Platypus：</p><ol><li>在 Script Type 中选择你的 Python 环境，在本例中我使用 Conda，所以填写入 <code>/anaconda3/bin/python</code>。</li><li>如果对图标有需求可选择需要的图标文件。</li><li>在 Interface 处选择 None，我们的程序本身就有 GUI，所以无需 Platypus 为我们创建图形外壳。</li><li>Identifier 和 Author 处可按需填入，之后按 Create App 生成 App 文件。</li></ol><p><img src="/images/Platypus%20%E9%85%8D%E7%BD%AE.png" alt="Platypus 配置"><br>Platypus 配置与生成的可执行文件<br><img src="/images/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6.png" alt="可执行文件"><br>执行可执行 App 文件后打开的窗口</p><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2><p>在学完本文后，相信大家已经对 PySimpleGUI 有了足够的认识，并能按照想法设计一些程序了。<br>接下来我会联动《人人都能用 WAAPI》和《写给声音设计师的极速 GUI 开发大法》，为大家带来一些我和朋友们开源项目的 GUI 代码分析。<br>考虑到受众群体。<strong>我会尽量对除了 Python 基本概念之外的代码都书写注释，只要有 Python 基础都能看懂。</strong>希望作为这两个系列文章的联动产物，为大家展现更多工作中的实际应用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 音频编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WAAPI is for Everyone | Part 1 Overview</title>
      <link href="/2020/11/14/WAAPI%20is%20for%20Everyone%20P1/"/>
      <url>/2020/11/14/WAAPI%20is%20for%20Everyone%20P1/</url>
      
        <content type="html"><![CDATA[<p>Hello. I’m Thomas Wang (also known as Xi Ye).<br>I discovered WAAPI (Wwise Authoring API) in the second half of last year. For a non-professional programmer like me, it was easy to get overwhelmed with new concepts like WAMP, JSON etc. Nevertheless, aside from the official documents, there are very few videos, articles and projects shared by other developers. Instead of asking for help, I tried to figure things out all by myself. And, I learned a lot.</p><blockquote><p>In open source, we feel strongly that to really do something well, you have to get a lot of people involved.  — Linus Torvalds</p></blockquote><p><strong>Ideas are only valuable if you put them out to the world, right?</strong> So, with the open source spirit in mind, I decided to share this WAAPI guide series with you all. They are more like a complement to the official documents, yet more approachable and beginner friendly.<br>Being beginner friendly doesn’t mean that you have to start from scratch. Instead, with these guides, it will be easier as you venture into the world of WAAPI. <strong>The tool I’m using is Python, so our discussion will be based on that. Of course, you can use other programming languages supported by WAAPI to make remote calls (using C# to call WAAPI for instance).</strong></p><blockquote><p>This blog series assume that:</p><ul><li>You know how to configure the development environment, install and use Python, Anaconda, pip, VS Code, PyCharm etc.</li><li>You are familiar with basic Python syntax.</li><li>You have a comprehensive understanding of Wwise features.</li><li>You are eager to optimize the existing Wwise workflow.</li><li>You know something about mind maps.</li></ul></blockquote><h2 id="Why-Should-We-Use-WAAPI"><a href="#Why-Should-We-Use-WAAPI" class="headerlink" title="Why Should We Use WAAPI?"></a>Why Should We Use WAAPI?</h2><h3 id="1-1-Have-You-Ever-Struggled-to-Work-More-Efficiently-When-Using-Wwise"><a href="#1-1-Have-You-Ever-Struggled-to-Work-More-Efficiently-When-Using-Wwise" class="headerlink" title="1.1. Have You Ever Struggled to Work More Efficiently When Using Wwise?"></a>1.1. Have You Ever Struggled to Work More Efficiently When Using Wwise?</h3><ul><li>Is it possible to reduce the click and drag &amp; drop operations?</li><li>How to create playback rules easily for hundreds or maybe even thousands of imported assets?</li><li>Can we automate the logic connection when using Game Syncs, Events or SoundBanks?</li><li>How to build a dynamic interaction between DAW and Wwise?</li><li>How to link the CI system to constantly optimize the integration pipeline?</li><li>etc.</li></ul><h3 id="1-2-What’s-The-Point-of-Introducing-WAAPI"><a href="#1-2-What’s-The-Point-of-Introducing-WAAPI" class="headerlink" title="1.2. What’s The Point of Introducing WAAPI?"></a>1.2. What’s The Point of Introducing WAAPI?</h3><p>If you have asked yourself any of the questions listed above, WAAPI would be a good answer.<br>As a great feature introduced in Wwise 2017.1, WAAPI is meant to execute repetitive tasks and streamline the workflow. Using WAAPI, you can do all kinds of operations such as retrieving project information, importing audio files, building container hierarchies, posting Events, setting Game Syncs etc. <strong>WAAPI is an essential tool for sound designers to optimize the Wwise workflow. It can save you a lot of time, allowing you to focus on the creative side of things.</strong><br>Many companies in the industry don’t have such a position like Game Audio Programmer or Technical Sound Designer. If you happen to be employed by one of them, this blog could be very helpful. <strong>The best way to streamline your workflow is constant optimization of repetitive tasks. Instead of waiting and wondering, let’s see how to actually do it.</strong></p><h3 id="1-3-Aren’t-The-Official-Documents-Thorough-Enough"><a href="#1-3-Aren’t-The-Official-Documents-Thorough-Enough" class="headerlink" title="1.3. Aren’t The Official Documents Thorough Enough?"></a>1.3. Aren’t The Official Documents Thorough Enough?</h3><p>Among all audio middlewares as far as I know, Wwise has the most thorough localized official documents. <strong>Yet, you still need some background tech knowledge to learn and use WAAPI.</strong> That’s why I wrote this blog series, hoping to make an useful complement to those documents. Meanwhile, there are great articles talking about WAAPI on the Audiokinetic blog. Enjoy reading them if you like.</p><h2 id="Learning-WAAPI-More-Efficiently-Using-Mind-Maps"><a href="#Learning-WAAPI-More-Efficiently-Using-Mind-Maps" class="headerlink" title="Learning WAAPI More Efficiently Using Mind Maps"></a>Learning WAAPI More Efficiently Using Mind Maps</h2><h3 id="2-1-Summarizing-WAAPI-Essentials-With-Mind-Maps"><a href="#2-1-Summarizing-WAAPI-Essentials-With-Mind-Maps" class="headerlink" title="2.1 Summarizing WAAPI Essentials With Mind Maps"></a>2.1 Summarizing WAAPI Essentials With Mind Maps</h3><p>As an important learning tool, mind maps inspired me tremendously in the past eight years.<br>As you can see, there are a wide variety of WAAPI APIs. It takes time for you to search them in the documents and find out which one does what. For instance, how do you know that you can use ak.wwise.core.object.get when you want to carry out API queries?<br><img src="/images/%E7%B9%81%E7%90%90%E7%9A%84API.png" alt=""></p><p>I was wondering if there is a better way to do this. And, bingo!<br>Creating mind maps came to my mind. How to summarize WAAPI essentials with mind maps? Let’s take ak.wwise.core.object.get for example.</p><ol><li>First, forget about the <code>ak</code> prefix. Then you divide the rest into three parts: <code>wwise.core</code>, <code>object</code> and <code>get</code>.</li><li>Then you sort all APIs by their features, using boxes to identify them.</li></ol><p><img src="/images/%E5%AF%BC%E5%9B%BE1.png" alt="Global View"></p><p><img src="/images/%E5%AF%BC%E5%9B%BE2.png" alt="Local View"></p><h3 id="2-2-Importing-Into-the-Knowledge-Base-for-Further-Clarification"><a href="#2-2-Importing-Into-the-Knowledge-Base-for-Further-Clarification" class="headerlink" title="2.2. Importing Into the Knowledge Base for Further Clarification"></a>2.2. Importing Into the Knowledge Base for Further Clarification</h3><p>Now we’ve built a basic logic system for learning WAAPI. Next, we need to import the information into MarginNote 3 for further clarification.<br><img src="/images/%E5%AF%BC%E5%9B%BE3.png" alt="Here is how it looks in MN3"></p><p>Now you can see the whole picture of WAAPI very clearly. More importantly, it provides you a better way to learn and use these APIs. This works for me, and maybe for you too. Certainly, you may choose any other tools that suit you better.<br><strong>I won’t show you all the mind maps that I created.</strong> You can make your own ones with the method mentioned previously. It shouldn’t be that difficult.If you are interested, you can redo what I just did. It doesn’t matter whether you choose MarginNote 3, XMind or something else. <strong>The most important thing is that you actually do it.</strong></p><h2 id="How-I-Wrote-This-Blog-Series"><a href="#How-I-Wrote-This-Blog-Series" class="headerlink" title="How I Wrote This Blog Series?"></a>How I Wrote This Blog Series?</h2><p>Now that you know how I summarized WAAPI essentials. Let’s talk about how I wrote this blog series.<br><strong>WAAPI APIs can be divided into two categories: execution (Functions) and subscription (Topics)</strong>. Based on this, I wrote this blog series.<br>(Note: Again, I left out the ak. prefix.)</p><ol><li>Overview</li><li>wwise.core (mainly execution APIs)</li><li>wwise.ui, wwise.debug, wwise.waapi</li><li>soundengine</li><li>wwise.core, wwise.debug, wwise.ui (subscription APIs)</li><li>Making Calls to WAAPI in the Game Engine</li><li>Examples</li></ol><h2 id="WAAPI-Basics"><a href="#WAAPI-Basics" class="headerlink" title="WAAPI Basics"></a>WAAPI Basics</h2><h3 id="4-1-What-is-WAAPI"><a href="#4-1-What-is-WAAPI" class="headerlink" title="4.1. What is WAAPI?"></a>4.1. What is WAAPI?</h3><p>WAAPI (Wwise Authoring API) is an essential module in Wwise. Through making calls to these APIs, you can tell Wwise to execute operations directly, without having to move the mouse or type with the keyboard.<br>These operations involve UIs (views, options, commands), core features (quickly adding audio files), sound engine (setting RTPC values, posting Events etc.). More information on WAAPI:<br><a href="https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi.html" target="_blank" rel="noopener">https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi.html</a></p><h3 id="4-2-Programming-Languages-and-Calling-Methods-Supported-by-WAAPI"><a href="#4-2-Programming-Languages-and-Calling-Methods-Supported-by-WAAPI" class="headerlink" title="4.2. Programming Languages and Calling Methods Supported by WAAPI"></a>4.2. Programming Languages and Calling Methods Supported by WAAPI</h3><h4 id="Programming-Languages"><a href="#Programming-Languages" class="headerlink" title="Programming Languages"></a>Programming Languages</h4><p>You can make WAAPI calls with a variety of languages such as C++, C#, JavaScript, Python etc. The last three are relatively easy for beginners. (Python 3.6+ is recommended.) If there is no need for making WAAPI calls within plug-ins, then you don’t have to use C++.</p><h4 id="Calling-Methods"><a href="#Calling-Methods" class="headerlink" title="Calling Methods"></a>Calling Methods</h4><p><strong>WAAPI provides three methods to make API calls: WAMP, HTTP POST and Wwise plug-ins.</strong><br>In most cases, we use WAMP. Because it’s the only one that support both execution and subscription APIs. <strong>So what is WAMP?</strong><br>It’s a method of communication via WebSocket. If you are unfamiliar with the principles of network communication, you can think of it as a method of transporting information over the network. To achieve this, you need an IP address and a port to connect to WAAPI.<br>You can execute the required operations only if your application is connected to Wwise via WAMP.<br>More information on how to make WAAPI calls:<br><a href="https://www.audiokinetic.com/library/edge/?source=SDK&amp;id=waapi_gettingstarted.html" target="_blank" rel="noopener">https://www.audiokinetic.com/library/edge/?source=SDK&amp;id=waapi_gettingstarted.html</a></p><h3 id="4-3-Configuring-the-Development-Environment"><a href="#4-3-Configuring-the-Development-Environment" class="headerlink" title="4.3. Configuring the Development Environment"></a>4.3. Configuring the Development Environment</h3><blockquote><p>Development environment is nothing new, so I’m not going to talk about it here. If you are interested, feel free to check the links below.</p></blockquote><p><strong>Since Conda doesn’t have the waapi-client package required by WAAPI, we have to install it manually. If you are not a fan of Anaconda, you can use pip instead.</strong><br>In case you are, it’s better to do it as described in the official document: first you install pip, then manage packages with pip within Anaconda. For more information, please check the links below.<br>(For advanced users only) You could use the conda skeleton pypi and conda build commands to install the package. But I never tried personally, so I will leave it to you.</p><h4 id="Installing-Anaconda"><a href="#Installing-Anaconda" class="headerlink" title="Installing Anaconda"></a>Installing Anaconda</h4><p><a href="https://docs.anaconda.com/anaconda/install/" target="_blank" rel="noopener">https://docs.anaconda.com/anaconda/install/</a></p><h4 id="Configuring-Anaconda-and-Adding-the-waapi-client-Package-With-pip"><a href="#Configuring-Anaconda-and-Adding-the-waapi-client-Package-With-pip" class="headerlink" title="Configuring Anaconda and Adding the waapi-client Package With pip"></a>Configuring Anaconda and Adding the waapi-client Package With pip</h4><p><a href="https://docs.anaconda.com/anaconda/user-guide/" target="_blank" rel="noopener">https://docs.anaconda.com/anaconda/user-guide/</a> <a href="https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-pkgs.html#installing-non-conda-packages" target="_blank" rel="noopener">https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-pkgs.html#installing-non-conda-packages</a><br><strong>Note: With pip installed, you can run pip install waapi-client directly in Python 3.</strong></p><h4 id="Configuring-the-VS-Code-Development-Environment"><a href="#Configuring-the-VS-Code-Development-Environment" class="headerlink" title="Configuring the VS Code Development Environment"></a>Configuring the VS Code Development Environment</h4><p><a href="https://code.visualstudio.com/docs/python/environments" target="_blank" rel="noopener">https://code.visualstudio.com/docs/python/environments</a></p><h4 id="Enabling-WAAPI-in-Wwise"><a href="#Enabling-WAAPI-in-Wwise" class="headerlink" title="Enabling WAAPI in Wwise"></a>Enabling WAAPI in Wwise</h4><p><a href="https://www.audiokinetic.com/library/edge/?source=SDK&amp;id=waapi_prepare.html" target="_blank" rel="noopener">https://www.audiokinetic.com/library/edge/?source=SDK&amp;id=waapi_prepare.html</a></p><h3 id="4-4-Differences-Between-Execution-and-Subscription-APIs"><a href="#4-4-Differences-Between-Execution-and-Subscription-APIs" class="headerlink" title="4.4. Differences Between Execution and Subscription APIs"></a>4.4. Differences Between Execution and Subscription APIs</h3><blockquote><p>Execution APIs execute certain operations, subscription APIs get the return result after that. They are referred to as “remote call” and “publish &amp; post” in the official Wwise documents.</p></blockquote><p><strong>Execution APIs：</strong><br>as their names suggest, all of these APIs are used to execute certain operations.<br>A specific operation will be executed after you make an API call. All those three methods are able to make execution API calls, although HTTP POST is not the best choice.<br><strong>Subscription APIs：</strong><br>When you make a subscription API call, your application will wait for Wwise to react. If you subscribed to an object creation action, you will get the return result only after that action is executed. Such calls are only possible with WAMP. They cannot be done via the other two methods.</p><h3 id="4-5-JSON-and-WAAPI-Documents"><a href="#4-5-JSON-and-WAAPI-Documents" class="headerlink" title="4.5. JSON and WAAPI Documents"></a>4.5. JSON and WAAPI Documents</h3><h4 id="What-is-JSON"><a href="#What-is-JSON" class="headerlink" title="What is JSON?"></a>What is JSON?</h4><p>People who’s not a professional programmer (like me) may wonder what JSON is when using WAAPI for the first time.<br><strong>JSON (JavaScript Object Notation) is a lightweight data-interchange format that uses human-readable text to store and transmit data objects.</strong> If you are familiar with XML, then you probably know something about JSON.<br>It’s important to know what JSON is. Because this format will be used for both input arguments and return values when making a remote call to WAAPI. <strong>Let’s find out the answer before we proceed.</strong> For further clarification, here is an example.</p><h4 id="Arguments-and-Result-Execution-APIs"><a href="#Arguments-and-Result-Execution-APIs" class="headerlink" title="Arguments and Result (Execution APIs)"></a>Arguments and Result (Execution APIs)</h4><p>Here is the <code>ak.wwise.core.object.create</code> doc in which there are two tables.<br><img src="/images/%E5%8F%82%E6%95%B01.png" alt="Arguments"></p><p><img src="/images/%E7%BB%93%E6%9E%9C1-1.png" alt="Result"></p><p>Both of them have three columns: Name, Type and Description.<br>You can use a function to pass in arguments and get the return result. <strong>In the Arguments table, these are the arguments that you want to pass in when making function calls. In the Result table, these are the result that you will get in return when it’s done.</strong><br>As mentioned previously, <strong>they are all in JSON format. Note that those with an asterisk (*) are mandatory arguments, the rest are optional ones.</strong><br>Let’s have a look at the Arguments table. There are three types of arguments:</p><ol><li><code>Name *</code> needs a single string as an argument to define the name. That means you only have to provide one name in string format for JSON to use. But why does <code>parent *</code> need four arguments? As you can see, the first one is <code>any of:</code>. That means you can choose any of the following three arguments to define the parent. They can be a name, a GUID or a path.</li><li>As for <code>notes</code>, it doesn’t have an asterisk. Because it’s not a mandatory argument. In other words, you can decide whether to pass in a note as needed when using <code>ak.wwise.core.object.create</code>.</li><li><code>children</code> is kind of puzzling. It’s different from the previous arguments. Actually, it’s an array in which you need to populate the argument that you want to pass in. <code>children[... ].type *</code> and <code>children[... ].name *</code> are mandatory arguments. So you have to populate the type and name sub-arguments.</li></ol><p>Now let’s take a look at the Result table. You can probably figure out what kinds of return result you would get as long as you know which arguments will be passed in. For instance, you created some objects using <code>ak.wwise.core.object.create</code>. Naturally, Wwise should return their names, GUIDs and paths accordingly. In the meantime, errors will be reported if it fails.</p><h4 id="How-to-Use-JSON"><a href="#How-to-Use-JSON" class="headerlink" title="How to Use JSON?"></a>How to Use JSON?</h4><p>In the previous section, we explained what the arguments are and what return result you could get. Now you may wonder how to populate these arguments to make sure that WAAPI can receive them properly.<br>Let’s take <code>ak.wwise.core.object.create</code> for example, and see how it works.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Arguments that are required to execute ak.wwise.core.object.create</span></span><br><span class="line">args = &#123;</span><br><span class="line">    <span class="string">"parent"</span>: parent_guid, </span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"Sound"</span>, </span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Simple_SFX"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Result that you will get after executing ak.wwise.core.object.create and passing in args</span></span><br><span class="line">result = &#123;</span><br><span class="line">    <span class="string">"id"</span>: object_guid, </span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Simple_SFX"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>As you can see from the example, <strong>JSON is actually something like a dictionary in Python</strong>. The difference is that all quotes in JSON must be double quotes, and JSON blocks should be in string format. <strong>However, under the Python + WAAPI environment, it seems that these two rules are not strictly verified</strong>. So you don’t have to use the <code>json</code> modules in Python to make a format conversion. It works even if you write in dictionary format.<br><img src="/images/%E5%AF%B9%E7%85%A7%E8%A1%A8.png" alt=""><br>By comparing Python and JSON, you can see the corresponding relationship in terms of data structure. These objects are essential when using WAAPI. You can get the required result only if the arguments are set up as described.</p><h4 id="How-to-Format-the-JSON-Syntax-for-Better-Readability"><a href="#How-to-Format-the-JSON-Syntax-for-Better-Readability" class="headerlink" title="How to Format the JSON Syntax for Better Readability?"></a>How to Format the JSON Syntax for Better Readability?</h4><p>WAAPI argument documents are defined using JSON, which lack of readability. <strong>In order to better understand these arguments when using WAAPI, we need to format the JSON syntax.</strong><br>Here is the argument syntax for <code>ak.wwise.core.object.create</code>:<br><img src="/images/%E5%8F%82%E6%95%B02.png" alt=""></p><p>It has a very poor readability. To improve this, we can use JSON formatting tools such as JSON Editor (&gt;<a href="https://jsoneditoronline.org/)" target="_blank" rel="noopener">https://jsoneditoronline.org/)</a>.<br>Remember how messy the format was? Now it’s much better!<br><img src="/images/JSON1.png" alt="JSON1"></p><p>With the argument syntax formatted, we can clearly see the required arguments in the required section, as well as type and description in the properties section. There are two more properties. <code>localDefinitions</code> is actually the definition for <code>children</code> mentioned previously. <code>patternProperties</code> is the potential value type when setting object properties via <code>@propertyName</code>.</p><p><img src="/images/JSON2.png" alt="JSON2"></p><p>The Result table works the same way. In the following image, we can clearly see the default return values: name, children and ID. With the JSON syntax formatted, it’s much more readable both for arguments and return values.<br><strong>When you want to call a WAAPI function, all you need is to modify the required arguments under the JSON framework, then make a remote call.</strong><br>To understand the corresponding relation between JSON and Python, you should refer to examples as your first step. It’s recommended that you check all examples listed in the Wwise Authoring API Examples Index. Since these examples are quite brief, I suggest you go through the descriptions here first.<br>Now let’s see how to use these arguments in a full context. Here is an example from the official document, describing how to create a Random Container with two Sound SFX objects included.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Arguments provided in the example code</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"># Parent GUID, type, name, property value</span></span><br><span class="line">    <span class="string">"parent"</span>: <span class="string">"&#123;7A12D08F-B0D9-4403-9EFA-2E6338C197C1&#125;"</span>, </span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"RandomSequenceContainer"</span>, </span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Boom"</span>, </span><br><span class="line">    <span class="string">"@RandomOrSequence"</span>: <span class="number">1</span>, </span><br><span class="line">    <span class="comment"># Children type and name</span></span><br><span class="line">    <span class="string">"children"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"Sound"</span>, </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"A"</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"Sound"</span>, </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"B"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Arguments in a real scenario</span></span><br><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> WaapiClient() <span class="keyword">as</span> client:</span><br><span class="line">        <span class="comment"># Assign the JSON-formatted arguments to args</span></span><br><span class="line">        args = &#123;</span><br><span class="line">            <span class="string">"parent"</span>: <span class="string">"&#123;7A12D08F-B0D9-4403-9EFA-2E6338C197C1&#125;"</span>, </span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"RandomSequenceContainer"</span>, </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"Boom"</span>, </span><br><span class="line">            <span class="string">"@RandomOrSequence"</span>: <span class="number">1</span>, </span><br><span class="line">            <span class="string">"children"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"Sound"</span>, </span><br><span class="line">                    <span class="string">"name"</span>: <span class="string">"A"</span></span><br><span class="line">                &#125;, </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"Sound"</span>, </span><br><span class="line">                    <span class="string">"name"</span>: <span class="string">"B"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># Execute a remote call. The first argument is the API name, the second is the JSON argument.</span></span><br><span class="line">        client.call(<span class="string">"ak.wwise.core.object.create"</span>, args)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">    print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 3. The return result after making a remote call, including parent GUID, parent container name, children GUID, children name.</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"&#123;66666666-7777-8888-9999-AAAAAAAAAAAA&#125;"</span>, </span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Boom"</span>, </span><br><span class="line">    <span class="string">"children"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"id"</span>: <span class="string">"&#123;46813545-2168-3547-8328-681AB678D6F5&#125;"</span>, </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"A"</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"id"</span>: <span class="string">"&#123;68465134-2548-2377-3541-321354318ABD&#125;"</span>, </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"B"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Options-and-Publish-Subscription-APIs"><a href="#Options-and-Publish-Subscription-APIs" class="headerlink" title="Options and Publish (Subscription APIs)"></a>Options and Publish (Subscription APIs)</h4><p>If you look carefully at the official documents, you will notice that the subscription API arguments are a bit different. <strong>There are two tables: Options and Publish, instead of Arguments and Result</strong>.<br>Subscription APIs are based on the callback functions executed when publishing topics. Arguments in the Options table define the type of return value in a callback function, avoiding unnecessary queries. Meanwhile, you can think of arguments in the Publish table as a different form of those in the Result table. It essentially returns the same information in JSON format, only that it’s published when the subscribed topics are modified.<br>Nevertheless, there are exceptions for the execution APIs, such as <code>ak.wwise.core.audio.importTabDelimited</code>, <code>ak.wwise.core.object.get</code>, <code>ak.wwise.core.profiler.getBusses</code>, <code>ak.wwise.core.profiler.getVoices</code>. They have both Arguments and Options tables listed. The former specifies the query scope (mandatory). The later indicates the query options (optional). They will be further described in Part 2.</p><h3 id="4-6-Hello-Wwise！"><a href="#4-6-Hello-Wwise！" class="headerlink" title="4.6. Hello Wwise！"></a>4.6. Hello Wwise！</h3><p>We’ve talked about the basics. Now let’s see how it works in a real scenario!<br><strong>Take “Hello Wwise!” for example.</strong></p><h4 id="Determining-Which-APIs-to-Use"><a href="#Determining-Which-APIs-to-Use" class="headerlink" title="Determining Which APIs to Use"></a>Determining Which APIs to Use</h4><p>Obviously, for a scenario like Hello World, we should use execution APIs.<br><code>ak.soundengine.postMsgMonitor</code> can do the job perfectly.</p><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>For better readability, I added thorough notes in the code. You can check each of them below.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"></span><br><span class="line"><span class="comment"># “try…except…” statement for handling Python exceptions. For instance, when the WAAPI connection fails.</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Use the default address to connect to Wwise. You can change the port as needed.</span></span><br><span class="line">    <span class="keyword">with</span> WaapiClient() <span class="keyword">as</span> client:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># All WAAPI arguments are in JSON format, no matter they are passed in or sent back. Use the dictionary to define the printout message (Hello Wwise!)</span></span><br><span class="line">        print_args = &#123;</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"Hello Wwise!"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># Make a remote call to ak.soundengine.postMsgMonitor, then pass in the arguments you just defined</span></span><br><span class="line">        client.call(<span class="string">"ak.soundengine.postMsgMonitor"</span>, print_args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">    print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br></pre></td></tr></table></figure></p><h4 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h4><p>Don’t forget to click Start Capture before you execute the script. Otherwise, the Profiler won’t start the capture process. In the end, we will get the following information:<br><img src="/images/%E7%BB%93%E6%9E%9C1.png" alt="In the WAAPI tab in Logs, we can see that a WAMP connection has been built."></p><p><img src="/images/%E7%BB%93%E6%9E%9C2.png" alt="In Profiler, we can see the printout message &quot;Hello Wwise!”."></p><h2 id="WAAPI-Use-Cases"><a href="#WAAPI-Use-Cases" class="headerlink" title="WAAPI Use Cases"></a>WAAPI Use Cases</h2><h3 id="5-1-Execution-APIs"><a href="#5-1-Execution-APIs" class="headerlink" title="5.1. Execution APIs"></a>5.1. Execution APIs</h3><h4 id="Without-Arguments"><a href="#Without-Arguments" class="headerlink" title="Without Arguments"></a>Without Arguments</h4><p>Getting information about the current project through the <code>getInfo</code> function.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> WaapiClient() <span class="keyword">as</span> client:</span><br><span class="line">        result = client.call(<span class="string">"ak.wwise.core.getInfo"</span>)</span><br><span class="line">        pprint(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">    print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br></pre></td></tr></table></figure></p><p>Result:<br><img src="/images/%E7%BB%93%E6%9E%9C3-1.png" alt="With Arguments"></p><h4 id="With-Arguments"><a href="#With-Arguments" class="headerlink" title="With Arguments"></a>With Arguments</h4><p>Refer to the “Hello Wwise!” section.</p><h3 id="5-2-Subscription-APIs"><a href="#5-2-Subscription-APIs" class="headerlink" title="5.2. Subscription APIs"></a>5.2. Subscription APIs</h3><p>Using <code>ak.wwise.core.object.nameChanged</code>, we can subscribe to the project information when the object name is changed, and return its new name, old name and type.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># “try…except…else…” statement for handling Python exceptions</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    client = WaapiClient()</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">    print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># Use on_name_changed() as the callback function to get the return result in dictionary format</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_name_changed</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># Get the object type</span></span><br><span class="line">        obj_type = kwargs.get(<span class="string">"object"</span>, &#123;&#125;).get(<span class="string">"type"</span>)</span><br><span class="line">        <span class="comment"># Get the old name</span></span><br><span class="line">        old_name = kwargs.get(<span class="string">"oldName"</span>)</span><br><span class="line">        <span class="comment"># Get the new name</span></span><br><span class="line">        new_name = kwargs.get(<span class="string">"newName"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Use the format function to print out the info, and tell user that an object of type XXX has been renamed from A to B</span></span><br><span class="line">        print(<span class="string">"Object '&#123;&#125;' (of type '&#123;&#125;') was renamed to '&#123;&#125;'\n"</span>.format(old_name, obj_type, new_name))</span><br><span class="line">        <span class="comment"># Terminate the WAMP connection as needed</span></span><br><span class="line">        client.disconnect()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Subscribe to required topics, and pass in the callback function. Choose type to return the object’s type when its name is changed</span></span><br><span class="line">    handler = client.subscribe(<span class="string">"ak.wwise.core.object.nameChanged"</span>, on_name_changed, &#123;<span class="string">"return"</span>: [<span class="string">"type"</span>]&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print out the info to remind user that a subscription to ak.wwise.core.object.nameChanged has been made. Make a suggestion that user should rename the object to verify the script</span></span><br><span class="line">    print(<span class="string">"Subscribed 'ak.wwise.core.object.nameChanged', rename an object in Wwise"</span>)</span><br></pre></td></tr></table></figure></p><p>Here is the return result. The project information is printed out as we expected.<br><img src="/images/%E7%BB%93%E6%9E%9C4.png" alt=""></p><h2 id="What’s-Next"><a href="#What’s-Next" class="headerlink" title="What’s Next?"></a>What’s Next?</h2><p>In Part 2, we will talk about wwise.core execution APIs. There are a lot of examples in the official documents. But to get started quickly, I will show you some actual use cases. Stay tuned if you are interested!</p>]]></content>
      
      
      
        <tags>
            
            <tag> 音频编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>极简搭建（三）空间音频试验场</title>
      <link href="/2020/10/30/%E6%9E%81%E7%AE%80%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/10/30/%E6%9E%81%E7%AE%80%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 极简搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>极简搭建（二）利用 WAAPI 搭建 CI 系统</title>
      <link href="/2020/10/25/%E6%9E%81%E7%AE%80%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/10/25/%E6%9E%81%E7%AE%80%E6%90%AD%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 极简搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>极简搭建（一）从零构建 Wwise + Unity 的手游热更系统</title>
      <link href="/2020/10/20/%E6%9E%81%E7%AE%80%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/10/20/%E6%9E%81%E7%AE%80%E6%90%AD%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>在新的系列文《极简搭建》中，我将会针对这两类问题进行讨论：一类是对于其它工种来说属于日常工作，但针对声音设计师有些难度的。另一类是通过例子理解起来更为有效的。<br><strong>当然，如果职位定位是技术音频，我认为这些问题的掌握是理所当然的。</strong><br>第一篇文章中需要讨论的就是如何实现手游热更，鉴于本人暂时对 FMOD 及虚幻不够熟悉，关于 Wwise + UE 及 FMOD + 两大引擎的热更搭建会在我学会之后再更。</p><blockquote><p>本系列文章阅读需要的前置知识：</p><ul><li>足够的 Unity 和 Wwise 基础。</li><li>了解基本的 Android 和 iOS 开发。</li><li>了解 C# 和 Lua。</li></ul></blockquote><p>本文目录：</p><p>[toc]</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="什么是热更新？"><a href="#什么是热更新？" class="headerlink" title="什么是热更新？"></a>什么是热更新？</h3><p>热更新（Hotfix）是典型的那种不懂之前很迷茫，懂之后很简单的概念。<br>在一开始先不要考虑那么多实现过程，<strong>热更新的本质就是一句话：绕过商店直接在 App 内更新代码或资源。</strong><br>游戏开始加载时如果存在校验服务器与本地资源版本的差异，那就是在执行热更检测。<br>与之对应的是大版本更新（注意这可不叫“冷更”），两者区别如下：</p><table><thead><tr><th></th><th>大版本号</th><th>资源版本号</th><th>包体变化</th></tr></thead><tbody><tr><td>大版本更新</td><td>改变</td><td>不变</td><td>由 A 变为 B</td></tr><tr><td>热更新</td><td>不变</td><td>改变</td><td>由 A 变为 A + A1 + A2 etc.</td></tr></tbody></table><p>热更新有很多坑，比如代码热更新和资源热更新就有不同，前者会涉及到代码是否在更新前解析执行等，还需要考虑是否能通过商店审核之类的问题。我无心探讨热更新技术的好坏（xLua，slua，tolua，ILRuntime，jsb等），毕竟也不是干这个的。<br>但对于资源和代码如何正确的实现现有技术框架下的热更新，这是必掌握的能力。</p><h3 id="作为声音设计师我学它干嘛？"><a href="#作为声音设计师我学它干嘛？" class="headerlink" title="作为声音设计师我学它干嘛？"></a>作为声音设计师我学它干嘛？</h3><p>不妨声音设计师们设身处地的为引擎程序员想想。对于程序员而言，热更属于已经搭好的一个系统。<strong>无论性能如何，只要不想被开除，这个热更系统至少是能保证可用的。</strong><br>而 Wwise 作为音频中间件，是在 Unity 中通过一些修改来实现替换掉本身的音频系统来实现功能的。<br><strong>问题来了，引擎程序员怎么知道在热更时哪些文件需要以哪种方法处理，从而能满足 Wwise 正常获取新资源的需求呢？</strong>毕竟游戏资源更新了，新内容的音频资源必须跟上。<br>为了满足这些，就需要按照本文所说的方法理解 Wwise 热更新的实现方法。这样声音设计师可以更好的理解程序员的工作流程以提供正确的新包，对技术音频设计师而言这也是个必备的知识点。<br>相信所有游戏宏观的热更新方案不会轮到音频部门来做决定，音频人员更重要的是利用好当前项目决定的热更技术方案以保证 Wwise 的稳定运行。</p><h2 id="搭建一个基本的-Unity-工程"><a href="#搭建一个基本的-Unity-工程" class="headerlink" title="搭建一个基本的 Unity 工程"></a>搭建一个基本的 Unity 工程</h2><p>在接着讲之前，我们先搭建一个最基本的 Unity 工程。</p><h3 id="新建工程并接入-Wwise"><a href="#新建工程并接入-Wwise" class="headerlink" title="新建工程并接入 Wwise"></a>新建工程并接入 Wwise</h3><h3 id="创建所需场景"><a href="#创建所需场景" class="headerlink" title="创建所需场景"></a>创建所需场景</h3><h2 id="配置热更所需信息"><a href="#配置热更所需信息" class="headerlink" title="配置热更所需信息"></a>配置热更所需信息</h2><h3 id="修改-Wwise-DLC-路径"><a href="#修改-Wwise-DLC-路径" class="headerlink" title="修改 Wwise DLC 路径"></a>修改 Wwise DLC 路径</h3><h3 id="修改热更代码"><a href="#修改热更代码" class="headerlink" title="修改热更代码"></a>修改热更代码</h3><h2 id="生成-Android-端并测试热更效果"><a href="#生成-Android-端并测试热更效果" class="headerlink" title="生成 Android 端并测试热更效果"></a>生成 Android 端并测试热更效果</h2><h3 id="生成-Android-客户端"><a href="#生成-Android-客户端" class="headerlink" title="生成 Android 客户端"></a>生成 Android 客户端</h3><h3 id="搭建热更服务器"><a href="#搭建热更服务器" class="headerlink" title="搭建热更服务器"></a>搭建热更服务器</h3><h3 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h3><h2 id="生成-iOS-端并测试热更效果"><a href="#生成-iOS-端并测试热更效果" class="headerlink" title="生成 iOS 端并测试热更效果"></a>生成 iOS 端并测试热更效果</h2><h3 id="生成-iOS-服务器"><a href="#生成-iOS-服务器" class="headerlink" title="生成 iOS 服务器"></a>生成 iOS 服务器</h3><h3 id="搭建热更服务器-1"><a href="#搭建热更服务器-1" class="headerlink" title="搭建热更服务器"></a>搭建热更服务器</h3><h3 id="测试效果-1"><a href="#测试效果-1" class="headerlink" title="测试效果"></a>测试效果</h3><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2><p>在第二篇中我们会聊聊如何借用 WAAPI 的订阅功能实现 CI 系统，作为自动化搭建和测试的系统，CI 系统在实际工作中具有极大的重要性。<br>那么会搭建 CI 系统对声音设计师或技术音频有什么用呢？其实就是方便测试与构建自动化流程，这对技术有追求的人来说怎么可能不学。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 极简搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>人人都能用 WAAPI（四）Beyond WAAPI</title>
      <link href="/2020/10/05/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2020/10/05/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>我给这系列文章命名为《人人都能用 WAAPI》，想了很久，该如何为这系列文章收尾。突然 <strong>Beyond WAAPI</strong> 跳入我的脑海中，在最后这篇文章中，我会分享一下我对 WAAPI 工作流的反思以阐述 Beyond WAAPI 的含义。<br>本文中共包含两个项目：</p><ul><li>项目一是我的个人项目 <strong>WAAPI Code Generator</strong>，这个项目的功能对应本系列文章的主题《人人都能用 WAAPI》。我为大家开发了一个编写 WAAPI 代码的“元工具”，<strong>提供一种更优雅的使用方式从而进一步降低了 WAAPI 的使用门槛。</strong></li><li>项目二是我与腾旭光子工作室的技术音频设计师李 AA 共同开发的 <strong>WAAPI Database</strong>，这个项目是为了展示 WAAPI 在实际项目中的应用。通过合理设计，实现抓取 Wwise 内信息并使用数据库进行管理。</li></ul><p>为了让初学者更好理解，除了对项目的整个架构进行分析，我会尽量对其中涉及到 WAAPI 的代码进行注释，以方便大家参考。<br><strong>作为对文档中薄弱知识的补充，本文后还会附上在游戏引擎中如何调用 WAAPI 的讲解。</strong></p><p>本文目录：</p><p>[toc]</p><h2 id="WAAPI-的“元工具”：WAAPI-Code-Generator"><a href="#WAAPI-的“元工具”：WAAPI-Code-Generator" class="headerlink" title="WAAPI 的“元工具”：WAAPI Code Generator"></a>WAAPI 的“元工具”：WAAPI Code Generator</h2><h3 id="1-1-对现有工作流的思考"><a href="#1-1-对现有工作流的思考" class="headerlink" title="1.1. 对现有工作流的思考"></a>1.1. 对现有工作流的思考</h3><p><strong>在开发工具时使用 WAAPI 很容易遇到这样的痛点：</strong></p><ol><li>面对 <code>ak.wwise.core.object.get</code> 或 <code>ak.wwise.core.object.create</code> 这种选项繁杂的 API，手写 JSON 格式的配置代码块着实体验不佳，一不小心写错了符号还需修改。</li><li>无论是否遵循本文曾提到的分类逻辑，在文档中搜寻想要的 API 时都得在那些长长的 API 名中费劲挖掘一番。</li></ol><p>本着提高技术音频设计师效率的逻辑，我在思考能否进行一类<strong>元工具</strong>的开发。就像对待重复代码块写作时会用到 Code Snippets 一样，尽量减少重复工作带来的时间浪费。<br>这也是 WAAPI Code Generator 诞生的动机，我的初衷就是希望把 WAAPI 的使用变的更加简单且工具化。</p><h3 id="1-2-设计原理"><a href="#1-2-设计原理" class="headerlink" title="1.2. 设计原理"></a>1.2. 设计原理</h3><p>我们以 <code>ak.wwise.core.object.get</code> 为例，在 Python 中调用这个 API 需要：</p><ol><li>根据文档选定需要使用的参数，<code>form</code> 决定从何处获取，<code>transform</code> 决定变换条件，此外还有可选参数 Options 决定返回值和平台。</li><li>为 <code>form</code> 手动获取 GUID 或路径，其他的参数要按需从文档中获取正确的参数。</li><li>书写 JSON 配置的语法结构，把对应的参数放到正确的地方。</li><li>测试代码。（如果 JSON 格式不小心写错，Debug 时间到！）</li></ol><p><strong>而在 WAAPI Code Generator 中你只需要：</strong></p><ol><li>在左边第一栏中间选择需要的 WAAPI class，选中 <code>ak.wwise.core</code> 即可轻松在下面找到 <code>ak.wwise.core.object.get</code>。</li><li>在程序中间第二栏的下拉列表里选择所需的参数。<strong>此时右边会有官方文档及我所书写的文档注释</strong>。如果需要使用 GUID 或工程路径等信息作为参数，直接在左边下方的工程浏览器里可清晰看到当前工程的完整目录架构，随时获取所需信息并添加到配置参数中。</li><li>选中所需的语言，即会按照该语言所需的参数格式生成代码。点击 Generate，代码默认会自动复制到剪贴板，随后粘贴至你的代码编辑器内即可。</li></ol><p>容易看出，我优化掉了 WAAPI 中繁琐的步骤，例如反复的翻阅文档、精心书写 JSON 格式、去 Wwise 内拷贝 GUID 等。</p><h3 id="1-3-使用方法"><a href="#1-3-使用方法" class="headerlink" title="1.3. 使用方法"></a>1.3. 使用方法</h3><p>todo：添加图片、详细介绍<br>GitHub 地址：<a href="https://github.com/zcyh147/WAAPI-Code-Generator" target="_blank" rel="noopener">https://github.com/zcyh147/WAAPI-Code-Generator</a></p><ol><li>打开 GitHub 仓库，在 releases 中下载对应系统的最新版，解压到你喜欢的目录中</li><li>根据 Wwise 内的 WAAPI 设置，填入服务器和端口号来连接 WAAPI 服务器。默认情况下不需修改，直接点击 Connect 按钮即可。</li><li>本程序遵循 <em>Don’t Make Me Think</em> 原则，采用“左中右”三分栏的设计，用户从左到右进行顺序操作即可，非常简单。</li></ol><h2 id="WAAPI-数据抓取器：WAAPI-Database"><a href="#WAAPI-数据抓取器：WAAPI-Database" class="headerlink" title="WAAPI 数据抓取器：WAAPI Database"></a>WAAPI 数据抓取器：WAAPI Database</h2><h3 id="2-1-功能简述"><a href="#2-1-功能简述" class="headerlink" title="2.1. 功能简述"></a>2.1. 功能简述</h3><p><strong>从项目名 WAAPI Database 中不难看出，程序的主要目的是对 Wwise 中各种信息进行抓取</strong>，其核心功能通过 <code>ak.wwise.core.object.get</code> 来实现。<br>抓取后的数据会使用 SQLite 保存在本地数据库之中，这是一款轻量且免配置的数据库工具。如果读者不熟悉数据库也没关系，可把数据库当做是一种结构更复杂但更易于管理的电子表格结构，暂不予深究。<br>WAAPI Database 的运行方式是借助 Wwise 在 SoundBank 生成时执行的 PostXXXX 行为，通过这个功能在生成 SoundBank 后执行一个 Command Line Tools 文件，从而触发 WAAPI Database 中的功能代码。<br><strong>在我的 GUI 版工具中，还有手动抓取的功能</strong>，即无需等 SoundBank 生成也可直接抓取当前工程的数据，作为 WAAPI Database 的功能补充。<br><strong>GitHub 地址：<a href="https://github.com/jazzlost/WaapiDatabase" target="_blank" rel="noopener">https://github.com/jazzlost/WaapiDatabase</a></strong></p><h3 id="2-2-代码架构分析"><a href="#2-2-代码架构分析" class="headerlink" title="2.2. 代码架构分析"></a>2.2. 代码架构分析</h3><p>下面通过思维导图把项目中涉及到的所有文件列出其逻辑关系，以直白的展示程序的架构。<br><strong>以下代码解析基于 WAAPI Database V0.3，WAAPI 版本2019.2。</strong></p><h3 id="2-3-WAAPI-代码模块拆解"><a href="#2-3-WAAPI-代码模块拆解" class="headerlink" title="2.3. WAAPI 代码模块拆解"></a>2.3. WAAPI 代码模块拆解</h3><p>代码文件中关于 <code>wd_sqlite_interface.py</code> 和 <code>wd_sqlite_utils.py</code> 的部分为 SQLite 相关的内容，在此不做讲解。</p><h4 id="wd-client-py"><a href="#wd-client-py" class="headerlink" title="wd_client.py"></a>wd_client.py</h4><h4 id="wd-config-py"><a href="#wd-config-py" class="headerlink" title="wd_config.py"></a>wd_config.py</h4><h4 id="wd-parser-py"><a href="#wd-parser-py" class="headerlink" title="wd_parser.py"></a>wd_parser.py</h4><h4 id="wd-processor-py"><a href="#wd-processor-py" class="headerlink" title="wd_processor.py"></a>wd_processor.py</h4><h4 id="wd-args-py"><a href="#wd-args-py" class="headerlink" title="wd_args.py"></a>wd_args.py</h4><h4 id="waapi-config-json"><a href="#waapi-config-json" class="headerlink" title="waapi_config.json"></a>waapi_config.json</h4><h4 id="waapi-database-wcmdline"><a href="#waapi-database-wcmdline" class="headerlink" title="waapi_database.wcmdline"></a>waapi_database.wcmdline</h4><h4 id="wd-gui-py"><a href="#wd-gui-py" class="headerlink" title="wd_gui.py"></a>wd_gui.py</h4><h3 id="2-4-UI-设计"><a href="#2-4-UI-设计" class="headerlink" title="2.4. UI 设计"></a>2.4. UI 设计</h3><h4 id="原型设计"><a href="#原型设计" class="headerlink" title="原型设计"></a>原型设计</h4><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h3 id="工作效果"><a href="#工作效果" class="headerlink" title="工作效果"></a>工作效果</h3><h2 id="在游戏引擎中调用-WAAPI"><a href="#在游戏引擎中调用-WAAPI" class="headerlink" title="在游戏引擎中调用 WAAPI"></a>在游戏引擎中调用 WAAPI</h2><h3 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h3><h3 id="Unreal"><a href="#Unreal" class="headerlink" title="Unreal"></a>Unreal</h3><h3 id="Godot"><a href="#Godot" class="headerlink" title="Godot"></a>Godot</h3><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><strong>感谢在我人生中压力最大的时光中给予我鼓励和帮助的朋友们和家人，以及我挚爱的所有音乐家的作品们，没有你们，我是无法完成这篇体量庞大的文章的。</strong><br>之后如果我和朋友们还有优质的 WAAPI 开源项目，仍然会汇总后以文章的形式发布。<br>与此同时，<strong>建议大家看看现有的 WAAPI 项目实际应用</strong>，如：</p><ol><li>Wwise Authoring API（WAAPI）的三个开源工程：<a href="https://blog.audiokinetic.com/waapi-three-open-source-projects-for-wwise-authoring-api/" target="_blank" rel="noopener">https://blog.audiokinetic.com/waapi-three-open-source-projects-for-wwise-authoring-api/</a> </li><li>连通 Wwise 和 REAPER – 第 1 部分：WAAPI Transfer：<a href="https://blog.audiokinetic.com/connecting-wwise-and-reaper-part-1-waapi-transfer/" target="_blank" rel="noopener">https://blog.audiokinetic.com/connecting-wwise-and-reaper-part-1-waapi-transfer/</a></li><li>WAAPI AK-thon：<a href="https://blog.audiokinetic.com/ak-thon-waapi/" target="_blank" rel="noopener">https://blog.audiokinetic.com/ak-thon-waapi/</a></li><li>WAAPI Formula：<a href="https://github.com/jazzlost/Waapi_Formula" target="_blank" rel="noopener">https://github.com/jazzlost/Waapi_Formula</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 音频编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写给声音设计师的敏捷 GUI 开发大法（三）实例：WAAPI Code Generator 与 WAAPI Database</title>
      <link href="/2020/09/30/PySimpleGUI%20%20%E7%AC%AC%E4%B8%89%E7%AF%87/"/>
      <url>/2020/09/30/PySimpleGUI%20%20%E7%AC%AC%E4%B8%89%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>在本系列教程的第三篇中，会详解两个实际项目中的 UI 设计。<br><strong>其一是我的个人项目 WAAPI Code Generator，其二是我和光子工作室的技术音频李AA老师合作的项目 WAAPI Database。</strong><br>作为两个实用级的 WAAPI 项目，虽然不算什么复杂的设计，但可以通过对它们让大家了解 PySimpleGUI 在实际开发中是怎么应用的。<strong>出于我一贯的讲解习惯，本文会尽量对除 Python 基础逻辑之外的每一行代码都进行注释，希望通过这样解答大家所有可能存在的疑惑。</strong></p><p><em>本文目录：</em></p><p>[toc]</p><h2 id="WAAPI-Code-Generator-概述"><a href="#WAAPI-Code-Generator-概述" class="headerlink" title="WAAPI Code Generator 概述"></a>WAAPI Code Generator 概述</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1. 概述"></a>1.1. 概述</h3><h3 id="1-2-技术栈"><a href="#1-2-技术栈" class="headerlink" title="1.2. 技术栈"></a>1.2. 技术栈</h3><h3 id="1-3-GUI-原型设计"><a href="#1-3-GUI-原型设计" class="headerlink" title="1.3. GUI 原型设计"></a>1.3. GUI 原型设计</h3><p>在设计最复杂的第二栏时，我进行了以下思考：<br><code>ak.wwise.core.object.get</code> 最多需要四个参数，form 可用左下角框解决，transform、options 两项都直接选，是固定的。<br><code>ak.wwise.core.object.create</code> 则具有八个的参数（三个为必须参数），parent 可通过左下角选择，其余的参数里如 platform 是固定的，notes 是自己写的。<br>综上所述，第二栏布局中需要下拉框、文本框协同作战，最好是可下拉且可编辑的树状结构！</p><h2 id="WAAPI-Database-概述"><a href="#WAAPI-Database-概述" class="headerlink" title="WAAPI Database 概述"></a>WAAPI Database 概述</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1. 概述"></a>2.1. 概述</h3><p>WAAPI Database 的主要功能是在 Wwise 生成 SoundBank 后抓取工程中的信息并存入数据库中，数据库中的内容可供分析之用。</p><h3 id="2-2-技术栈"><a href="#2-2-技术栈" class="headerlink" title="2.2. 技术栈"></a>2.2. 技术栈</h3><p><strong>WAAPI Database 全部代码均通过 Python 完成，使用了三个库：</strong></p><ol><li>负责数据库的 SQLite</li><li>负责 GUI 实现的 PySimpleGUI </li><li>负责调用 WAAPI 的 waapi-client</li></ol><p>WAAPI Database 还有一个在 UE4 内运行版本，此版本暂时不考虑开源。<br><strong>本文将会着重讲解我在这个程序中 GUI 设计的部分，</strong>故有关 WAAPI 和 SQLite 使用的代码不会讲解。如果大家对 WAAPI 部分的实现有兴趣，可以在《人人都能用 WAAPI》系列文中等待实例讲解的篇章，WAAPI Database 会作为一个完整的 WAAPI 实例进行讲解。</p><h3 id="2-3-GUI-原型设计"><a href="#2-3-GUI-原型设计" class="headerlink" title="2.3. GUI 原型设计"></a>2.3. GUI 原型设计</h3><h3 id="2-4-GUI-代码实现"><a href="#2-4-GUI-代码实现" class="headerlink" title="2.4. GUI 代码实现"></a>2.4. GUI 代码实现</h3><h3 id="3-1-布局构建"><a href="#3-1-布局构建" class="headerlink" title="3.1. 布局构建"></a>3.1. 布局构建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-程序连接"><a href="#3-2-程序连接" class="headerlink" title="3.2. 程序连接"></a>3.2. 程序连接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-执行效果"><a href="#3-3-执行效果" class="headerlink" title="3.3. 执行效果"></a>3.3. 执行效果</h3><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 音频编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>技术音频的 Unity Editor 脚本开发指北（一）</title>
      <link href="/2020/09/30/Unity%20Editor%20%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/09/30/Unity%20Editor%20%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br><strong>技术音频设计师的工作到底有哪些？</strong>除了参考技术美术的职责，在游戏音频中解决具备技术与设计特点的工作外。还有一条最基本的工作责任，那就是从各种可能上改善音频管线的效率。<br>而 Unity Editor Scripting 正是个必备的研究方向，与引擎程序员的开发方向不同，我们不会在 Unity Editor 中创建关卡快速构建器这样的工具。作为技术音频设计师，改善并创建 Unity 与音频中间件集成时的相关工具才是本文的探讨方向。</p><blockquote><p>本系列文章阅读需要的前置知识：</p><ul><li>有一定的 Unity、Wwise、C# 基础，了解引擎使用、 Wwise 整合和 C# 基本语法等必备知识。</li><li>对 WAAPI 比较熟悉，了解在 C# 下的 WAAPI 调用。</li></ul></blockquote><p>本文目录：</p><p>[toc]</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="什么是-Editor-Scripting？"><a href="#什么是-Editor-Scripting？" class="headerlink" title="什么是 Editor Scripting？"></a>什么是 Editor Scripting？</h3><h3 id="为什么要用？"><a href="#为什么要用？" class="headerlink" title="为什么要用？"></a>为什么要用？</h3><h2 id="简单的-WAAPI-调用例子"><a href="#简单的-WAAPI-调用例子" class="headerlink" title="简单的 WAAPI 调用例子"></a>简单的 WAAPI 调用例子</h2><h3 id="创建-Hello-Wwise"><a href="#创建-Hello-Wwise" class="headerlink" title="创建 Hello Wwise"></a>创建 Hello Wwise</h3><h3 id="远程控制-Wwise-中的播放"><a href="#远程控制-Wwise-中的播放" class="headerlink" title="远程控制 Wwise 中的播放"></a>远程控制 Wwise 中的播放</h3><h2 id="关于效率优化的思考"><a href="#关于效率优化的思考" class="headerlink" title="关于效率优化的思考"></a>关于效率优化的思考</h2><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>补完 Reaper 效率链的最后一环（三）Command Line 详解</title>
      <link href="/2020/09/28/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20ReaScript%20%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%94%B9%E5%96%84%20Reaper%20%E6%95%88%E7%8E%87%EF%BC%9F%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/09/28/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20ReaScript%20%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%94%B9%E5%96%84%20Reaper%20%E6%95%88%E7%8E%87%EF%BC%9F%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>在《补完 Reaper 效率链的最后一环》专栏的第三篇中暂时先把 ReaScript 放到一边，分享一些其他的内容。<br>上篇文章的开头处曾谈到包括 Reaper、Wwise 和 LMB 都对 Command Line（命令行）有着使用支持。然而对于这部分功能的使用方法，<strong>少见的在 Reaper 帮助文档内居然一句未提</strong>，Cockos 论坛上也只有少数帖子有过相关讨论。<br><strong>作为冷门技巧爱好者，出于对 Reaper 文档欠缺部分的补充，我认为有必要详细聊一聊 Reaper 的 Command Line 用法及其扩展思路。</strong><br>注：本文使用的 Reaper 版本均基于 V6.14</p><blockquote><p>本系列文章阅读需要的前置知识：</p><ul><li>有 Python 基础。</li><li>对 macOS 终端、Windows 命令行等略有了解。</li><li>了解 Reaper 批处理的使用方法。</li></ul></blockquote><p>本文目录：</p><p>[toc]</p><h2 id="概念与配置方法"><a href="#概念与配置方法" class="headerlink" title="概念与配置方法"></a>概念与配置方法</h2><h3 id="为什么要用-Command-Line（命令行）？"><a href="#为什么要用-Command-Line（命令行）？" class="headerlink" title="为什么要用 Command Line（命令行）？"></a>为什么要用 Command Line（命令行）？</h3><p>为什么有好好的图形界面不用，非得要通过命令行来使用 Reaper？<br><strong>原因很简单：图形界面虽然对用户更友好，但命令行调用可提供更稳定、准确、快速的操作执行结果。</strong><br>这也是 Reaper 的伟大之处，一个完整的 DAW 愿意放下身段提供这样的底层使用方式。通过把一部分功能提取出来，可做到同时实现命令行的精准操作与 DAW 级别的后期处理。<br>要知道，FFMpeg 的功能是有限的。想通过它调用一串效果器来进行音频处理难以完成，此时 Reaper 的命令行用法就成了一个大杀器。<br>举个例子，通过简单的封装，可以把 Reaper 的效果器链批处理功能封装到音频管线中（就像暴雪在 TED 引擎里的用法），此时用户无需再面对 DAW 就能调用相关功能。</p><h3 id="查看参数文档的方法"><a href="#查看参数文档的方法" class="headerlink" title="查看参数文档的方法"></a>查看参数文档的方法</h3><p><strong>对于 Windows 和 macOS 来说，查看命令行使用帮助的方法相同。</strong>Linux 版暂不在本文的讨论范围之内，不过使用方法亦无太大差别。<br>可分别在命令行和终端中输入以下命令（需自行修改为自己的 Reaper 安装目录）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Windows: X:\YYY\ZZZ\reaper.exe -h</span><br><span class="line">Mac: /Applications/REAPER64.app/Contents/MacOS/REAPER -h</span><br></pre></td></tr></table></figure></p><p>执行之后可看到以下提示：<br><img src="/images/Reaper%20Windows-1.png" alt="Reaper Windows"><br>Windows<br><img src="/images/Reaper%20macOS-1.png" alt="Reaper macOS"><br>macOS<br>不难看出，命令行的用法为：<code>reaper（Reaper 安装路径） [options] [filename.rpp] [filename.wav]</code>，在 Windows 下横线“-”也可写为“/”。<br><strong>对比两者文档的区别，</strong>会发现 macOS 比 Windows 缺少 <code>-newinst</code>、<code>-nonewinst</code>、<code>-close</code> 这三个选项，且 Windows 具有一个独享的选项 <code>-noactive</code>，在之后的部分我们会聊一聊它们的用法。</p><h3 id="添加-Reaper-到环境变量"><a href="#添加-Reaper-到环境变量" class="headerlink" title="添加 Reaper 到环境变量"></a>添加 Reaper 到环境变量</h3><p><strong>每次都要先输一长串 Reaper 的安装路径再加指令，无疑是比较麻烦的。</strong><br>为此，可以把 Reaper 的安装目录添加到环境变量，之后即可直接在命令行中无需目录直接调用 Reaper。关于环境变量的配置方法在此不多加赘述，如有疑问可自行通过搜索引擎查找配置方法。<br>下面分别是 Windows 和 macOS 下配置截图及执行结果图：<br><img src="/images/Windows%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="Windows 环境变量"><br>Windows 环境变量设置<br><img src="/images/Windows%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%B5%8B%E8%AF%95.png" alt="Windows 环境变量测试"><br>在命令行中直接执行 <code>reaper -h</code> 可看到与之前相同的结果<br><img src="/images/macOS%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="macOS 环境变量"><br>macOS 环境变量设置<br><img src="/images/macOS%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%B5%8B%E8%AF%95-1.png" alt="macOS 环境变量测试"><br>在终端中直接执行 <code>reaper -h</code> 后也可看到相同的结果</p><h3 id="功能详解"><a href="#功能详解" class="headerlink" title="功能详解"></a>功能详解</h3><p>在开始实例之前，我们详细分析一下 Reaper 命令行工具所提供的功能。<strong>鉴于 Windows 版的功能更多，这部分的介绍以 Windows 版文档为准。</strong><br>在这里我把功能分为三大块。<br><strong>第一部分为单一的选项：</strong><br><code>-audiocfg</code>：在启动时打开 Preferences 中的 Audio Device 设置窗口<br><code>-cfgfile file.ini</code>：如果使用其他的资源文件夹需要完整路径，否则会使用默认路径<br><code>-new</code>：以新的工程启动<br><code>-template filename.rpp</code>：使用指定的模板工程开启 Reaper<br><code>-saveas newfilename.rpp</code>：当创建或加载完工程后，另存为指定名称的工程<br><code>-renderproject filename.rpp</code>：使用工程内保存的渲染设置来渲染指定工程<br><code>-ignoreerrors</code>：在加载时不会出现报错窗口<br><code>-nosplash</code>：静默加载，不显示开始画面<br><code>-splashlog /path/to/filename.log</code>：把开始画面中的信息写入到指定路径下的 Log 文件里<br><code>-newinst | -nonewinst</code>：是否创建新的 Reaper 实例（打开新的窗口而不是标签页），会忽略设置中对于新实例的检测设置<br><code>-close[all][:save|:nosave]</code>：关闭工程，可通过选项设置保存与否（无效）<br><strong>第二部分为批量转换文本文件中的语法格式：</strong><br><code>-batchconvert filelist.txt</code>：<br>在执行批处理时需使用一个 txt 文件来定义所有的配置。为了方便展示配置文本的内容，我使用代码块来展示配置文件的书写语法（为了写注释，这里使用 Python 格式渲染代码块），并且其中写入了可被使用的参数格式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每行一个文件名（实际使用中需要额外添加路径）</span></span><br><span class="line">filename.wav</span><br><span class="line"><span class="comment"># 也可以每行一个文件名+制表符+输出文件名</span></span><br><span class="line">filename.wav(制表符分割)outputfile.wav</span><br><span class="line"><span class="comment"># 配置代码模块（可选）</span></span><br><span class="line">&lt;CONFIG</span><br><span class="line">  SRATE <span class="number">44100</span> <span class="comment"># 采样率</span></span><br><span class="line">  NCH <span class="number">2</span> <span class="comment"># 全局输出的通道数</span></span><br><span class="line">  RSMODE <span class="number">7</span> <span class="comment"># 重采样模式，0到9之间，需要在</span></span><br><span class="line">  DITHER <span class="number">3</span> <span class="comment"># 抖动处理模式，1为添加抖动，2为噪音塑形，3为两者协作</span></span><br><span class="line">  USESRCSTART <span class="number">1</span> <span class="comment"># 把 BWF 内的开始偏置信息应用到输出文件中</span></span><br><span class="line">  PAD_START <span class="number">1.0</span> <span class="comment"># 在开头增加静音段落，以秒为单位</span></span><br><span class="line">  PAD_END <span class="number">1.0</span> <span class="comment"># 在结尾增加静音段落，以秒为单位</span></span><br><span class="line">  OUTPATH <span class="string">'C:\output'</span> <span class="comment"># 设置批处理文件的输出目录</span></span><br><span class="line">  OUTPATTERN <span class="string">'$filenumber_$track'</span> <span class="comment"># 使用通配符定义输出文件名，如不设置则使用原文件名</span></span><br><span class="line">  FXCHAIN <span class="string">'chain1.RfxChain'</span> <span class="comment"># 使用效果器链</span></span><br><span class="line">  &lt;FXCHAIN <span class="comment"># 效果器链子模块，可把效果器链文件内的内容复制在这里，可避免每次都寻找效果器链文件的麻烦</span></span><br><span class="line">    WAK <span class="number">0</span> <span class="number">0</span></span><br><span class="line">    BYPASS <span class="number">0</span> <span class="number">0</span></span><br><span class="line">    &lt;VST <span class="string">"VST3: PAZ- Analyzer Stereo (Waves)"</span> <span class="string">"WaveShell1-VST3 11.0.vst3"</span> <span class="number">0</span> <span class="string">""</span> <span class="number">1462399732</span>&#123;<span class="number">5653545741455370617</span>A2D20616E616C&#125; <span class="string">""</span></span><br><span class="line">    XXXXXXX <span class="comment"># 此处省略效果器链文件内容，太长了</span></span><br><span class="line">  &gt;</span><br><span class="line">  &lt;OUTFMT <span class="comment"># 输出格式子模块，为 base64 格式的数据。可先保存好输出格式设置，之后用文本编辑器打开 .rpp 文件后在 RENDER_CFG 中找到对应的数据</span></span><br><span class="line">    bDNwbVAAAAAAAAAABQAAAP////<span class="number">8</span>EAAAAUAAAAAAAAAA=</span><br><span class="line">  &gt;</span><br><span class="line">  &lt;METADATA <span class="comment"># 元数据子模块，查找方法同上，在工程文件中搜索 RENDER_METADATA 中可找到对应的数据</span></span><br><span class="line">    (contents of &lt;RENDER_METADATA block <span class="keyword">from</span> project file)</span><br><span class="line">  &gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p><strong>第三部分为 Windows 独有的选项：</strong><br><code>-noactivate</code>：打开 Reaper 后并不前置窗口（无效）</p><h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><p>下面通过一些实例，体验一下命令行工具的应用。</p><h3 id="按需创建新的工程"><a href="#按需创建新的工程" class="headerlink" title="按需创建新的工程"></a>按需创建新的工程</h3><p>通过预先创建好的模板文件创建工程：<br><code>reaper -template C:\Users\xiye\AppData\Roaming\REAPER\ProjectTemplates\templates1.rpp</code><br><img src="/images/%E7%BB%93%E6%9E%9C1-2.png" alt="结果1"></p><p>通过预先创建好的模板文件创建工程并另存为 newfilename.rpp（默认另存为的位置为用户名文件夹下）：<br><code>reaper -template C:\Users\xiye\AppData\Roaming\REAPER\ProjectTemplates\templates1.rpp -saveas newfilename.rpp</code><br><img src="/images/%E7%BB%93%E6%9E%9C2-1.png" alt="结果2"></p><p>渲染刚创建的工程（轨道里已放入音频文件），默认生成的文件会与 Project - Render 设置里的路径相同，如果没指定文件名将会生成一个无名的 wave 文件：<br><code>reaper -renderproject C:\Users\xiye\newfilename.rpp</code><br><img src="/images/%E7%BB%93%E6%9E%9C3-2.png" alt="结果3"></p><h3 id="对文件进行效果链批处理"><a href="#对文件进行效果链批处理" class="headerlink" title="对文件进行效果链批处理"></a>对文件进行效果链批处理</h3><p>Reaper 的效果器链是个很棒的功能，<strong>不仅储存了效果器的名称、顺序，还储存了效果器当前所有的参数。</strong>在二次调用的时候非常方便，只需简单加载即可轻松复现之前的配置。<br>这个例子中，我们演示一下如何对一些 wav 文件通过效果器链进行批量渲染，示例目录中创建的结构如下，<strong>注意这个目录仅做演示，实际上音频文件、配置文件、输出文件夹可随意放在不同的文件夹中。</strong><br><img src="/images/%E7%A4%BA%E4%BE%8B%E5%B7%A5%E7%A8%8B.png" alt="示例工程"><br>其中有配置文件、输出文件夹及三个音频文件<br>首先创建一个配置文件 convert_setting.txt 供批处理使用（实际使用时需删除注释）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 需要被处理的文件</span></span><br><span class="line">C:\Users\xiye\Desktop\TestAudio\<span class="number">1.</span>wavC:\Users\xiye\Desktop\TestAudio\<span class="number">2.</span>wavC:\Users\xiye\Desktop\TestAudio\<span class="number">3.</span>wav</span><br><span class="line"><span class="comment"># CONFIG 块</span>&lt;CONFIG  SRATE <span class="number">44100</span> <span class="comment"># 采样率</span>  NCH <span class="number">2</span> <span class="comment"># 通道数</span>  RSMODE <span class="number">9</span> <span class="comment"># 重采样模式</span>  DITHER <span class="number">3</span> <span class="comment"># 抖动模式</span>  PAD_START <span class="number">0.0</span> <span class="comment"># 不添加开始静默</span>  PAD_END <span class="number">0.0</span> <span class="comment"># 不添加结束静默</span></span><br><span class="line">  <span class="comment"># 以上的部分如果不想设置，其实不写也行 ：）</span></span><br><span class="line">  OUTPATH <span class="string">"C:\Users\xiye\Desktop\TestAudio\Output"</span> <span class="comment"># 输出路径设置为源文件目录下的子目录 Output</span>  OUTPATTERN <span class="string">""</span> <span class="comment"># 使用原文件名输出</span>  FXCHAIN <span class="string">"chain1.RfxChain"</span> <span class="comment"># 使用提前创建好的效果器链 chain1</span>&gt;</span><br></pre></td></tr></table></figure></p><p>提前创建好的效果器链 chain1 中，包括 ReaEQ 和 ReaVerb，并已设置了参数<br><img src="/images/chain1.png" alt="chain1"><br>chain1 的内容（图为加载后的效果，仅演示效果链的内容）<br>在命名行中执行以下命令:<br><code>reaper -batchconvert C:\Users\xiye\Desktop\TestAudio\convert_setting.txt</code><br>因为文件很少，可看到批处理窗口一闪而过：<br><img src="/images/%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86%E4%B8%AD.png" alt="批量处理中"><br>一闪而过的批处理窗口<br>执行结束后打开 Output 文件夹查看批处理后的音频文件，通过试听，发现已经完成了 EQ 与混响处理：<br><img src="/images/%E5%A4%84%E7%90%86%E5%90%8E.png" alt="处理后"><br>输出的文件<br>同时，TestAudio 文件夹中还创建了 Log 文件记录了操作日志：<br><img src="/images/%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97.png" alt="操作日志"><br>批处理日志</p><h2 id="更深的思考"><a href="#更深的思考" class="headerlink" title="更深的思考"></a>更深的思考</h2><h3 id="通过-Python-修改-Batch-Processing-的文本文件"><a href="#通过-Python-修改-Batch-Processing-的文本文件" class="headerlink" title="通过 Python 修改 Batch Processing 的文本文件"></a>通过 Python 修改 Batch Processing 的文本文件</h3><p>每次都人工修改批处理配置文件里的路径和参数，这对于聪明的用户绝对是难以忍受的。<strong>既然如此，不妨通过 Python 来完成这种繁琐的操作。</strong><br>举个实际使用时的例子，对于文件路径而言，完全可以写个函数获取目标路径内所有音频文件的完整路径，并修改到批处理配置文件内的对应位置。<br>在这里我们预先构建好一个 txt 文件作为模板，内容如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原始配置文件</span></span><br><span class="line">input_path&lt;CONFIG  SRATE <span class="number">44100</span>  NCH <span class="number">2</span>  RSMODE <span class="number">9</span>  DITHER <span class="number">3</span>  PAD_START <span class="number">0.0</span>  PAD_END <span class="number">0.0</span>  OUTPATH output_path  OUTPATTERN <span class="string">""</span>  FXCHAIN fx_chain&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后的配置文件</span></span><br><span class="line">input_path&lt;CONFIG  SRATE sample_rate  NCH channels  RSMODE re_sample_mode  DITHER dither_mode  PAD_START pad_start  PAD_END pad_end  OUTPATH output_path  OUTPATTERN out_pattern  FXCHAIN fx_chain&gt;</span><br></pre></td></tr></table></figure></p><p>根据其中的内容，可利用字符串的 replace 方法，通过下面的函数对配置文件的内容进行修改：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三个参数分别为读取后的配置文件，需要修改的字符串代号（如 input_path、fx_chain），修改后的字符串或数字</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_changer</span><span class="params">(setting_file, old_str, new_str)</span>:</span></span><br><span class="line">    file_data = <span class="string">""</span></span><br><span class="line">    <span class="comment"># 修改文件中的内容</span></span><br><span class="line">    <span class="keyword">with</span> open(file, <span class="string">"r"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            <span class="keyword">if</span> old_str <span class="keyword">in</span> line:</span><br><span class="line">                line = line.replace(old_str, new_str)</span><br><span class="line">            file_data += line</span><br><span class="line">    <span class="comment"># 写入修改后的内容</span></span><br><span class="line">    <span class="keyword">with</span> open(file,<span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(file_data)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 因为 input_path 肯定不会是单行，而是一大堆文本文件。所以在获取完文件路径后，需要用换行符把其分割开，写成：</span></span><br><span class="line">file_path = <span class="string">"path1\npath2\npath3"</span></span><br></pre></td></tr></table></figure></p><h3 id="在命令行启动时调用-Action-或-ReaScript"><a href="#在命令行启动时调用-Action-或-ReaScript" class="headerlink" title="在命令行启动时调用 Action 或 ReaScript"></a>在命令行启动时调用 Action 或 ReaScript</h3><p><strong>如果想要在命令行调用 Reaper 的同时启动某个 Action 或脚本得怎么办？</strong><br>这在有些应用场景下可能是个刚需，例如在命令行创建工程后通过脚本让工程自行执行一些更复杂的初始化操作，然而命令行的语法中并没有跟这个功能有关的参数。<br><strong>其实很简单，有两个变通的方法可以解决这个需求。</strong><br>第一个方法，可以通过 SWS 中现有的脚本来做到：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置全局启动时加载的 Action 或脚本</span></span><br><span class="line">SWS/S&amp;M: Set <span class="keyword">global</span> startup action </span><br><span class="line"><span class="comment"># 设置工程启动时加载的 Action 或脚本</span></span><br><span class="line">SWS/S&amp;M: Set project startup action</span><br></pre></td></tr></table></figure></p><p>第二个方法，在 Reaper 资源路径的 Scripts 文件夹中通过创建名为 __startup.（后缀名可以是 eel 或 lua）的脚本，也可在启动时被加载（除非 Shift 键被按下），在 Reaper V5.3 之后均可使用。</p><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2><p>《补完 Reaper 效率链的最后一环》专栏除了分享有关 ReaScript 的知识外，<strong>还会分享一些我认为比较冷门的 Reaper 使用技巧。</strong><br>那些比较大路货的经验，本专栏默认读者通过各种视频和文章已掌握，所以我对书写文档和论坛中都比较冷门的技巧会更有兴趣。如果对大家有帮助，欢迎持续关注！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reaper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>人人都能用 WAAPI（三）Functions（执行类 API）剩余部分及 Topic（订阅类 API）</title>
      <link href="/2020/09/25/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/09/25/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>在《人人都能用 WAAPI（三）》中，我们会继续上一篇的内容，讨论 WAAPI 的 Functions（执行类）中剩下的其他的 API 及 Topic（订阅类）。<br>考虑到 Audiokinetic 官网无代码框，我在 GitHub 创建了一个仓库，其中包括了本系列文章中所有的代码，地址为：<a href="https://github.com/zcyh147/Everyone-can-use-WAAPI" target="_blank" rel="noopener">https://github.com/zcyh147/Everyone-can-use-WAAPI</a></p><blockquote><p>阅前须知：</p><ul><li><strong>把 API 逐条列出讲解是为了快速阐述其功能，补充文档的一些不足，以帮助大家快速对 WAAPI 建立印象</strong>，并非重写参考文档。所以建议看完本文后按照第一篇文中所提的方法，用自己喜欢的整理方式重新整理一次。</li><li>本文并不会把每个参数全都翻译并复述一遍功能，这里<strong>均假设读者已学会了概述中的 JSON 阅读方法，能够自行根据我的介绍查阅 WAAPI 参数及返回值等文档信息，此外还希望读者能准确的找到在线文档中对应的章节。</strong></li><li>为了照顾初学者，我尽量把注释写到每一行，以便快速入门。</li><li>学会 RTFM（Read The Fucking Manual），因为接下来的文章比较严肃。<strong>如发现某些概念看不懂或找不到，请善用 Wwise 文档强大的搜索功能或通过 Google 检索所需答案。</strong></li><li><strong>因为 WAAPI 的功能也是随版本更新逐渐添加的，建议安装最新版 Wwise 进行操作。</strong>当报错信息提示 “The procedure URI is unknown.” 时，就代表你的当前 WAAPI 版本并不支持此 API。</li></ul></blockquote><p>本文目录：</p><p>[toc]</p><h2 id="Functions（执行类-API）剩余部分"><a href="#Functions（执行类-API）剩余部分" class="headerlink" title="Functions（执行类 API）剩余部分"></a>Functions（执行类 API）剩余部分</h2><h3 id="wwise-ui、wwise-waapi、wwise-debug-概览"><a href="#wwise-ui、wwise-waapi、wwise-debug-概览" class="headerlink" title="wwise.ui、wwise.waapi、wwise.debug 概览"></a>wwise.ui、wwise.waapi、wwise.debug 概览</h3><p><img src="/images/ui%20waapi%20debug.png" alt="ui waapi debug"><br><code>wwise.ui</code>、<code>wwise.waapi</code>、<code>wwise.debug</code> 这几个小分类是执行类里比较简单的部分，功能分别为 UI 级的控制操作、对于 WAAPI 相关信息的获取及 Debug 功能。<br>鉴于 <code>soundengine</code> 部分比较复杂，作为预热我们会先从这些小功能讲起。</p><h3 id="ui（用户界面级操作）"><a href="#ui（用户界面级操作）" class="headerlink" title="ui（用户界面级操作）"></a>ui（用户界面级操作）</h3><h4 id="bringToForeground-captureScreen-getSelectedObjects（窗口操作、截图、获取选中对象）"><a href="#bringToForeground-captureScreen-getSelectedObjects（窗口操作、截图、获取选中对象）" class="headerlink" title="bringToForeground, captureScreen, getSelectedObjects（窗口操作、截图、获取选中对象）"></a>bringToForeground, captureScreen, getSelectedObjects（窗口操作、截图、获取选中对象）</h4><p><code>bringToForeground</code> 能够把当前 Wwise 窗口前置，这个功能只在 Windows 下才有效。<br><code>captureScreen</code> 可以对当前 Wwise 工程进行截图，如果不进行参数指定默认会截取整个视图。通过其中的 <code>rect</code> 参数可以设置截图的 xy 轴起始点及宽度高度。如果想截取指定的 View，可以在 <code>viewName</code> 中进行指定，同时可通过 <code>viewSyncGroup</code> 指定获取 View 中的哪个 Sync Group。<br><code>getSelectedObjects</code> 可以获得当前选择对象的相关信息。大家都知道在获取对象 GUID 时，可以按住 Shift 键后在对象上点右键，在菜单中点击复制对象 GUID。而这个 API 可以对这个工作流程进行优化，它的参数只有 Options 用来决定返回值。<br>比如刚才提到的需求，我们可在 Options 中添加 <code>id</code> 参数，即可在调用这个 API 的时候获得 GUID 返回值。<strong>这个功能与 <code>ak.wwise.core.object.get</code> 能获取的数据种类是完全一样的。</strong>想获得更为便捷的信息获取工作流，可以通过命令扩展功能把脚本调用整合到右键菜单上。<br>todo：待测试</p><h4 id="project-open-project-close（读取工程与关闭工程）"><a href="#project-open-project-close（读取工程与关闭工程）" class="headerlink" title="project.open, project.close（读取工程与关闭工程）"></a>project.open, project.close（读取工程与关闭工程）</h4><p>通过 <code>project.open</code> 可以打开指定的工程，为此需要传入 <code>path</code> 参数。此外还可设置 <code>bypassSave</code> 来决定是否提示用户保存当前工程。<br>在 <code>project.close</code> 也是同理，可通过 <code>bypassSave</code> 决定是否提示用户保存当前工程。如果设定为 False，会直接关闭工程。</p><h4 id="commands-execute-commands-getCommands（执行命令与获取可用命令列表）"><a href="#commands-execute-commands-getCommands（执行命令与获取可用命令列表）" class="headerlink" title="commands.execute, commands.getCommands（执行命令与获取可用命令列表）"></a>commands.execute, commands.getCommands（执行命令与获取可用命令列表）</h4><p><strong>commands 的 <code>execute</code> 是个更“直接”的命令执行功能</strong>。<br>在上一篇中我们提到当想达到一个具体的需求时要先找到对应的 API，之后按文档要求调用 API 以实现它的功能。但如果我们想完成一些简单的需求，尤其是 Wwise 本身展现在软件页面上的一些功能时。这种方法无疑略显麻烦，快捷键无疑比代码更为简单。</p><blockquote><p>举个例子，如果我们在自己做的工具想一键生成所有 SoundBank，按上一篇文中的方法应该怎么做呢？注意 <code>generate</code> 是没有功能能生成所有 SoundBank 的。所以假设想用这个 API 实现需求，我们就必须先获取所有 SoundBank 的名称或 GUID，再作为参数反复传入 API 以让其正常工作，这无疑是笨拙且低效的。</p></blockquote><p>这时我们就需要用到 <code>execute</code>，它的必备参数 <code>command</code> 即需要执行的命令。以上例所提的需求来说，我们可在文档中的 Wwise Authoring Command Identifiers（<a href="https://www.audiokinetic.com/library/edge/?source=SDK&amp;id=globalcommandsids.html）中翻阅命令列表。在其中可轻松找到" target="_blank" rel="noopener">https://www.audiokinetic.com/library/edge/?source=SDK&amp;id=globalcommandsids.html）中翻阅命令列表。在其中可轻松找到</a> <code>GenerateAllSoundbanksAllPlatforms</code> 或 <code>GenerateAllSoundbanksCurrentPlatform</code>，甚至还有加上 AutoClose 的版本（生成结束后自动关闭 SoundBank 生成窗口），在参数中写入一行简单的 <code>“command”: &quot;GenerateAllSoundbanksAllPlatforms&quot;</code>，此时执行远程调用，Wwise 就会自动对全部平台的全部 SoundBank 执行生成操作。<br><strong>与 WAAPI 的绝大多数执行过程不同，这种调用方法是会显示出窗口的，参数中也没有方法让其静默工作。</strong>本质上就是代替我们完成了点击操作，但却<strong>极大的扩展了 WAAPI 对于简单命令的执行能力。</strong><br>todo：<code>enableAutomationMode</code>情况下呢？<br>翻阅 Wwise Authoring Command Identifiers，除了能看到上面提到的 SoundBank 相关指令外，还可轻松看到诸如拷贝对象信息、调用系统菜单、显示各种窗口、版本管理相关等功能。<br><code>getCommands</code> 可以看到当前版本平台支持的所有命令，<strong>但它比 Wwise Authoring Command Identifiers 中所列出命令的会更多</strong>，可作为使用时的参考。</p><h4 id="commands-register-commands-unregister（命令扩展的注册与注销）"><a href="#commands-register-commands-unregister（命令扩展的注册与注销）" class="headerlink" title="commands.register, commands.unregister（命令扩展的注册与注销）"></a>commands.register, commands.unregister（命令扩展的注册与注销）</h4><p><code>register</code> 和 <code>unregister</code>，看名字容易看出它们的功能是注册与注销，它们实际操作的是 Wwise 的另一个进阶功能，即对命令扩展（用户自定义的命令）进行注册与注销。</p><blockquote><p><strong>命令扩展（Command Add-ons）是在 Wwise 中添加自定义的功能的一种方法，这个新增的功能可以出现在菜单中，可以用上一小节提到的 <code>execute</code> 命令执行，也可映射到控制器或快捷键上。</strong><br>为什么有了 WAAPI 我们还要这个功能呢？因为不是所有的工作流改善都是 WAAPI 能做到的。举个例子，你想对已导入的音频进行简单的编辑（不是 Trim），这时可能需要打开 DAW 或音频剪辑工具改完后再重新替换 Wwise 中的源文件，显然比较麻烦。<br>但有了命令扩展功能在，我们就可以在 Wwise 中给音频源的菜单中增加直接调用 Audacity 的功能，同时给 Audacity 传递一些预定义参数，让其自动对我们所选的文件进行读取操作以便于编辑。<br>除了执行程序外，<strong>命令扩展也可以调用脚本</strong>。因为绝大多数音频设计的工作还是要面对 Wwise 本身的界面的，所以一些 WAAPI 功能脚本做好后我们可以嵌入到 Wwise 的菜单中，这样在工作中更加方便。</p></blockquote><p>回到 <code>register</code> 和 <code>unregister</code> 的功能上，<strong>其实它们就是在 WAAPI 中的一种注册和注销命令扩展的方法（其余的定义命令扩展方法是要在几个路径下的 Add-ons\Commands 目录中添加 JSON 配置参数来完成的）</strong>。对此，技术音频设计师或许可以给用户封装一个自定义添加功能菜单的程序，调用 <code>register</code> 来进行用户定义功能的菜单添加。这样能够实现更加私人订制化的的工作流实现，令声音设计师在定制菜单上具有更多自由度。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>对于 <code>bringToForeground, captureScreen, getSelectedObjects</code> 三个 API 而言，其中 <code>getSelectedObjects</code> 无疑在快速获取对象信息上有着绝对的有时，简化了 <code>get</code> 中的一部分功能，有效提升了效率。<br><code>commands.execute</code> 对于 WAAPI 工具设计无疑是个非常重要的功能，虽然其中的不少功能都可通过快捷键做到，但快捷键是有所限制的。首先记忆快捷键对于记忆力来说是个挑战，使用控制器虽然可避免记忆，但终究不是所有人的控制器都按钮足够（以及是否有足够的地方贴上贴纸）。<br>对于使用 Metagrid 和 StreamDeck 的人来说映射快捷键倒没什么问题，但此时如果还有 <code>commands.execute</code> 及 WAAPI 其他功能脚本进行辅助，才是真正的做到了工作流提升的最大化。</p><h3 id="waapi（WAAPI-相关）"><a href="#waapi（WAAPI-相关）" class="headerlink" title="waapi（WAAPI 相关）"></a>waapi（WAAPI 相关）</h3><h4 id="getFunctions-getSchema-getTopics（获取-WAAPI-有关信息）"><a href="#getFunctions-getSchema-getTopics（获取-WAAPI-有关信息）" class="headerlink" title="getFunctions, getSchema, getTopics（获取 WAAPI 有关信息）"></a>getFunctions, getSchema, getTopics（获取 WAAPI 有关信息）</h4><p>WAAPI 中的 <code>waapi</code> 类下面的三个是 API 反射函数，唯一的功能就是获取 WAAPI 有关信息。<br><code>getFunctions</code> 能够获取当前所有可用的 Functions（执行类） API，<code>getTopics</code> 则是获取当前所有可用的 Topics（订阅类）API。<br><code>getSchema</code> 以 WAAPI URI 作为参数，能够返回 URI 对应的各种 Schema。<strong>注意此 API 因参数冲突问题，Python 用户需更新 waapi-client 0.5及后续版本才可正常工作。</strong></p><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>对于不允许工作电脑联网的公司，因为官方的离线文档目前只会下载 Wwise Help，并不会下载 Wwise SDK 文档，可用这种方法在离线时查询 WAAPI 有关参数和使用方法。<br>todo：（真的文档只会下 Wwise Help 吗？）</p><h3 id="debug（Debug-功能）"><a href="#debug（Debug-功能）" class="headerlink" title="debug（Debug 功能）"></a>debug（Debug 功能）</h3><h4 id="enableAsserts-enableAutomationMode-testAssert-testCrash"><a href="#enableAsserts-enableAutomationMode-testAssert-testCrash" class="headerlink" title="enableAsserts, enableAutomationMode, testAssert, testCrash"></a>enableAsserts, enableAutomationMode, testAssert, testCrash</h4><p><code>enableAutomationMode</code> 为启用自动化模式，可减少自动化任务过程中由消息框和对话框造成的潜在中断。在大量的自动化工作中可以打开此选项，此时 Wwise 的界面也会变成炫酷的暗红色调。<br><code>enableAsserts</code> 为断言开关，<code>testAssert</code> 用来在 Debug Builds 中测试断言。订阅类的 <code>ak.wwise.debug.assertFailed</code> 功能亦会返回断言失败时的具体信息。使用这个功能前需要知道，Wwise SDK 提供 Debug、Profile 和 Release 三个版本，日常的开发工作主要面对 Profile 版，Release 版本则用于最终零售。而 Wwise 提供的断言测试功能，只能在 Debug（调试）版本中使用。<br><code>testCrash</code> 为崩溃时用来 Debug 的功能。</p><h3 id="soundengine-概览"><a href="#soundengine-概览" class="headerlink" title="soundengine 概览"></a>soundengine 概览</h3><p><img src="/images/soundengine.png" alt="soundengine"><br><code>soundengine</code> 是执行类中的第二大分类，负责直接对声音引擎层级进行操作。<strong>如果曾翻阅过 Wwise SDK，我们很容易发现 <code>soundengine</code> 的大部分 API 在其中都以同名出现过。</strong>也就是说，WAAPI 将这一部分常用功能从 Wwise SDK 中暴露了出来，提供了另一种控制声音引擎的方法。<br>因为是对声音引擎的各种属性进行操作，所以这些 API 几乎都需要用户提供注册后的 Game Object 的 GUID 作为参数，以明确到底要对哪个操作对象进行控制。<br>在 Wwise 中 Game Object 是最核心的概念之一，只有把游戏引擎中的发声体与 Wwise 中的 Game Object 绑定，Wwise 才能知道到底要对为游戏中的哪个对象发声、设置位置等。<br><strong>要建立 Game Object 的前提是 Wwise 与游戏引擎相连，在这部分会假设读者已经完成了 Unity 和 Wwise 的连接。</strong></p><h4 id="registerGameObj-unregisterGameObj（游戏对象注册与注销）"><a href="#registerGameObj-unregisterGameObj（游戏对象注册与注销）" class="headerlink" title="registerGameObj, unregisterGameObj（游戏对象注册与注销）"></a>registerGameObj, unregisterGameObj（游戏对象注册与注销）</h4><p><strong>如上文所述，把游戏引擎里的对象注册到 Wwise Game Object 上是 Wwise 能正确工作的前提。</strong><br>除了在游戏引擎中通过预制脚本或直接引用 Wwise SDK 注册外（这两者都是使用了 <code>AK::SoundEngine::RegisterGameObj()</code>），我们也可通过 WAAPI 来进行 Game Object 的注册管理。<br><code>registerGameObj</code> 与 <code>unregisterGameObj</code> 分别负责注册与注销 Wwise Game Object，其中 <code>registerGameObj</code> 需要提供 Game Object 的 ID 与名称，<code>unregisterGameObj</code> 只需 Game Object ID 即可注销对象。</p><h4 id="executeActionOnEvent-postEvent-postTrigger-postMsgMonitor-seekOnEvent（执行与发送）"><a href="#executeActionOnEvent-postEvent-postTrigger-postMsgMonitor-seekOnEvent（执行与发送）" class="headerlink" title="executeActionOnEvent, postEvent, postTrigger, postMsgMonitor, seekOnEvent（执行与发送）"></a>executeActionOnEvent, postEvent, postTrigger, postMsgMonitor, seekOnEvent（执行与发送）</h4><p><code>postMsgMonitor</code> 在本系列文的第一篇概述中曾用来输出 “Hello Wwise!“ 字符串，它的功能只有一条，即把传入的信息输出到 Profiler 的 Capture Log 中。<br><code>postEvent</code> 与 SDK 中的 <code>AK::SoundEngine::PostEvent</code> 功能相同，提供 Game Object ID 与 Event ID 后可在特定的 Game Object 上触发 Event。<br><code>postTrigger</code> 可在 Interactive Music 中手动触发 Stinger，与在 Wwise 中设置的 Trigger 触发效果相同。<br><code>executeActionOnEvent</code> 可对特定 Game Object 上的 Event 执行 Action，必备参数除了 <code>gameObject</code>，<code>event</code>，<code>actionType</code> 用来决定操作对象和行为类型之外，还可用 <code>fadeCurve</code>（过度时的曲线类型），<code>transitionDuration</code>（过度时长）来为 Event 增加播放淡变。<br><code>seekOnEvent</code> 可对指定 Event 的 Play Actions 中引用的所有播放对象中查找，为此需要提供相关的参数如 <code>event</code>，<code>gameObject</code>，<code>playingId</code> 及查找属性等。</p><h4 id="stopAll-stopPlayingID（停止播放）"><a href="#stopAll-stopPlayingID（停止播放）" class="headerlink" title="stopAll, stopPlayingID（停止播放）"></a>stopAll, stopPlayingID（停止播放）</h4><p><code>stopAll</code> 停止特定游戏对象上播放的声音，如果游戏对象不存在，那么所有声音都会被停止。<br><code>stopPlayingID</code> 停止播放特定的内容，需要使用 <code>playingId</code> 来指明要停止播放的内容，同时还必须提供 <code>fadeCurve</code>，<code>transitionDuration</code> 来设置声音渐变时的曲线和时间。</p><h4 id="setDefaultListeners-setListeners-setListenerSpatialization-setGameObjectAuxSendValues-setGameObjectOutputBusVolume-setPosition-setMultiplePositions-setObjectObstructionAndOcclusion-setScalingFactor（各种属性设置）"><a href="#setDefaultListeners-setListeners-setListenerSpatialization-setGameObjectAuxSendValues-setGameObjectOutputBusVolume-setPosition-setMultiplePositions-setObjectObstructionAndOcclusion-setScalingFactor（各种属性设置）" class="headerlink" title="setDefaultListeners, setListeners, setListenerSpatialization, setGameObjectAuxSendValues, setGameObjectOutputBusVolume, setPosition, setMultiplePositions, setObjectObstructionAndOcclusion, setScalingFactor（各种属性设置）"></a>setDefaultListeners, setListeners, setListenerSpatialization, setGameObjectAuxSendValues, setGameObjectOutputBusVolume, setPosition, setMultiplePositions, setObjectObstructionAndOcclusion, setScalingFactor（各种属性设置）</h4><p><code>setDefaultListeners</code> 可置默认的听者，之后所有新注册的游戏对象都会以此作为听者。需要提供作为 <code>listeners</code>（听者）的 Game Object GUID。<br><code>setListeners</code> 可为单一发声体对象的设置听者，为此需要提供作为 <code>listeners</code>（听者）和 <code>emitter</code>（发声体）的 Game Object GUID。<br><code>setListenerSpatialization</code> 用来设定听者的空间化参数，对不同声道设置音量偏置。需要提供 <code>listener</code>（听者的 GUID），<code>volumeOffsets</code>（每个声道的偏置值），<code>spatialized</code>（空间化开关），<code>channelConfig</code>（声道构造）。<br><code>setGameObjectAuxSendValues</code> 可对特定 Game Object 设定 Aux Bus，使用 <code>gameObject</code>（游戏对象的 GUID），<code>auxSendValues</code>（Aux Bus 对象、发送量、发送后对象的听者）来决定 Aux Send 的相关属性。<br><code>setGameObjectOutputBusVolume</code> 设定指定发声体 Game Object 的 Output Bus 音量，需提供 <code>emitter</code>（需要被调整音量的发声体对象），<code>listener</code>（听者对象），<code>controlValue</code>（使用数值更改音量，0为静音，0-1为衰减量，1往上为增加量）。<br><code>setPosition</code><br><code>setMultiplePositions</code> 可以为一个发声体设置多个位置，预制脚本 AkAmbient 中的多点定位就是用 SDK 中它所对应的 API 实现的。参数除了 <code>gameObject</code>（游戏对象） 之外，还需要提供 <code>multiPositionType</code>（多点定位模式），<code>positions</code>（听者的位置和朝向）。<br><code>setObjectObstructionAndOcclusion</code> 用来设置对象的声障和声笼级别，需要 <code>listener</code>（听者）和 <code>emitter</code>（发声体）及 <code>obstructionLevel</code>（声障级别），<code>occlusionLevel</code>（声笼级别）。<br><code>setScalingFactor</code></p><h4 id="setState-setSwitch-setRTPCValue-resetRTPCValue（Game-Sync-设置）"><a href="#setState-setSwitch-setRTPCValue-resetRTPCValue（Game-Sync-设置）" class="headerlink" title="setState, setSwitch, setRTPCValue, resetRTPCValue（Game Sync 设置）"></a>setState, setSwitch, setRTPCValue, resetRTPCValue（Game Sync 设置）</h4><p><code>setState</code>, <code>setSwitch</code>, <code>setRTPCValue</code><br><code>resetRTPCValue</code></p><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><h2 id="Topic（订阅类-API）"><a href="#Topic（订阅类-API）" class="headerlink" title="Topic（订阅类 API）"></a>Topic（订阅类 API）</h2><h3 id="wwise-core-概览"><a href="#wwise-core-概览" class="headerlink" title="wwise.core 概览"></a>wwise.core 概览</h3><p><img src="/images/%E8%AE%A2%E9%98%85wwise.core.png" alt="订阅wwise.core"></p><p>与 Functions（执行类 API）相同，Topics（订阅类 API）中最大的功能模块也是 <code>wwise.core</code>。<br><strong>在开始前请注意这些 API 的一个共性，它们的可选的 Options 中绝大多数存在两个公用选项</strong>。其一是 <code>platform</code>（平台），另一个是通过 <code>return</code> 设置的 Wwise 对象内置的存取器提供的诸多标准属性（可参考文档中有关 “built-in accessors for Wwise objects” 的描述，以下简称为“基本信息”）。</p><h3 id="object（订阅有关对象属性的改变）"><a href="#object（订阅有关对象属性的改变）" class="headerlink" title="object（订阅有关对象属性的改变）"></a>object（订阅有关对象属性的改变）</h3><h4 id="created-preDeleted-postDeleted"><a href="#created-preDeleted-postDeleted" class="headerlink" title="created, preDeleted, postDeleted"></a>created, preDeleted, postDeleted</h4><p><code>created</code> 可在工程中有对象被创建时，发布此对象被订阅的信息。具体的信息类型需要使用 Options 参数指定，如果此参数留空，发布的信息中只会包含 <code>object</code> 基本信息（包括 GUID 与对象类型）。<br><code>preDeleted</code> 与 <code>postDeleted</code> 的功能近似，区别是发布订阅的信息的时间点不同，<strong>前者在对象删除前发布消息，后者在删除后发布消息</strong>。对于需要精确时间戳的情况下，<code>preDeleted</code> 能够更精确的获得准确删除操作开始的时间点。与 <code>created</code> 一样，如果不提供 Options 指定订阅返回值，默认也只会返回 <code>object</code> 的基本信息。</p><h4 id="childAdded-childRemoved"><a href="#childAdded-childRemoved" class="headerlink" title="childAdded, childRemoved"></a>childAdded, childRemoved</h4><p><code>childAdded</code> 与 <code>childRemoved</code> 订阅了父对象（容器对象）中子对象的状态，当子对象被添加或移除时，会发布订阅的信息类型。<br>它们需要提供 Options 参数，来决定发布的信息中返回哪些对象信息类型。当不提供 Options 参数时，默认只会返回 <code>parent</code>（父对象） 和 <code>child</code>（对象的基本信息）。</p><h4 id="attenuationCurveChanged-attenuationCurveLinkChanged"><a href="#attenuationCurveChanged-attenuationCurveLinkChanged" class="headerlink" title="attenuationCurveChanged, attenuationCurveLinkChanged"></a>attenuationCurveChanged, attenuationCurveLinkChanged</h4><p><code>attenuationCurveChanged</code> 可订阅对象的衰减曲线的使用情况，但这个改变情况并非指衰减曲线本身（分割点位置、曲线类型）的变化，而是 Attenuation Editor 中衰减曲线的使用状态。<br><code>attenuationCurveLinkChanged</code> 订阅了衰减曲线在不同平台下的 Link 情况。<br><strong>我进行了多次测试，发现实际使用中这两者的功能相同，都会响应彼此的设计功能而发布相同的返回信息</strong>，因此这两个 API 可以混用。它们的可选 Options 参数中可设定所需的对象的基本信息。</p><h4 id="curveChanged-nameChanged-notesChanged"><a href="#curveChanged-nameChanged-notesChanged" class="headerlink" title="curveChanged, nameChanged, notesChanged"></a>curveChanged, nameChanged, notesChanged</h4><p><code>curveChanged</code> 可订阅对象属性曲线发生改变的情况，并不会返回曲线改变了多少。如不指定 Options，默认会返回 <code>owner</code>（被修改的对象）和 <code>curve</code>（被修改的曲线对象）的基本信息。<br><code>nameChanged</code> 可订阅对象名称的变化，如不指定 Options，默认会返回 <code>oldName</code>（修改前的对象名），<code>newName</code>（修改后的对象名），<code>object</code>（对象的基本信息）。<br><code>notesChanged</code> 可订阅对象备注的变化，如不指定 Options，默认会返回 <code>oldNotes</code>（修改前的备注），<code>newNotes</code>（修改后的备注），<code>object</code>（对象的基本信息）。</p><h4 id="propertyChanged-referenceChanged"><a href="#propertyChanged-referenceChanged" class="headerlink" title="propertyChanged, referenceChanged"></a>propertyChanged, referenceChanged</h4><p><code>propertyChanged</code> 可订阅对象的属性发生改变的具体情况，<strong>它也是 <code>wwise.core.object</code> 订阅子类中唯一需要提供必须参数的 API</strong>，Options 中必备的参数有 property（被修改的属性名）和 object（对象名或 GUID）。同时也指定基本参数来决定发布信息的返回值。默认情况下会返回 <code>property</code>（被修改的属性名），<code>object</code>（对象的基本信息），<code>old</code>（之前的属性值），<code>new</code>（新的属性值），<code>platform</code>（被修改属性值所在的平台）。<br><code>referenceChanged</code> 用来订阅对象引用发生变化的情况，如不指定 Options，默认会返回 <code>old</code>（之前的引用对象），<code>new</code>（之的的引用对象），<code>object</code>（引用被修改的对象），<code>reference</code>（被修改的引用对象的名字）。</p><h3 id="project（订阅工程的状态改变）"><a href="#project（订阅工程的状态改变）" class="headerlink" title="project（订阅工程的状态改变）"></a>project（订阅工程的状态改变）</h3><h4 id="loaded-saved"><a href="#loaded-saved" class="headerlink" title="loaded, saved"></a>loaded, saved</h4><p><code>loaded</code> 可在工程被正确加载后发布信息，无需参数，这个 API 指的是通过菜单打开工程或 <code>ak.wwise.ui.project.open</code> 打开工程并加载完成后发布消息。<br><code>saved</code> 可在工程保存后发布被修改文件的路径消息，<strong>它所返回的 <code>modifiedPaths</code> 很详细，每个被修改的 wwu 文件和工程内文件的的路径都会被返回。</strong></p><h4 id="preClosed-postClosed"><a href="#preClosed-postClosed" class="headerlink" title="preClosed, postClosed"></a>preClosed, postClosed</h4><p><code>preClosed</code> 和 <code>postClosed</code> 分别可在工程开始关闭和关闭完成时发布消息，注意这个关闭指的是通过 Crtl + F4 快捷键或 <code>ak.wwise.ui.project.close</code> 来关闭的工程，并不是点击窗口关闭按钮关闭整个 Wwise。</p><h3 id="soundbank（订阅-SoundBank-生成状态）"><a href="#soundbank（订阅-SoundBank-生成状态）" class="headerlink" title="soundbank（订阅 SoundBank 生成状态）"></a>soundbank（订阅 SoundBank 生成状态）</h3><h4 id="generated-generationDone"><a href="#generated-generationDone" class="headerlink" title="generated, generationDone"></a>generated, generationDone</h4><p><code>generated</code> 可订阅 SoundBank 开始生成时的信息，在每个平台的每个 SoundBank 开始生成时都会被触发，因此会发布多个消息。Options 中除了设定 SoundBank 对象的基础信息（Wwise 对象基本信息）外，还可选择加入 <code>bankData</code>（base64 编码的包内数据及编码后的大小），<code>infoFile</code>（在结果中添加 bankInfo，其中包括 SoundBank 内的详细信息如 Event 信息、路径、GUIID 等），<code>pluginInfo</code>（JSON 格式，工程所用到的插件相关信息） 三个选项。<strong>当选中这三个选项时，会在返回信息中增加更具体的信息，自带的 <code>soundbank</code> 中只有对象基础消息，是无法反映出 SoundBank 内具体的构成的。</strong><br><code>generationDone</code> 可订阅 SoundBank 生成结束时的 log 信息，不指定 Options 时，默认会返回 <code>logs</code> 中的 <code>severity</code>（生成完成后的错误程度，从无错误到最严重分别为 Message、Warning、Error、Fatal Error），<code>time</code>（日志时间戳），<code>message</code>（日志消息），<code>messageId</code>（日志消息 ID）</p><h3 id="switchContainer（订阅-Switch-Container-容器内的指派变化）"><a href="#switchContainer（订阅-Switch-Container-容器内的指派变化）" class="headerlink" title="switchContainer（订阅 Switch Container 容器内的指派变化）"></a>switchContainer（订阅 Switch Container 容器内的指派变化）</h3><h4 id="assignmentAdded-assignmentRemoved"><a href="#assignmentAdded-assignmentRemoved" class="headerlink" title="assignmentAdded, assignmentRemoved"></a>assignmentAdded, assignmentRemoved</h4><p><code>assignmentAdded</code> 和 <code>assignmentRemoved</code> 可以订阅 Switch Container 中指派的添加与移除，它们两者可选的 Options 与可发布的信息完全一致，在这里放在一起讨论。<br>在 Options 中如果不指定需返回的 Switch Container 和指派对象的基本信息时，这两个 API 默认都只会返回 <code>stateOrSwitch</code>（子对象指派到了 Switch 还是 State 中，并返回它的信息），<code>switchContainer</code>（容器本身的信息），<code>child</code>（被指派到容器内对象的有关信息）</p><h3 id="transport（订阅走带状态变化）"><a href="#transport（订阅走带状态变化）" class="headerlink" title="transport（订阅走带状态变化）"></a>transport（订阅走带状态变化）</h3><h4 id="stateChanged"><a href="#stateChanged" class="headerlink" title="stateChanged"></a>stateChanged</h4><p><code>stateChanged</code> 可订阅走带对象的状态变化，必须用 Options 提供 <code>transport</code>（走带对象的 GUID）。当状态改变，会发布 <code>transport</code>（正在订阅的走带对象的 GUID），<code>object</code>（被走带对象所控制对象的 GUID），<code>state</code>（走带播放状态）。</p><h3 id="audio（订阅音频导入状态）"><a href="#audio（订阅音频导入状态）" class="headerlink" title="audio（订阅音频导入状态）"></a>audio（订阅音频导入状态）</h3><h4 id="imported"><a href="#imported" class="headerlink" title="imported"></a>imported</h4><p><code>imported</code> 可订阅音频导入操作完成后的消息，可选的 Options 中可设定每个被导入对象所要返回的基本信息。</p><h3 id="log（订阅日志中对象的添加情况）"><a href="#log（订阅日志中对象的添加情况）" class="headerlink" title="log（订阅日志中对象的添加情况）"></a>log（订阅日志中对象的添加情况）</h3><h4 id="itemAdded"><a href="#itemAdded" class="headerlink" title="itemAdded"></a>itemAdded</h4><p><code>itemAdded</code> 可订阅日志中条目的增加，不需要指定 Options，在发布信息中可以返回 <code>channel</code>（可返回 Log 窗口中选项卡的名称），<code>item</code>（选项卡内具体新增的条目，如 time，severity 等）。</p><h3 id="wwise-debug-概览"><a href="#wwise-debug-概览" class="headerlink" title="wwise.debug 概览"></a>wwise.debug 概览</h3><p><img src="/images/%E8%AE%A2%E9%98%85wwise.debug.png" alt="订阅wwise.debug"></p><h4 id="assertFailed（订阅资源失败信息）"><a href="#assertFailed（订阅资源失败信息）" class="headerlink" title="assertFailed（订阅资源失败信息）"></a>assertFailed（订阅资源失败信息）</h4><p><code>assertFailed</code> 只在 Debug 版本下可用，会返回 <code>fileName</code>（原文件名），<code>lineNumber</code>（代码行数），<code>expression</code>（错误注释）。</p><h3 id="wwise-ui-概览"><a href="#wwise-ui-概览" class="headerlink" title="wwise.ui 概览"></a>wwise.ui 概览</h3><p><img src="/images/%E8%AE%A2%E9%98%85wwise%20ui.png" alt="订阅wwise ui"></p><h4 id="commands-executed-selectionChanged（订阅命令执行状态与选择改变）"><a href="#commands-executed-selectionChanged（订阅命令执行状态与选择改变）" class="headerlink" title="commands.executed, selectionChanged（订阅命令执行状态与选择改变）"></a>commands.executed, selectionChanged（订阅命令执行状态与选择改变）</h4><p><code>commands.executed</code> 可订阅有命令被执行，可选的 Options 中除了设定对象的基本信息外，还可设定 platform（平台）和 language（语言）。默认情况下会返回 platform（平台），objects（被执行对象的基本信息），command（被执行命令的 ID）。<strong>这条 API 不只响应通过 <code>ak.wwise.ui.commands.execute</code> 所执行的命令，用户正常执行的操作也会有响应，因此可用作查看当前命令是否在 Wwise Authoring Command Identifiers 受支持的验证工具。</strong><br><code>selectionChanged</code> 可工程中选中对象的变化，只<strong>对 Project Explorer 和 Event Viewer 这种含有条目的有效</strong>，对调整选项无效。可选的 Options 中同样可以指定 <code>platform</code>（平台）和 <code>language</code>（语言），返回值只会返回 <code>object</code>（被选中对象的基本信息）。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="Functions（执行类-API）剩余部分-1"><a href="#Functions（执行类-API）剩余部分-1" class="headerlink" title="Functions（执行类 API）剩余部分"></a>Functions（执行类 API）剩余部分</h3><p><code>wwise.ui</code>、<code>wwise.waapi</code>、<code>wwise.debug</code> 中的功能比较简单，大家可自行尝试。<br><code>soundengine</code> 需要用实例来演示一下使用方法，关于 Game Object 注册的部分容易让人费解。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="Topic（订阅类-API）-1"><a href="#Topic（订阅类-API）-1" class="headerlink" title="Topic（订阅类 API）"></a>Topic（订阅类 API）</h3><p>对订阅 Topics 类 API 来说，<strong>所有的调用都是需要回调函数来指定返回值的</strong>。之所以这样设计，是因为订阅执行后程序会阻塞并等待返回值，并不像执行类 API 单独一次远程调用结束就了事。<br>因此我们需要一个回调函数，指明当订阅的信息发生时用谁来接受产生的信息，以便于当信息发生时执行此函数。关于 Topics 类的回调函数传参办法，请参考第一篇中的示例代码（<a href="https://blog.audiokinetic.com/everyone-can-use-waapi-overview/）。" target="_blank" rel="noopener">https://blog.audiokinetic.com/everyone-can-use-waapi-overview/）。</a><br>订阅类 API 的功能大多非常简单，这里就不单独放出示例了。但对于订阅类 API 有个问题，调用时会阻塞程序，所以如果想同时让程序做别的功能，可把这部分调用进行多线程设计。</p><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2><p>在下一篇文章中会迎来本系列文章的结尾，文章主体会分为两部分。<br>首先，我们会用实例体验一下 WAAPI 在具体工作中的应用。另外，作为补充，我们会讨论一下在游戏引擎中如何调用 WAAPI，这部分是文档中比较薄弱的内容</p>]]></content>
      
      
      
        <tags>
            
            <tag> 音频编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>补完 Reaper 效率链的最后一环（二）使用 reapy</title>
      <link href="/2020/09/21/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20ReaScript%20%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%94%B9%E5%96%84%20Reaper%20%E6%95%88%E7%8E%87%EF%BC%9F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/09/21/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20ReaScript%20%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%94%B9%E5%96%84%20Reaper%20%E6%95%88%E7%8E%87%EF%BC%9F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>在《补完 Reaper 效率链的最后一环（一）ReaScript 基础》中，我们分析了如何使用 Lua 编写脚本的全过程。并通过一个实例，<strong>把从抽象逻辑到最终的 GUI 脚本程序这一条开发的流程完整的跑通了一遍。</strong><br>在此相信读者已经有了一定的脚本开发基础，哪怕还没动手学习，应该也对脚本开发的流程有了大概的认知。<br>本系列教程的第二篇中，会讨论一下如何用 reapy 在 Reaper 外部对 ReaScript API 进行调用。通过使用 reapy，我们<strong>一方面能够获得更加 Python 的脚本开发体验。另一方面在某些需要用户避免接触 Reaper 而又需要其功能的场景下，可通过把脚本调用外置来解决这个需求。</strong></p><blockquote><p>本系列文章阅读需要的前置知识：</p><ul><li>有一定的英文基础，能够看懂 ReaScript 文档。最好有在 Cockos 论坛上搜索答案的能力。</li><li>有 Python 基础，会配置相应的开发环境，了解 PySimpleGUI 使用。</li><li>对 Reaper 的功能比较了解。</li></ul></blockquote><p>本文目录：</p><p>[toc]</p><h2 id="缘起：对暴雪声音设计师工作流的思考"><a href="#缘起：对暴雪声音设计师工作流的思考" class="headerlink" title="缘起：对暴雪声音设计师工作流的思考"></a>缘起：对暴雪声音设计师工作流的思考</h2><h3 id="1-1-Wwise-Tour-2016-Blizzard-Overwatch"><a href="#1-1-Wwise-Tour-2016-Blizzard-Overwatch" class="headerlink" title="1.1. Wwise Tour 2016 - Blizzard Overwatch"></a>1.1. Wwise Tour 2016 - Blizzard Overwatch</h3><p>在 Wwise Tour 2016 中，守望先锋的开发者分享了关于音频设计的内容。<br>当他们演示 TED 引擎时，通过按住 Record 按钮录制语音，引擎就自动完成了一系列调用。其所执行的步骤大概是是完成录音、调用 Reaper 进行处理、调用 LMB（现在的 AMB）进行响度处理、调用 Wwise 生成 WEM 等。要知道去年我对这种自动化流程还不太熟悉，这种流畅的工作流让我印象非常深刻。</p><h3 id="1-2-我的思索"><a href="#1-2-我的思索" class="headerlink" title="1.2. 我的思索"></a>1.2. 我的思索</h3><p>他们调用 Reaper 的方法我非常感兴趣，因当时知识有限，不知还有命令行的用法（Reaper、LMB、Wwise 都支持 Command Line），所以甚至想到了会不是走 Win32 API 调用 Reaper 时做到隐藏页面再调 ReaScript API 来做到的……<br>因为去年只会 Python，就想着怎么用它来玩 ReaScript，所以<strong>在探索过程中找到了 reapy</strong>，发现它大大增加了 Python 程序员使用 ReaScript 时的易用性。<br><strong>这段探索故事的结尾，正是本篇文章的来源。</strong></p><h2 id="为什么要用-reapy？"><a href="#为什么要用-reapy？" class="headerlink" title="为什么要用 reapy？"></a>为什么要用 reapy？</h2><h3 id="2-1-ReaScript-支持的三种脚本语言对比"><a href="#2-1-ReaScript-支持的三种脚本语言对比" class="headerlink" title="2.1. ReaScript 支持的三种脚本语言对比"></a>2.1. ReaScript 支持的三种脚本语言对比</h3><p>在上篇文章中我们提到，除了支持 C/C++，<strong>ReaScript 支持的三门脚本语言分别是自有的 EEL、Lua 及 Python。</strong><br>对于使用 Python 来进行 ReaScript 开发来说，除了会性能略差于 EEL 和 Lua，使用 Tkinter 这种 GUI 框架也容易出现问题（尤其是 macOS 中）。但我们也知道，<strong>Python 有着海量的第三方资源，reapy 正是我挖掘到的一个很棒的 ReaScript Wrapper。</strong><br>首先我们来看看这三种脚本语言的 API 调用名称，它们是略有区别的，拿测试 API 连通性的 <code>APITest()</code> 举例：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EEL2:</span><br><span class="line">APITest();</span><br><span class="line"></span><br><span class="line">Lua:</span><br><span class="line">reaper.APITest()</span><br><span class="line"></span><br><span class="line">Python:</span><br><span class="line">RPR_APITest()</span><br></pre></td></tr></table></figure></p><p>可以发现，只有 EEL 保持了最简略的 API 调用名称。而 Lua 需要加入 <code>reaper.</code> 的前缀（当然，对于 Lua 我们可以通过加入一行 <code>local r = reaper</code> 让脚本写法变成 <code>r.APITest()</code>，<strong>这也是 Moy 老师文章中所提到的小技巧，与 Python 的 as 重命名同理</strong>）。<br>但是对于 Python 的 API 而言，这个 RPR_ 的讨厌前缀就很难在使用时去掉了。而这篇文章所介绍的 reapy 却可以轻松去掉这个前缀，这只是它的一个小优点。</p><h3 id="2-2-reapy-的优势"><a href="#2-2-reapy-的优势" class="headerlink" title="2.2. reapy 的优势"></a>2.2. reapy 的优势</h3><p>就像上面提到的，使用 reapy 可以让 Python 调用 ReaScript 变的更为简单，因为它有这些优势：</p><ol><li><strong>API 调用名称更简单，ReaScript 中毫无用处的 RPR_ 前缀被去掉了，</strong>而且对 ReaScript 进行了优雅且 Pythonic 的装饰。同样的调用控制台输出消息功能，以前需要使用 <code>RPR_ShowConsoleMsg(&quot;Hello world!&quot;)</code>，现在只需一句 <code>reapy.print(&quot;Hello world!&quot;)</code> 即可做到。更加简单，也更加的面向对象。</li><li><strong>在 Reaper 内外均可调用，并解决了在 Reaper 外调用 ReaScript 性能差的问题。</strong>因为 ReaScript 通过外部 API 调用时会运行在 defer loop 当中，这会严重影响复杂脚本的性能。为此，reapy 提供了环境管理器 <code>reapy.inside_reaper</code> 来解决这个问题。</li><li><strong>更新及时</strong>，另一个 ReaScript Python 装饰 beyond.Reaper 在 V27 后已经多年不更新，ReaPyLib 也是停更很久，而 reapy 在本文写作的上一个月还在持续更新。</li><li><strong>具有结构分类</strong>，原始的 ReaScript API 就是一团乱麻，而 reapy 为其进行了逻辑完善的分类排布。</li><li>外部调用会更稳定，因为 ReaScript 的设计原因，用 Python 在 Reaper 内部引用外部库会有或多或少的问题。</li></ol><h2 id="配置开发环境"><a href="#配置开发环境" class="headerlink" title="配置开发环境"></a>配置开发环境</h2><p>老规矩，请大家自行参考这些优质文章配置相关开发环境。对于开发工具也并非强求，用自己喜欢的开发工具均可。</p><h3 id="3-1-Windows-下配置"><a href="#3-1-Windows-下配置" class="headerlink" title="3.1. Windows 下配置"></a>3.1. Windows 下配置</h3><h4 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h4><p><a href="https://segmentfault.com/a/1190000022797661" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022797661</a></p><h4 id="配置-Anaconda"><a href="#配置-Anaconda" class="headerlink" title="配置 Anaconda"></a>配置 Anaconda</h4><p><a href="https://zhuanlan.zhihu.com/p/25198543" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25198543</a></p><h4 id="配置-VS-Code-开发环境"><a href="#配置-VS-Code-开发环境" class="headerlink" title="配置 VS Code 开发环境"></a>配置 VS Code 开发环境</h4><p><a href="https://zhuanlan.zhihu.com/p/30324113" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30324113</a></p><h3 id="3-2-macOS-下配置"><a href="#3-2-macOS-下配置" class="headerlink" title="3.2. macOS 下配置"></a>3.2. macOS 下配置</h3><h4 id="安装-Anaconda-1"><a href="#安装-Anaconda-1" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h4><p><a href="https://blog.csdn.net/lq_547762983/article/details/81003528" target="_blank" rel="noopener">https://blog.csdn.net/lq_547762983/article/details/81003528</a></p><h4 id="配置-Anaconda-1"><a href="#配置-Anaconda-1" class="headerlink" title="配置 Anaconda"></a>配置 Anaconda</h4><h4 id="配置-VS-Code开发环境"><a href="#配置-VS-Code开发环境" class="headerlink" title="配置 VS Code开发环境"></a>配置 VS Code开发环境</h4><p>此两步可参考上面的链接，操作类似。</p><h3 id="3-3-在-Reaper-中配置-Python-的路径"><a href="#3-3-在-Reaper-中配置-Python-的路径" class="headerlink" title="3.3. 在 Reaper 中配置 Python 的路径"></a>3.3. 在 Reaper 中配置 Python 的路径</h3><p><strong>注意，reapy 声称能够帮助用户配置 Reaper 中的 Python 路径，所以可先执行 3.4. 中的提到的 <code>reapy.configure_reaper()</code>，如果配置未成功再按本段内容手工配置。</strong><br>在 Reaper 中想使用 Python 需要配置一些参数:</p><ol><li>打开 Options - Preferences 中的 ReaScript，在窗口中勾选 Enable Python to use with ReaScript，以打开 Python 支持。</li><li>因为 Reaper 并不知道 Python 的所在，自动检测如果未检测出 Python，可能还需指定你的 Python 文件。</li></ol><p>下面是在 Windows 和 macOS 的配置截图，供大家参考。其中使用的环境都是 Anaconda 中的 Python，直接安装的 Python 也可按照相同的方法指定环境路径并定位所需的 Python 文件。<br><img src="/images/macOS%20%E9%85%8D%E7%BD%AE.png" alt="macOS 配置"><br>macOS 配置<br><img src="/images/Windows%20%E9%85%8D%E7%BD%AE.png" alt="Windows 配置"><br>Windows 配置</p><h4 id="3-4-安装-reapy-并测试"><a href="#3-4-安装-reapy-并测试" class="headerlink" title="3.4. 安装 reapy 并测试"></a>3.4. 安装 reapy 并测试</h4><p>因为 conda-forge 中没有 reapy，所以 reapy 可以通过以下两种方式安装：</p><ol><li>没有 Conda 的话，直接执行 <code>pip install python-reapy</code> 在本地 pip 环境中安装 reapy。</li><li>有 Conda 的话，同样执行上述命令，在 Conda 的 pip 环境中安装 reapy。</li></ol><p>安装完毕之后，打开 Reaper，在终端中执行 <code>python -c &quot;import reapy; reapy.configure_reaper()&quot;</code>。这一步的目的是为了初始化 reapy，同时添加脚本 activate_reapy_server.py，它是 reapy 在 Reaper 外部使用的前提，会在外部调用的时候持续保持运行。<br>作为测试，在 Reaper 内外均可执行以下语句观察执行效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reapy</span><br><span class="line">reapy.test_api()</span><br></pre></td></tr></table></figure></p><p><img src="/images/%E5%9C%A8%E5%86%85%E5%A4%96%E5%90%8C%E6%97%B6%E6%89%A7%E8%A1%8C.png" alt="在内外同时执行"><br>在 VS Code 和 Reaper 内分别执行同样的代码<br>我们会发现，都得到了一样的返回结果，这代表 reapy 已经配置成功：<br><img src="/images/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-09-18%2002.13.46.png" alt="屏幕快照 2020-09-18 02.13.46"><br>测试结果</p><h2 id="reapy-解析"><a href="#reapy-解析" class="headerlink" title="reapy 解析"></a>reapy 解析</h2><h3 id="4-1-开发理念"><a href="#4-1-开发理念" class="headerlink" title="4.1. 开发理念"></a>4.1. 开发理念</h3><p>reapy 由 Roméo Després 开发，他现在是华纳音乐（法国）的数据分析师，也曾在 IRCAM 工作过。<br>reapy 的核心开发理念就是为了解决 ReaScript 在 Python 下糟糕的使用体验，比如毫不 Pythonic 的 API 设计，通过修饰完成了面向对象层的重设计。这也是目前唯一一个活跃的 Python 版 ReaScript 项目。<br><strong>对于普通用户而言，最直观的感受就是部分常用 API 变的简单易用了，</strong>因为 API 经过装饰后的易用性变的非常好。而未经过处理的 API 的也可继续使用不带 RPR_ 前缀的原名进行调用，<br>对于不想费时间学习 EEL 或 Lua 的 Python 程序员来说，reapy 是个非常友善的切入点。<br><strong>当然，reapy 也有缺点。</strong>因为现在都没开发到 V1.0 版本，所以只有主要的 API 完成了装饰，根据需求复杂程度可能还需混合使用新旧 API。</p><h3 id="4-2-简单实例"><a href="#4-2-简单实例" class="headerlink" title="4.2. 简单实例"></a>4.2. 简单实例</h3><p>在 3.4. 小节中我们提到了测试 API 的用法，在原生的 Python 版 ReaScript 中的 <code>RPR_APITest()</code>，在 reapy 中只需写成 <code>reapy.test_api()</code> 即可。<br>大家还记得，上一篇文章中用脚本复刻了一条 Action 的功能 <code>Item edit: Move position of item under mouse to edit cursor</code>，这是之前的 Lua 版代码：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> r = reaper</span><br><span class="line"></span><br><span class="line">r.Undo_BeginBlock()</span><br><span class="line"></span><br><span class="line">item = r.BR_GetMouseCursorContext_Item()</span><br><span class="line">cursor_pos = r.GetCursorPosition()</span><br><span class="line">r.SetMediaItemInfo_Value(item, <span class="string">"D_POSITION"</span>, cursor_pos)</span><br><span class="line"></span><br><span class="line">r.Undo_EndBlock()</span><br></pre></td></tr></table></figure></p><p>如果用 Python 配合原生 ReaScript API 来写会是这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RPR_Undo_BeginBlock()</span><br><span class="line"></span><br><span class="line">item = BR_GetMouseCursorContext_Item()</span><br><span class="line">cursor_pos = RPR_GetCursorPosition()</span><br><span class="line">RPR_SetMediaItemInfo_Value(item, <span class="string">"D_POSITION"</span>, cursor_pos)</span><br><span class="line"></span><br><span class="line">RPR_Undo_EndBlock()</span><br></pre></td></tr></table></figure></p><p>现在我们用 reapy 在 Reaper 内重写一遍代码，看看与之的版本有什么区别。当然，这段代码在 Reaper 外执行也是可以的，只是在外面执行时 <code>r.perform_action(40528)</code> 这句是没有意义的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reapy <span class="keyword">as</span> r</span><br><span class="line"><span class="keyword">from</span> reapy <span class="keyword">import</span> reascript_api <span class="keyword">as</span> rpr</span><br><span class="line"><span class="comment"># 获取当前工程</span></span><br><span class="line">proj = r.Project()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Undo Block 开始</span></span><br><span class="line">proj.begin_undo_block()</span><br><span class="line"><span class="comment"># reapy 中使用第三方 API 有些问题（虽然老版文档说 reascript_api 中可用所有的第三方 API），所以这里使用 reapy 装饰后的 Main_OnCommand 执行 Action（Item: Select item under mouse cursor）以获取鼠标下的对象</span></span><br><span class="line">r.perform_action(<span class="number">40528</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取鼠标下的对象并对返回值加以处理为 str，给 SetMediaItemInfo_Value 的参数做好准备。</span></span><br><span class="line">item = str(proj.get_selected_item(<span class="number">0</span>))</span><br><span class="line">item = eval(item.strip(<span class="string">'Item()'</span>))</span><br><span class="line"><span class="comment"># 获取当前游标位置</span></span><br><span class="line">cursor_pos = proj.cursor_position</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以前的 API 也可在 reascript_api 直接引用，目前 reapy 还没加入 item.set_info_value(param_name, param_value)语法，所以这步略显麻烦</span></span><br><span class="line">rpr.SetMediaItemInfo_Value(item, <span class="string">"D_POSITION"</span>, cursor_pos)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Undo Block 结束</span></span><br><span class="line">proj.end_undo_block()</span><br></pre></td></tr></table></figure></p><p>从这段重写的代码中可看出：</p><ol><li>大多数 API 都被装饰过了，调用起来更符合 Python 的风格，也更加面向对象。</li><li>对于没装饰的 API，也提供了去除恼人前缀的调用方式。</li></ol><p>对于一个还在持续开发中的第三方库来说，我还是非常期待它做到 V1.0 能做到多么完善。但即使是如此，现在的使用体验也很不错。</p><h3 id="4-3-reapy-文档的阅读方法-Translation-Table"><a href="#4-3-reapy-文档的阅读方法-Translation-Table" class="headerlink" title="4.3. reapy 文档的阅读方法 - Translation Table"></a>4.3. reapy 文档的阅读方法 - Translation Table</h3><p><strong>ReaScript 的文档非常杂乱无章，</strong>很多时候只能靠搜索碰运气，所以第一篇文中我们提到了优化版文档以供大家更快的查询所需 API。而对于 reapy，它也有一套自己的文档。<br>地址：<a href="https://python-reapy.readthedocs.io/en/latest/api_table.html" target="_blank" rel="noopener">https://python-reapy.readthedocs.io/en/latest/api_table.html</a><br><img src="/images/reapy%20%E6%96%87%E6%A1%A3.png" alt="reapy 文档"></p><p><strong>在文档左边可以看到入门指南的 Api guide、安装指南、模块索引等章节，通常查询 API 需要面对的章节就是我给出的 Translation Table。</strong><br>reapy 的 API 分类是根据 Mespotine 的 ReaScript API 分类而定，不过可惜 Mespotine 的 API 分类原网页已经失效。<br>往下翻，我们会看到 API 中存在对应关系，<strong>右边的列代表了 reapy 中的装饰 API</strong>，而左边代表 ReaScript 中的原 API。<br><img src="/images/%E6%96%87%E6%A1%A3%E5%AE%9E%E4%BE%8B2.png" alt="文档实例2"></p><p>使用 reapy 来开发脚本，在 Translation Table 中应优先使用 reapy 版的 API 以获得更好的 Python 编程体验。<br>目前的 reapy 还没有完成全部的 API 装饰，不过绝大多数常用的都已完成。其中的函数有两种简单用法：</p><ol><li>已经具有 reapy 装饰的，执行 <code>reapy.function_name()</code>。当然，也可以重命名 reapy 后执行如 <code>r.function_name()</code> 这样的语句。</li><li>还没有 reapy 装饰的，可执行 <code>from reapy import reascript_api</code> 以从 reascript_api 中导入子模块后再使用。因为此子模块名字较长，可根据自己的喜好重命名，比如命名为 rpr，那么函数的调用就是 <code>rpr.raw_function_name()</code>。</li></ol><h3 id="4-4-reapy-文档的阅读方法-Module-Index"><a href="#4-4-reapy-文档的阅读方法-Module-Index" class="headerlink" title="4.4. reapy 文档的阅读方法 - Module Index"></a>4.4. reapy 文档的阅读方法 - Module Index</h3><p><strong>此外，reapy 的设计重点是让 ReaScript 更加的 Pythonic，</strong>所以使用时会发现它存在一种分层级的 API 管理逻辑。比如当你对 audio 或 midi 类对象执行的操作时，可以直接从 Module Index 找到对应的对象看看它都封装了什么方法，之后直接对对象执行相应的方法即可，不必再像传统的 ReaScript 设计流程那样把 Get 出的对象反复的作为参数传递。<br>我目前的使用习惯是以 Translation Table 为主要 API 搜索页面，Module Index 则在对某一类对象进行操作时去参考它目前封装的功能。<br><img src="/images/%E6%96%87%E6%A1%A3%E5%B1%82%E7%BA%A7.png" alt="文档层级"><br>文档中的 Module Index</p><p>下面通过实例看看这些层级的使用，我引用一些比较常用的 API 以供参考。<br>当执行 <code>import reapy</code>，会默认导入 reapy.core.reaper.reaper 内所有的函数，是常见工程级操作的顶层层级。<strong>事实上 reapy 的层级位置在文档中是 reaper.core.reaper，所以以此开头的 audio、defer、midi、ui 等需通过 reapy.audio、reapy.midi 的方法来调用。</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reapy <span class="keyword">as</span> r</span><br><span class="line"></span><br><span class="line"><span class="comment"># reapy 顶层封装的功能</span></span><br><span class="line">r.print(<span class="string">"Hello Reaper!"</span>) <span class="comment"># 控制台输出</span></span><br><span class="line">r.clear_console() <span class="comment"># 清除控制台</span></span><br><span class="line">r.perform_action(action_id) <span class="comment"># 调用 Action</span></span><br><span class="line">r.open_project(filepath) <span class="comment"># 打开工程</span></span><br><span class="line">r.get_reaper_version() <span class="comment"># 获取 Reaper 版本</span></span><br><span class="line">r.set_global_automation_mode(mode) <span class="comment"># 设置全局 Automation 模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一种常见用法，以轨道对象举例，首先要获取一个轨道对象，可通过名字或轨道编号获取</span></span><br><span class="line">track = r.proj.tracks[num <span class="keyword">or</span> name]</span><br><span class="line"><span class="comment"># 获取轨道对象后，就可对它执行 reapy.core.Track() 类中封装的所有方法了。对 Item 对象来说也是同理</span></span><br><span class="line">track.GUID <span class="comment"># 获取 GUID</span></span><br><span class="line">track.add_item(start=<span class="number">0</span>, end=<span class="keyword">None</span>, length=<span class="number">0</span>) <span class="comment"># 添加 item 对象并返回它</span></span><br><span class="line">track.delete() <span class="comment"># 删除轨道</span></span><br><span class="line">track.get_info_value(param_name) <span class="comment"># 获取指定属性值</span></span><br><span class="line">track.set_info_value(param_name, param_value) <span class="comment"># 设置指定属性值</span></span><br><span class="line">track.solo() <span class="comment"># Solo 轨道</span></span><br><span class="line">track.mute() <span class="comment"># Mute 轨道</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 MIDI 对象进行各种操作</span></span><br><span class="line">r.midi.get_active_editor() <span class="comment"># 返回活动的 MIDI 编辑器</span></span><br><span class="line">r.midi.get_input_names() <span class="comment"># 获得所有 MIDI 输入通道名</span></span><br><span class="line">r.midi.get_n_inputs() <span class="comment"># 返回 MIDI 输入通道数</span></span><br><span class="line">r.midi.reinit() <span class="comment"># 重置所有 MIDI 设备</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对包络线对象进行各种操作</span></span><br><span class="line">r.Envelope.name() <span class="comment"># 返回包络线名字</span></span><br><span class="line">r.Envelope.get_value(time, raw=<span class="keyword">False</span>) <span class="comment"># 获取包络线指定时间点上的值</span></span><br><span class="line">r.Envelope.n_points() <span class="comment"># 获取包络线中的点位数</span></span><br><span class="line">r.Envelope.add_item(position=<span class="number">0.0</span>, length=<span class="number">1.0</span>, pool=<span class="number">0</span>) <span class="comment"># 创建新的包络线对象</span></span><br></pre></td></tr></table></figure></p><p><strong>reapy.tools，其中的 <code>inside_reaper()</code> 用于提高外部调用 ReaScript 时的性能。</strong>因为 ReaScript 外部引用是运行在 defer loop 之中的，执行效率比 Native ReaScript 差很多，只有每秒不到60次的执行效率，在进行重复次数很多的操作时会有很大性能影响。<br>为了解决这个问题，需要使用 <code>reapy.tools.inside_reaper</code> 模块，它的功能是把这部分代码通过自带的服务器脚本放到 Reaper 内部环境执行，再把结果取回外部。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reapy <span class="keyword">as</span> r</span><br><span class="line"></span><br><span class="line">project = r.Project() <span class="comment"># 获取当前工程对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求1000次工程的 BPM，直接在外部调用需要半分钟以上</span></span><br><span class="line">bpms = [project.bpm <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 inside_reaper() 后命令会从内部运行这段代码，只需0.1秒</span></span><br><span class="line"><span class="keyword">with</span> r.inside_reaper():</span><br><span class="line">     bpms = [project.bpm <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br></pre></td></tr></table></figure></p><p><code>reapy.config</code> 内定义了有关 reapy 开关和 Web 接口的内容，普通用户可以不用在意。<br><code>reapy.errors</code> 包括各种报错信息，可与 Python 的异常处理语句合用。</p><h2 id="实现一个简单的根据文件名导入-Reaper-的-GUI-程序"><a href="#实现一个简单的根据文件名导入-Reaper-的-GUI-程序" class="headerlink" title="实现一个简单的根据文件名导入 Reaper 的 GUI 程序"></a>实现一个简单的根据文件名导入 Reaper 的 GUI 程序</h2><p>我们都知道，批量的文件处理（比如对于游戏语音对白）所需的导入文件，均匀设置对象间隔及按区域导出这些功能对于 Reaper 来说是非常简单就能做到的。<br>为了演示 reapy 在外部的完整运行效果，<strong>假设一个需求，使用 ReaScript 导入文件，并能够要根据需求设定不同的属性值及效果器。</strong>通过让录音师进行规范的命名，在导入 Reaper 的时候可以轻松做到这件事。<strong>在这里设定文件名的格式为 <code>&lt;ItemName&gt;_&lt;Volume&gt;_&lt;FX&gt;.wav</code></strong></p><ul><li>注意：出于篇幅限制，只在示例文件名中定义一个属性和一个效果器，有更多的需求只需扩展代码即可。对于直接引入效果器链的方法不加以讨论，有兴趣的朋友可以自行改写 ReaPack 中的脚本 <code>mpl_Add FXChain to selected track</code>，将其从文件浏览器中选择效果器链的方法改成引入用户指定的效果器链文件名即可。</li></ul><h3 id="5-1-抽象功能逻辑"><a href="#5-1-抽象功能逻辑" class="headerlink" title="5.1. 抽象功能逻辑"></a>5.1. 抽象功能逻辑</h3><p>为了演示，首先建立两个示例文件：<br><code>Player_Heavy_Hit_12_-3_ReaEQ.wav</code><br><code>UI_Bright_Button_01_-5_ReaDelay.wav</code><br>音效文件的命名对于下划线使用的非常广泛，这里假设在已有文件名的最后加入两个下划线后缀，分别指定为音量与效果器的属性。<br>于是我们抽象出功能逻辑：</p><ol><li>使用 Python 读取文件名中的信息，并且暂存到容器中</li><li>使用 Reaper 在当前工程中插入新轨道</li><li>对轨道设置属性</li><li>对轨道设置 FX</li></ol><h3 id="5-2-选用-API"><a href="#5-2-选用-API" class="headerlink" title="5.2. 选用 API"></a>5.2. 选用 API</h3><ol><li>使用 Python 读取文件名中的信息，并且暂存到容器中：略</li><li>使用 Reaper 在当前工程中插入新轨道：InsertMedia()</li><li>对轨道设置属性：set_info_value()</li><li>对轨道设置 FX：add_fx()</li></ol><h3 id="5-3-实现功能代码"><a href="#5-3-实现功能代码" class="headerlink" title="5.3. 实现功能代码"></a>5.3. 实现功能代码</h3><p>使用 Python 读取文件名中的信息，暂存到一个提取好信息的字典中，并把所有字典放进一个列表中方便管理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">dict_list = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每一个文件进行参数获取，并存为一个字典</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dict</span><span class="params">(input_path)</span>:</span></span><br><span class="line">    <span class="comment"># 源文件名，如 `UI_Bright_Button_01_-5_C1.wav`</span></span><br><span class="line">    raw_file_name = input_path.split(os.sep)[<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># 指定音量</span></span><br><span class="line">    volume = raw_file_name.split(<span class="string">"_"</span>)[<span class="number">-2</span>]</span><br><span class="line">    <span class="comment"># 指定效果器链</span></span><br><span class="line">    fx = raw_file_name.split(<span class="string">"."</span>)[<span class="number">0</span>].split(<span class="string">"_"</span>)[<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># 原文件名中的完整文件名，如 `UI_Bright_Button_01.wav`</span></span><br><span class="line">    new_file_name = raw_file_name.rsplit(<span class="string">'_'</span>, <span class="number">2</span>)[<span class="number">0</span>] + <span class="string">"."</span> + input_path.split(<span class="string">"."</span>)[<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># 参数字典</span></span><br><span class="line">    info_dict = &#123;<span class="string">"path"</span>: input_path, <span class="string">"new_file_name"</span>: new_file_name, <span class="string">"volume"</span>: volume, <span class="string">"fx"</span>: fx&#125;</span><br><span class="line">    dict_list.append(info_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对文件夹内所有 wav 文件执行操作，并调用 get_dict() 函数提取信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file</span><span class="params">(input_folder)</span>:</span></span><br><span class="line">    file_end = []</span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(input_folder):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(input_folder):</span><br><span class="line">            file_end.append(os.path.splitext(file)[<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">'.wav'</span>):</span><br><span class="line">                get_dict(input_folder + os.sep + file)</span><br><span class="line">        insert_media(dict_list)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'.wav'</span> <span class="keyword">in</span> file_end:</span><br><span class="line">            sg.popup(<span class="string">'Processing Complete.'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sg.popup(<span class="string">'No wave file be found!'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sg.popup(<span class="string">'Check your input!'</span>)</span><br></pre></td></tr></table></figure></p><p>从该文件夹的字典列表分别读出每个文件的属性，准备对对应的属性进行设置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reapy</span><br><span class="line"><span class="keyword">from</span> reapy <span class="keyword">import</span> reascript_api <span class="keyword">as</span> rpr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_media</span><span class="params">(dict_list)</span>:</span></span><br><span class="line">    <span class="comment"># 获取当前工程</span></span><br><span class="line">    proj = reapy.Project()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> dict <span class="keyword">in</span> dict_list:</span><br><span class="line">        <span class="comment"># 从列表中的每个字典里读取相应数据</span></span><br><span class="line">        path = dict[<span class="string">"path"</span>]</span><br><span class="line">        new_file_name = dict[<span class="string">"new_file_name"</span>]</span><br><span class="line">        volume = dict[<span class="string">"volume"</span>]</span><br><span class="line">        fx = dict[<span class="string">"fx"</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 插入媒体到新轨道</span></span><br><span class="line">        rpr.InsertMedia(path, <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取轨道对象</span></span><br><span class="line">        num = proj.n_tracks - <span class="number">1</span></span><br><span class="line">        track = proj.tracks[num]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置轨道名，音量（含分贝换算及取小数），增加效果器</span></span><br><span class="line">        track.name = new_file_name.split(<span class="string">"."</span>)[<span class="number">0</span>]</span><br><span class="line">        track.set_info_value(<span class="string">"D_VOL"</span>, round((<span class="number">10</span> ** (int(volume) / <span class="number">20</span>)), <span class="number">2</span>))</span><br><span class="line">        track.add_fx(fx)</span><br></pre></td></tr></table></figure></p><p>设置 Render Matrix 并自动导出文件：<br>略，如感兴趣可参考 X-Raym 的 ReaScripts: Render Region Matrix Pack，他的脚本是图形界面中键鼠选取对象后再执行的，想在纯代码层面实现只需把这个多轨选择做到 API 里就行了。</p><h3 id="5-4-实现-GUI-代码"><a href="#5-4-实现-GUI-代码" class="headerlink" title="5.4. 实现 GUI 代码"></a>5.4. 实现 GUI 代码</h3><p>这里做一个最简单的文件夹选择器，并通过 popup 窗口以显示成功及报错信息。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gui</span><span class="params">()</span>:</span></span><br><span class="line">    layout = [  [sg.Text(<span class="string">'Browse Folders'</span>)],</span><br><span class="line">                [sg.Input(), sg.FolderBrowse(<span class="string">'Browse'</span>, key=<span class="string">'folder'</span>)],</span><br><span class="line">                [sg.Button(<span class="string">'Import'</span>), sg.Button(<span class="string">'Cancel'</span>)] ]</span><br><span class="line">    </span><br><span class="line">    window = sg.Window(<span class="string">'Reaper Importer'</span>, layout)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        event, values = window.read()</span><br><span class="line">        <span class="keyword">if</span> event <span class="keyword">in</span> (<span class="keyword">None</span>, <span class="string">'Cancel'</span>): </span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> event == <span class="string">'Import'</span>:</span><br><span class="line">            <span class="keyword">if</span> values[<span class="string">'folder'</span>]:</span><br><span class="line">                get_file(values[<span class="string">'folder'</span>])</span><br><span class="line">                sg.popup(<span class="string">'Done!'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sg.popup(<span class="string">'Choose some folder first!'</span>)</span><br><span class="line">    </span><br><span class="line">    window.close()</span><br></pre></td></tr></table></figure></p><h3 id="5-5-连接-GUI-代码与功能代码"><a href="#5-5-连接-GUI-代码与功能代码" class="headerlink" title="5.5. 连接 GUI 代码与功能代码"></a>5.5. 连接 GUI 代码与功能代码</h3><p>为了节省篇幅，函数体省略。因为这个程序比较简单，所以可不通过 <code>inside_reaper()</code> 改善性能。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"><span class="keyword">import</span> reapy</span><br><span class="line"><span class="keyword">from</span> reapy <span class="keyword">import</span> reascript_api <span class="keyword">as</span> rpr</span><br><span class="line">dict_list = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file</span><span class="params">(input_folder)</span>:</span></span><br><span class="line">    Function body</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dict</span><span class="params">(input_path)</span>:</span></span><br><span class="line">    Function body</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_media</span><span class="params">(list)</span>:</span></span><br><span class="line">    Function body</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gui</span><span class="params">()</span>:</span></span><br><span class="line">    Function body</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>    </span><br><span class="line">    gui()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><h3 id="5-6-运行结果"><a href="#5-6-运行结果" class="headerlink" title="5.6. 运行结果"></a>5.6. 运行结果</h3><p>建立一个新的工程并执行程序，可看到程序窗口已打开。<br><img src="/images/%E6%89%A7%E8%A1%8C%E5%89%8D.png" alt="执行前"><br>执行前<br>接下来浏览到测试文件的文件夹，并点击 Import。发现文件已经自动被导入（这两个文件是粘贴自同一文件，所以波形相同），并且已设置了音量（可见音量旋钮略往左）和挂载了设置的效果器。<br><img src="/images/%E6%89%A7%E8%A1%8C%E5%90%8E.png" alt="执行后"><br>执行后</p><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2><p>目前的两篇文章已经把 ReaScript 大概过了一遍，读者看后应该已有足够的基础去开发自己的脚本了。因为我暂时不准备在 EEL 上投入时间，所以这部分暂时不会涉及。<br>接下来《补完 Reaper 效率链的最后一环》专栏会有以下几个更新方向：</p><ol><li>开发技巧补遗，关于 API 的选用和复杂的脚本设计技巧还有很多值得谈的部分。</li><li>拆解优质脚本，与大家共同分析它们的代码。</li><li>分享我的自制脚本。</li></ol><p>如果大家有兴趣，欢迎持续关注！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reaper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>补完 Reaper 效率链的最后一环（一）ReaScript 基础</title>
      <link href="/2020/09/20/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20ReaScript%20%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%94%B9%E5%96%84%20Reaper%20%E6%95%88%E7%8E%87%EF%BC%9F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/09/20/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20ReaScript%20%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%94%B9%E5%96%84%20Reaper%20%E6%95%88%E7%8E%87%EF%BC%9F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>Reaper 的强大无需多言。无论是 Action List 中琳琅满目的功能，亦或是 SWS Extension 和 ReaPack 带来的超强拓展，对每一个从传统 DAW 转过来的人都是极大的惊喜。<strong>毕竟 Reaper 最大的问题不是它能不能做到，而是你能不能想到。</strong>通常你能想到的问题和需求，都能通过在 Reaper 找到对应功能或脚本来搞定。<br><strong>但你是否好奇过 ReaPack 中那些脚本是怎么写出来的？你是否曾不满于现有的脚本的功能？</strong>这篇文章会帮助你解决这些疑惑，让我们彻底从头学习一下脚本的构建。</p><blockquote><p>本系列文章阅读需要的前置知识：</p><ul><li>有一定的英文基础，能够看懂 ReaScript 文档。最好有在 Cockos 论坛上搜索答案的能力。</li><li>了解过一门编程语言，有 Lua 基础最好。零基础也不怕，我会快速讲解一下 Lua 语法基础，非常简单。</li><li>对 Reaper 的功能比较了解，并已安装好 ReaPack。</li><li>掌握基本的 GUI 设计知识。</li></ul></blockquote><p>本文目录：</p><p>[toc]</p><h2 id="ReaScript-基础"><a href="#ReaScript-基础" class="headerlink" title="ReaScript 基础"></a>ReaScript 基础</h2><h3 id="1-1-补完-Reaper-效率链的最后一环"><a href="#1-1-补完-Reaper-效率链的最后一环" class="headerlink" title="1.1. 补完 Reaper 效率链的最后一环"></a>1.1. 补完 Reaper 效率链的最后一环</h3><p><strong>既然 Reaper 现有的东西已经这么厉害，为什么还要学 ReaScript 来自己写脚本？</strong><br>其实我们很容易发现，在声音设计或者音乐混音的工作中，<strong>很多需求都需要去定制才能做到</strong>，只用现有的脚本和功能是远远不够的。<br>举个例子，在 WAAPI 中有通过“制表符分割文件”进行自动导入音频文件的 API，即通过文本文件中定义的文件名、文件路径、属性等信息，自动导入并创建 Wwise 中的对象。但显然，Reaper 本身没有功能能做到从文件中读取信息并创建轨道且设置相关属性的功能。<br><strong>我们先用脚本小白的思维做一下探索</strong>，试着搜索一下有没有人已经做过类似的脚本。</p><ul><li>X-Raym 曾做过一个 <code>Import tracks from file</code> 脚本，可以快速的从 txt 或 csv 文件中创建音轨，但这个脚本做不到同时导入音频文件，只能快速创建音轨标题。</li><li>继续搜索，会发现他还做过一个付费的脚本 <code>Import items and regions from CSV</code>，功能虽比上一个稍多一点，但也不做不到我们的要求。</li></ul><p><strong>当然，在这篇文章里我不会讨论搜索技巧，或者如何撞大运找到现成的轮子。</strong><br><strong>我们真正要思考的问题是：</strong></p><ol><li>现在有个现成的轮子无法满足我们，怎么在它的基础上增改代码以符合我们的需求？</li><li>如果真没现成的脚本，该如何从零搭个新的？</li></ol><p><strong>如果你对技术尚存追求，那么学习 ReaScript 就是你必修的一门 Reaper 功课。</strong></p><h3 id="1-2-为什么要做这系列教程"><a href="#1-2-为什么要做这系列教程" class="headerlink" title="1.2. 为什么要做这系列教程"></a>1.2. 为什么要做这系列教程</h3><p>在创作这篇文章之前，国内领域也有一些朋友做了关于 ReaScript 的教程。<strong>比如 Moy 老师曾做过几篇关于 ReaScript 的实例教学</strong>，在知乎、音频应用、声音设计论坛等社区中也有些朋友在分享自己所做的脚本。<br>之所以我还要做一系列新的教程，原因有几点：</p><ol><li><strong>这个领域应该有一套更友好且更系统的教程</strong>，尤其要解答初学者在学习与使用 ReaScript 时的一些疑惑。</li><li>补充一些重要的内容，比如<strong>阅读文档的方法、给脚本设计 UI、在 Reaper 外调用 ReaScript 等。</strong></li><li>奔着开源精神触发，<strong>我希望更多有创意的脚本被大家开发出来。</strong></li></ol><p>下面就让我们一起先从 ReaScript 基础开始。</p><h3 id="1-3-ReaScript-API-基础"><a href="#1-3-ReaScript-API-基础" class="headerlink" title="1.3. ReaScript API 基础"></a>1.3. ReaScript API 基础</h3><h4 id="1-3-1-简介"><a href="#1-3-1-简介" class="headerlink" title="1.3.1. 简介"></a>1.3.1. 简介</h4><p>ReaScript API 是 Reaper 中重要的功能补充，与 Action 的不同之处就是它更贴近底层。我们都知道，Reaper 的 Action 能瞬间完成一个具体的功能（这个功能实际上帮你一下子完成了多个功能步骤)。但在 API 中想是做到同样的效果，就要把这个功能拆解成<strong>细小步骤</strong>，并用代码实现每一步的操作后才能做到同样的事情。<br><strong>Action 和在 ReaPack 中下载的诸多脚本其实一样，本质上是一种对底层多步骤操作的封装。</strong>而我们“做脚本”这件事，就是重新封装属于我们自己的“功能想象”。<br>拿 <code>Item edit: Move position of item under mouse to edit cursor</code> 举例，当我们执行这个 Action，当前鼠标光标下的对象会直接移动到光标处，听起来似乎非常简单。<br><strong>但如果用脚本来实现，步骤就多了很多：</strong></p><ol><li>获取鼠标下的对象：<code>BR_GetMouseCursorContext_Item()</code></li><li>获取游标的位置：<code>GetCursorPosition()</code></li><li>把对象的左边缘移动到游标的位置：<code>SetMediaItemInfo_Value()</code></li></ol><p>可以看到，除了把这个 Action 拆成了三个步骤外，我还找到了对应的 API 功能，这是复刻这条 Action 的基础。<br>Reaper 脚本的原理，即<strong>要想办法把我们的需求不断拆解，最终达到每个细节步骤都能通过调用一条 API 完成（如上例所示）。</strong>最后再通过基本的程序结构为它们设计执行逻辑，就能得到具有功能性的脚本。</p><ul><li><strong>把大象放进冰箱需要三步，打开冰箱门，把大象放进去，把冰箱门关上。</strong></li></ul><p>很多人都听说过小品中的这句话，但可思考过它背后的逻辑？<strong>拆解一个看似想当然的行为，这也是脚本开发的基础逻辑。</strong><br>而事实上把大象放进冰箱里还有着很多前提：<br>冰箱（容器）能否装载这么大的动物（数据类型），这个大象是否需要麻醉（类似 Profiler 中时间点的概念），通过什么工具运载大象到冰箱里（中间变量，甚至压缩算法）……<br><strong>让读者有能力进行功能的拆解和找到对应的 API，这也是本系列文章所讲解的一个重点。</strong>我认如果你学明白这部分，剩下的组装程序与 GUI 开发其实也就没什么难度了。<br>Reaper 脚本开发的另一个优势在于已它已内置了编码工具，不需要配置开发环境就能直接在内部进行脚本编程（此处不包括 Python）。甚至，无需 Juce 这种框架就能进行插件（JSFX）的开发。<br><img src="/images/reaper%E5%BC%80%E5%8F%91.png" alt="reaper开发"></p><p>上图为我在脚本开发时的截图。虽图片被压缩，但仍容易看出，凭 Reaper 和 ReaPack 提供的开发工具，我们在 Reaper 中能获得从代码到 GUI 构建器一整套开发工作流。</p><h3 id="1-3-2-支持的编程语言"><a href="#1-3-2-支持的编程语言" class="headerlink" title="1.3.2. 支持的编程语言"></a>1.3.2. 支持的编程语言</h3><p>ReaScript 支持三种脚本编程语言，分别是 Reaper 自有的 EEL、Lua 和 Python（2.7-3.X）。其中 EEL 不仅可用于 ReaScript 的开发，亦可用于 JS 插件的开发。（ReaScript 对于 C/C++ 也有支持，但在本文暂不予讨论）。<br><strong>本文会着重讨论 ReaScript 通过 Lua 的实现。</strong>因为本人目前不熟悉 EEL，且 Python 在 Reaper 内的性能没有 EEL 或 Lua 好，亦无法实现 UI 或图形显示。<br>不过对于在 Reaper 外调用 API 我们会在下一篇有额外的讨论，在那里我们会用到 Python。</p><h3 id="1-4-简单实例"><a href="#1-4-简单实例" class="headerlink" title="1.4. 简单实例"></a>1.4. 简单实例</h3><p>既然是实例，我希望更有针对性。作为国际惯例，先从 Hello Reaper 开始。<br>这种基本的字符串输出实例的意义就是一条，代表你跑通了当前的开发环境。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reaper.ShowConsoleMsg(<span class="string">"Hello Reaper!"</span>)</span><br></pre></td></tr></table></figure></p><p><img src="/images/Hello%20Reaper.png" alt="Hello Reaper"><br>执行这句代码可看到如上的返回结果。</p><p>之后回过来看一下开头提到的那条 Action：<code>Item edit: Move position of item under mouse to edit cursor</code>。我们通过 ReaScript 复刻一下它的功能，这种学习方式会让你对它的功能实现过程认识的更加深刻。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">item = reaper.BR_GetMouseCursorContext_Item()</span><br><span class="line">cursor_pos = reaper.GetCursorPosition()</span><br><span class="line">reaper.SetMediaItemInfo_Value(item, <span class="string">"D_POSITION"</span>, cursor_pos)</span><br></pre></td></tr></table></figure></p><p>执行上面的脚本后，我们发现鼠标下面的对象如期望的移动到了光标处。<br>严格来说，这个脚本还需要加上 Undo_BeginBlock() 和 Undo_EndBlock() 以满足 Reaper 的撤销记录功能。否则执行脚本后会无法撤销，这些暂且不加以讨论。<br><strong>可能你还看不懂这部分代码，甚至不知道怎么执行它，不要担心，看完这篇文章后你就能轻松写出这样的脚本。</strong></p><h2 id="Lua-基础"><a href="#Lua-基础" class="headerlink" title="Lua 基础"></a>Lua 基础</h2><p><strong>为了照顾没接触过 Lua 的朋友，下面我们简单讲解一下它的基本语法。</strong>如果已有 Lua 基础，请直接跳到本文第三部分“如何阅读 ReaScript 文档”。<br>Lua 作为一门上手容易的的脚本语言，无论是在 ReaScript 开发还是在使用 xLua 这种热更新框架时都会用到。与 Python 类似，Lua 的语法并不复杂，学习成本很低。</p><h3 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1. 数据类型"></a>2.1. 数据类型</h3><p>nil：表示没有任何有效值。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 打印尚未赋值的变量 a，可得到返回值 nil</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- result: </span></span><br><span class="line"><span class="literal">nil</span></span><br></pre></td></tr></table></figure></p><p>boolean：在 Lua 中布尔值的假对应的只有 false 和 nil，其余所有的均为真（包括数字0）.<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">nil</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"0 = true"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"0 = false"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- result:</span></span><br><span class="line">boolean</span><br><span class="line"><span class="number">0</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>number：数字类型，在 Lua 5.2 之前均为双精度浮点型，在之后分为64位整型 integer 和双精度浮点型 float，但它们也属于 number 类型。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 分别输出不带小数点和带小数点的数字类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">3.0</span>))</span><br><span class="line"><span class="comment">-- 通过 math 模块判断数字是整型或浮点类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">type</span>(<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">type</span>(<span class="number">3.0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- result:</span></span><br><span class="line">number</span><br><span class="line">number</span><br><span class="line">integer</span><br><span class="line">float</span><br></pre></td></tr></table></figure></p><p>string：字符串，单引号或双引号均可定义字符串内容。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string1 = <span class="string">"string1"</span></span><br><span class="line">string2 = <span class="string">'string2'</span></span><br></pre></td></tr></table></figure></p><p>table：Lua 中的表与 Python 中的列表不同，table 还可以通过添加索引（数字或字符串）作为字典（关联数组）来使用.<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建空 table，</span></span><br><span class="line">tbl1 = &#123;&#125;</span><br><span class="line"><span class="comment">-- 直接初始化 table 并打印其中的元素，打印 table 指定索引之间的字符串。注意：Lua 的初始索引以1开始，而不是0。</span></span><br><span class="line">tbl2 = &#123;<span class="string">"obj1"</span>, <span class="string">"obj2"</span>, <span class="string">"obj3"</span>, <span class="string">"obj4"</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(tbl2[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">table</span>.<span class="built_in">concat</span>(tbl2, <span class="string">","</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建空 table，并指派一个键值对 a: 20</span></span><br><span class="line">associative_arrays = &#123;&#125;</span><br><span class="line">key = <span class="string">"a"</span></span><br><span class="line">associative_arrays[key] = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 打印 associative_arrays 中键值对，并分别通过变量 key 与字符串 a 来索引 table</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(associative_arrays) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">" : "</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(associative_arrays[key])</span><br><span class="line"><span class="built_in">print</span>(associative_arrays.a)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- result:</span></span><br><span class="line">obj1</span><br><span class="line">obj2,obj3</span><br><span class="line">a : <span class="number">20</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure></p><p>function：函数。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不含参数的函数：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add_numbers</span><span class="params">()</span></span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 含参数的函数：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add_numbers</span><span class="params">(a, b)</span></span></span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="built_in">print</span>(c)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>thread：线程，表示执行的独立线路，用于执行协同程序。<br>userdata：用户自定义数据类型，可将 C/C++ 的任意数据类型的数据存储到 Lua 变量中调用。</p><h3 id="2-2-逻辑判断"><a href="#2-2-逻辑判断" class="headerlink" title="2.2. 逻辑判断"></a>2.2. 逻辑判断</h3><p>if 语句：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a &lt; <span class="number">20</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a 小于20"</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>if…else 语句：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a &lt; <span class="number">20</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a 小于20"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a 大于20"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>if…elseif…else 语句：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">10</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a 的值为10"</span>)</span><br><span class="line"><span class="keyword">elseif</span>(a == <span class="number">20</span>)</span><br><span class="line"><span class="keyword">then</span>  </span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a 的值为20"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"没有匹配 a 的值"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h3 id="2-3-循环语句"><a href="#2-3-循环语句" class="headerlink" title="2.3. 循环语句"></a>2.3. 循环语句</h3><p>while 循环：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当 a 小于20时持续执行循环体</span></span><br><span class="line"><span class="keyword">while</span>(a &lt; <span class="number">20</span>)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a 的值为:"</span>, a)</span><br><span class="line">   a = a + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>数值 for 循环：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 没设置递增步长的 for 循环，每执行一次执行体后以1为单位递增 i</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>,<span class="number">5</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 以-1为递增步长的 for 循环，每执行一次执行体后以1为单位递增 -1</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">10</span>,<span class="number">1</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>泛型 for 循环：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"cherry"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 通过迭代器函数 ipairs 来遍历所有值</span></span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>repeat…until：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 持续执行循环体，直到 a 大于20时跳出循环</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a 的值是："</span>, a)</span><br><span class="line">   a = a + <span class="number">1</span></span><br><span class="line"><span class="keyword">until</span>(a &gt; <span class="number">20</span>)</span><br></pre></td></tr></table></figure></p><h3 id="2-4-循环控制语句"><a href="#2-4-循环控制语句" class="headerlink" title="2.4. 循环控制语句"></a>2.4. 循环控制语句</h3><p>break 语句：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 当 i 小于3时跳出循环体</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">10</span>,<span class="number">1</span>,<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>goto 语句：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设定 label</span></span><br><span class="line">::label:: <span class="built_in">print</span>(<span class="string">"a = "</span>, a)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当 a 小于3的时候跳转到 label</span></span><br><span class="line"><span class="keyword">if</span> a &lt; <span class="number">3</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">goto</span> label </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><h2 id="如何阅读-ReaScript-文档？"><a href="#如何阅读-ReaScript-文档？" class="headerlink" title="如何阅读 ReaScript 文档？"></a>如何阅读 ReaScript 文档？</h2><h3 id="3-1-原版文档与优化后文档的取舍"><a href="#3-1-原版文档与优化后文档的取舍" class="headerlink" title="3.1. 原版文档与优化后文档的取舍"></a>3.1. 原版文档与优化后文档的取舍</h3><h4 id="3-1-1-原版文档"><a href="#3-1-1-原版文档" class="headerlink" title="3.1.1. 原版文档"></a>3.1.1. 原版文档</h4><p>两种打开方法：</p><ol><li>打开 Help 菜单，点击 ReaScript documentation</li><li>直接访问 <a href="https://www.reaper.fm/sdk/reascript/reascripthelp.html" target="_blank" rel="noopener">https://www.reaper.fm/sdk/reascript/reascripthelp.html</a></li></ol><p>对于原版文档，建议大家采用第一种方法。官网的在线的 API 版本还停留在 Reaper 5 时代，时效性很差。<br><img src="/images/%E4%B8%91%E9%99%8B%E7%9A%84%20API%20%E6%96%87%E6%A1%A3.png" alt="丑陋的 API 文档"><br>丑陋的原版文档</p><p>不难发现，ReaScript API 原版文档过于简陋，排版很难看，不便于使用。<strong>但原版文档，尤其是本机自带的原版文档具有最佳的时效性。</strong></p><h4 id="3-1-2-X-Raym-版优化文档"><a href="#3-1-2-X-Raym-版优化文档" class="headerlink" title="3.1.2. X-Raym 版优化文档"></a>3.1.2. X-Raym 版优化文档</h4><p>为了解决原版文档过于简陋的问题，X-Raym 做了一个优化版本的文档：<br><a href="https://www.extremraym.com/cloud/reascript-doc/" target="_blank" rel="noopener">https://www.extremraym.com/cloud/reascript-doc/</a><br><img src="/images/x-raym%E7%89%88%20%E6%96%87%E6%A1%A3.png" alt="x-raym版 文档"></p><p>X-Raym 整理的这版文档的排版与格式都是上等，<strong>并人性化的在左侧放置了搜索框。</strong>这也是我主力推荐的版本。唯一的小缺点是更新稍有不及时，比如在本文发布的时间下 X-Raym 的这版文档停留在了5月3日。<br>如果有对文档时效性的需求（一般来说看这版足矣），还是请以官方文档为准。</p><h4 id="3-1-3-Mike-Lacey-版-Wiki-文档"><a href="#3-1-3-Mike-Lacey-版-Wiki-文档" class="headerlink" title="3.1.3. Mike Lacey 版 Wiki 文档"></a>3.1.3. Mike Lacey 版 Wiki 文档</h4><p>Mike Lacey 在09年创建了 Reaper Wiki，其中也包括 ReaScript Wiki，但很久未更新。除非有朋友对 Wiki 有执念，否则不推荐这版本。<br>地址：<a href="https://wiki.cockos.com/wiki/index.php/ReaScript" target="_blank" rel="noopener">https://wiki.cockos.com/wiki/index.php/ReaScript</a><br><img src="/images/%E8%8D%92%E5%BA%9F%E7%89%88%E6%96%87%E6%A1%A3.png" alt="荒废版文档"><br>许久不更新的 ReaScript Wiki</p><h3 id="3-2-如何在文档中找到想要的-API"><a href="#3-2-如何在文档中找到想要的-API" class="headerlink" title="3.2. 如何在文档中找到想要的 API"></a>3.2. 如何在文档中找到想要的 API</h3><p>ReaScript 的 API 数量庞大，算上扩展 API 近千个，显然是没有什么好方法去整理的。我曾试过通过思维导图进行分类，但因数量庞大，实在没有精力像 WAAPI 那样通过导图进行详细分类。<br>但是要知道，<strong>ReaScript 有些 API 可能你一辈子用不上，</strong>所以明确自己的目的，寻找自己需要的 API 才是对的，而不是被庞大的 API 列表所击打。<br><strong>一个简略且有效的文档查找步骤是：</strong></p><ol><li>在逻辑抽象阶段想明白自己要的功能是什么分类，并抽象出关键词，如<code>get</code>、<code>media</code>、<code>midi</code>、<code>takefx</code>等。</li><li>利用 X-Raym 版优化文档强大的搜索功能，通过组合词搜索找到目标 API。</li><li>在现有的脚本中查找功能相似的，学习它们的 API 调用。</li><li>善用 Google。</li></ol><h3 id="3-3-通过实例学习文档的阅读方法"><a href="#3-3-通过实例学习文档的阅读方法" class="headerlink" title="3.3. 通过实例学习文档的阅读方法"></a>3.3. 通过实例学习文档的阅读方法</h3><p>相信大家也发现 ReaScript 的脚本出了名的简略，我以富有代表性的 API 作为例子分析一下，先看 <code>GetTrackName</code> 这条 API 在文档中的介绍：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean retval, <span class="built_in">string</span> buf = reaper.GetTrackName(MediaTrack track)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Returns "MASTER" for master track, "Track N" if track has no name.</span></span><br></pre></td></tr></table></figure></p><p>根据文档我们可知，它的返回值有两个，一个是布尔类型的取回结果，一个是字符串类型的轨道名。文档中已注明特例的返回值，对于 master track 会返回 <code>MASTER</code>，如果轨道没有名字则会返回 <code>Track N</code>，看到这里似乎一切还很简单。<br><strong>但是请注意，它的参数是 <code>MediaTrack track</code>，如果你想当然的用鼠标选择一条轨道后就直接执行这条 API，并不会得到想要的轨道名，这是为什么？</strong><br>如果还记得“大象放进冰箱需要几步”就会明白，目前步骤细分的还不够。<strong>实际上这个 API 需要的参数是 MediaTrack 类型的轨道对象。</strong>所以如果想流畅使用 <code>GetTrackName</code>，先要想办法弄到这个 MediaTrack 类型的轨道对象。<br>通过在文档中搜索 MediaTrack，我们定位到另外一条 API：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MediaTrack reaper.GetTrack(ReaProject proj, integer trackidx)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- get a track from a project by track count (zero-based) (proj=0 for active project)</span></span><br></pre></td></tr></table></figure></p><p>终于，这条 API 的返回值是我们需要的 MediaTrack 对象，而它需要的输入值分别是工程编号及轨道编号。<br>我们用以下代码进行测试：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">track1 = reaper.GetTrack(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">track2 = reaper.GetTrack(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">retval1, name1 = reaper.GetTrackName(track1)</span><br><span class="line">retval2, name2 = reaper.GetTrackName(track2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(track1, track2)</span><br><span class="line"><span class="built_in">print</span>(retval1, name1)</span><br><span class="line"><span class="built_in">print</span>(retval2, name2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- result</span></span><br><span class="line">&lt;userdata: <span class="number">0x7fee19b28000</span>&gt;</span><br><span class="line">&lt;userdata: <span class="number">0x7fea89a58000</span>&gt;</span><br><span class="line"><span class="literal">true</span>  <span class="string">"Footsteps_Wood"</span></span><br><span class="line"><span class="literal">true</span>  <span class="string">"Track 1"</span></span><br></pre></td></tr></table></figure></p><p>由结果可见，我们成功的获取了轨道名。<br>实际上，<strong>通过这个例子你就已经学会了在 ReaScript API 阅读时的两个重要技巧：</strong></p><ol><li>当遇到不认识的参数时，要一步一步逆推出它的获取 API。</li><li>如果函数有不止一个返回值，需要用多个变量去接收其返回值。</li></ol><h2 id="通过实例学习如何创建带-UI-的-ReaScript-脚本"><a href="#通过实例学习如何创建带-UI-的-ReaScript-脚本" class="headerlink" title="通过实例学习如何创建带 UI 的 ReaScript 脚本"></a>通过实例学习如何创建带 UI 的 ReaScript 脚本</h2><p>其实通过“简单实例”与“通过实例学习文档的阅读方法”中的两段程序，我们已经走完了脚本开发的整套流程。但为了演示关于 GUI 设计的部分，我们做一个简单的程序来体验一下在 Reaper 中做 GUI 有多么容易。<br>绝大多数功能性脚本其实都不需要 GUI 的介入，但如果你要做一个 Variato（Nikola Lukic 开发的一个对选中区域内对象进行位置和属性随机化的插件）这样的工具。<strong>脚本工作时需要用户指定一些属性，那么这时候制作一个 GUI 就十分有必要了。</strong><br>为了让脚本有接收用户输入值需求，我们设计一个最简单的需求，把当前框选的所有 items 统一设置为用户需要的音量。</p><h3 id="4-1-如何打开-Reaper-中的开发环境？"><a href="#4-1-如何打开-Reaper-中的开发环境？" class="headerlink" title="4.1. 如何打开 Reaper 中的开发环境？"></a>4.1. 如何打开 Reaper 中的开发环境？</h3><p>在开始之前，我们先看看 Reaper 中会用到的开发环境，主要有两个。<br>其一是 ReaScript 自带的开发环境，第二是 ReaPack 中的交互式开发环境。<br><img src="/images/reascript%20editor.png" alt="reascript editor"><br>系统自带的脚本编辑器<br><img src="/images/%E4%BA%A4%E4%BA%92%E5%BC%8FLua.png" alt="交互式Lua"><br>cfillion 开发的 Interactive ReaScript<br>不难看出，系统自带的脚本编辑器会是我们开发时的主力工具。<br><strong>而Interactive ReaScript 作为交互式开发环境，更多是为了让我们方便试用 Lua 命令而开发。</strong>如果你想快速的尝试一些 API 功能，而不想打开编辑器大费周章，建议你使用这个。<br><strong>如果想在 VS Code 中进行开发，</strong>可安装 Lokasenna 开发的 Reaper tools for Visual Studio Code 进行自动补全，不过此版本已经两年未更新新的 API。我更建议使用 slsenseless 开发的 ReaScriptDocParser，与现有文档的同步速度会更好。这两者对 ReaScript 所支持的所有语言都具有自动补全，可按需选用。<br>Reaper tools for Visual Studio Code：<a href="https://github.com/jalovatt/reaper-vs-code" target="_blank" rel="noopener">https://github.com/jalovatt/reaper-vs-code</a><br>ReaScriptDocParser：<a href="https://github.com/slsenseless/ReaScriptDocParser/" target="_blank" rel="noopener">https://github.com/slsenseless/ReaScriptDocParser/</a></p><h3 id="4-2-抽象出功能逻辑"><a href="#4-2-抽象出功能逻辑" class="headerlink" title="4.2. 抽象出功能逻辑"></a>4.2. 抽象出功能逻辑</h3><p>在例子中，我们做一个简单的程序。当用户选择了 N 个媒体对象时，在程序中输入想要的目标音量值，点击按钮，就会自动执行脚本。当然，我需要它带 GUI。<br>首先抽象出脚本的功能逻辑：</p><ol><li>添加 Undo 开始块</li><li>获取用户的分贝输入值，并判断是否超过正常范围</li><li>判断用户选定的范围内是否有 item，如果没有及时报错</li><li>分别对每一个 item 执行音量设置</li><li>结束 Undo 块记录</li></ol><h3 id="4-3-选择-API"><a href="#4-3-选择-API" class="headerlink" title="4.3. 选择 API"></a>4.3. 选择 API</h3><p>依次填入对应的 API：</p><ol><li>添加 Undo 开始块：Undo_BeginBlock()</li><li>获取用户的分贝输入值，并判断是否超过正常范围：GUI.Val()</li><li>判断用户选定的范围内是否有 item，如果没有及时报错：GetSelectedMediaItem()</li><li>分别对每一个 item 执行音量设置：SetMediaItemInfo_Value()</li><li>结束 Undo 块记录：Undo_EndBlock()</li></ol><h3 id="4-4-编写功能代码"><a href="#4-4-编写功能代码" class="headerlink" title="4.4. 编写功能代码"></a>4.4. 编写功能代码</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建空表 sel_item，用来存储选中的媒体对象</span></span><br><span class="line">sel_item = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 1. 音量换算函数，把用户输入的分贝数 dB_input 换算成数字音量 vol_value</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ValFromdB</span><span class="params">(dB_input)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>^(dB_input/<span class="number">20</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 对象音量调整函数，参数为数字音量值 vol_value</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">VolChanger</span><span class="params">(vol_value)</span></span></span><br><span class="line">    reaper.Undo_BeginBlock()</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 保存选取的媒体对象在字典 sel_item 中</span></span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">1</span>, count_sel_items <span class="keyword">do</span></span><br><span class="line">    sel_item[i] = reaper.GetSelectedMediaItem(<span class="number">0</span>, i - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 对字典中的每一个对象执行音量改变操作</span></span><br><span class="line">  <span class="keyword">for</span> w = <span class="number">1</span>, #sel_item <span class="keyword">do</span></span><br><span class="line">    reaper.SetMediaItemInfo_Value(sel_item[w], <span class="string">"D_VOL"</span>, vol_value)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    reaper.Undo_EndBlock(<span class="string">"Batch Volumes"</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 输入值判断函数，因为推子最高为12 dB，需要判断用户的输入值是否在范围内并设置临界值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">input_cal</span><span class="params">(vol_value)</span></span></span><br><span class="line">    <span class="keyword">if</span> (vol_value &gt; <span class="number">12</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="comment">-- 根据我的取小数算法12.05正好转换为12 dB</span></span><br><span class="line">        VolChanger(<span class="number">12.05</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        VolChanger(vol_value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span></span>    </span><br><span class="line">    <span class="comment">-- 计算当前选中的对象数</span></span><br><span class="line">    count_sel_items = reaper.CountSelectedMediaItems(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 选取对象不为0才执行函数，否则弹窗提醒</span></span><br><span class="line">    <span class="keyword">if</span> count_sel_items &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> t = <span class="built_in">type</span>(dB_input)</span><br><span class="line">        <span class="keyword">if</span> t == <span class="string">"number"</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- 对分贝换算后的值保留1位小数</span></span><br><span class="line">            vol_value = (ValFromdB(dB_input) - ValFromdB(dB_input) % <span class="number">0.1</span>)</span><br><span class="line">            <span class="comment">-- 执行音量调整函数</span></span><br><span class="line">            input_cal(vol_value)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            reaper.ShowMessageBox(<span class="string">"Check your input first!"</span>, <span class="string">"Warning"</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">            <span class="comment">-- 脚本惯例，刷新页面</span></span><br><span class="line">            reaper.UpdateArrange()</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        reaper.ShowMessageBox(<span class="string">"Please check your selected!"</span>, <span class="string">"Warning"</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="4-5-绘制-GUI"><a href="#4-5-绘制-GUI" class="headerlink" title="4.5. 绘制 GUI"></a>4.5. 绘制 GUI</h3><p>在 ReaPack 中可以找到由 Adam Lovatt 开发的 Lokasenna_GUI Builder，这是一个专门为 ReaScript 创建 GUI 的工具。目前它的第三版改名为 Scythe 也已经发布，但目前看起来只能用纯代码进行开发，有兴趣的朋友亦可自己尝试。<br>在 Action List 里找到它并打开，我们看一下它的界面。<br><img src="/images/GUI%20Builder.png" alt="GUI Builder"></p><p>本例中的程序只需三个控件：</p><ul><li>一行文字用来提示用户在这里输入，并提示数值范围</li><li>文本框作为输入框</li><li>按钮用来执行脚本</li></ul><p><img src="/images/Project%20Settings.png" alt="Project Settings"><br>先调整一下窗体大小为合适的尺寸，在 Settings - Project Settings 中设置 Width 和 Height 分别为400和200。并更改窗体 Name 为 Batch Change Volume。<br><img src="/images/%E5%AE%8C%E6%88%90%E5%90%8E%E7%9A%84GUI%E7%BC%96%E8%BE%91%E5%99%A8.png" alt="完成后的GUI编辑器"></p><p>在布局中添加所需的控件，你会发现 GUI Builder 中的文本框左边是自带文字部分，所以我们实际上只需添加两个控件即可（Textbox 和 Button）。<br>右键点击窗体后选取需要的控件名，添加控件完成后按住 Shift 拖拽控件到合适的位置。之后按需更改尺寸大小，并对控件的名称与尺寸进行修改。<br><strong>注：按钮处的 Name 属性应填写为 input_value，GUI 中显示的名字以 Caption 为准，请自行设置。</strong><br><img src="/images/Export.png" alt="Export"></p><p>当操作结束后，点击 File - Export 导出为 Change_Volume.lua 文件，我们的 GUI 就创建完成了。想找到创建好的 GUI 文件，需要在 Reaper 选项中显示资源路径，随后打开 <code>REAPER/Scripts/ReaTeam Scripts/Development/Lokasenna_GUI v2/Developer Tools/GUI Builder</code> 目录，即可找到制作好的文件，后缀名是 <code>.lua</code>。<br>Windows 用户也可按照类似的路径寻找到 GUI 文件所在。</p><h3 id="4-6-连接-GUI-与功能代码"><a href="#4-6-连接-GUI-与功能代码" class="headerlink" title="4.6. 连接 GUI 与功能代码"></a>4.6. 连接 GUI 与功能代码</h3><p>现在打开 GUI 文件，在这里我通过 VS Code 进行编辑。为了演示简单，我们不采用引用刚创建好的 Change_Volume.lua 文件的方式，直接把上面编写好的功能代码先复制到 GUI 代码中我标记的地方。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> lib_path = reaper.GetExtState(<span class="string">"Lokasenna_GUI"</span>, <span class="string">"lib_path_v2"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> lib_path <span class="keyword">or</span> lib_path == <span class="string">""</span> <span class="keyword">then</span></span><br><span class="line">    reaper.MB(<span class="string">"Couldn't load the Lokasenna_GUI library. Please install 'Lokasenna's GUI library v2 for Lua', available on ReaPack, then run the 'Set Lokasenna_GUI v2 library path.lua' script in your Action List."</span>, <span class="string">"Whoops!"</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">loadfile</span>(lib_path .. <span class="string">"Core.lua"</span>)()</span><br><span class="line"></span><br><span class="line">GUI.req(<span class="string">"Classes/Class - Button.lua"</span>)()</span><br><span class="line">GUI.req(<span class="string">"Classes/Class - Textbox.lua"</span>)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> missing_lib <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">GUI.name = <span class="string">"Batch Change Volume"</span></span><br><span class="line">GUI.x, GUI.y, GUI.w, GUI.h = <span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">200</span></span><br><span class="line">GUI.anchor, GUI.corner = <span class="string">"mouse"</span>, <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将功能代码复制到这里</span></span><br><span class="line"></span><br><span class="line">GUI.New(<span class="string">"Do it!"</span>, <span class="string">"Button"</span>, &#123;</span><br><span class="line">    z = <span class="number">11</span>,</span><br><span class="line">    x = <span class="number">144</span>,</span><br><span class="line">    y = <span class="number">112</span>,</span><br><span class="line">    w = <span class="number">100</span>,</span><br><span class="line">    h = <span class="number">50</span>,</span><br><span class="line">    caption = <span class="string">"Do it!"</span>,</span><br><span class="line">    font = <span class="number">3</span>,</span><br><span class="line">    col_txt = <span class="string">"txt"</span>,</span><br><span class="line">    col_fill = <span class="string">"elm_frame"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">GUI.New(<span class="string">"input_value"</span>, <span class="string">"Textbox"</span>, &#123;</span><br><span class="line">    z = <span class="number">11</span>,</span><br><span class="line">    x = <span class="number">192</span>,</span><br><span class="line">    y = <span class="number">64</span>,</span><br><span class="line">    w = <span class="number">96</span>,</span><br><span class="line">    h = <span class="number">20</span>,</span><br><span class="line">    caption = <span class="string">"Volume (&lt;12dB)    "</span>,</span><br><span class="line">    cap_pos = <span class="string">"left"</span>,</span><br><span class="line">    font_a = <span class="number">3</span>,</span><br><span class="line">    font_b = <span class="string">"monospace"</span>,</span><br><span class="line">    color = <span class="string">"txt"</span>,</span><br><span class="line">    bg = <span class="string">"wnd_bg"</span>,</span><br><span class="line">    shadow = <span class="literal">true</span>,</span><br><span class="line">    pad = <span class="number">4</span>,</span><br><span class="line">    undo_limit = <span class="number">20</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">GUI.Init()</span><br><span class="line">GUI.Main()</span><br></pre></td></tr></table></figure></p><p>代码复制过来了，但 GUI 怎么和代码之间产生互动呢？<br><strong>根据逻辑推断我们可想出，按钮肯定是负责主函数的执行，而文本框负责接收用户输入的数据，并把这个数据传递给函数内部的变量 <code>dB_input</code>。</strong><br>观察代码，其中只有 <code>GUI.New</code> 两处地方需要注意，因为这是按钮的代码实现区。<br>首先，我们先修改按钮处的代码，为 Button 增加一个新的属性，<code>func = main</code>。<br>（为了节约篇幅，功能代码以上的部分省略。）<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 功能代码及上面的代码块省略</span></span><br><span class="line"></span><br><span class="line">GUI.New(<span class="string">"Do it!"</span>, <span class="string">"Button"</span>, &#123;</span><br><span class="line">    z = <span class="number">11</span>,</span><br><span class="line">    x = <span class="number">144</span>,</span><br><span class="line">    y = <span class="number">112</span>,</span><br><span class="line">    w = <span class="number">100</span>,</span><br><span class="line">    h = <span class="number">50</span>,</span><br><span class="line">    caption = <span class="string">"Do it!"</span>,</span><br><span class="line">    font = <span class="number">3</span>,</span><br><span class="line">    col_txt = <span class="string">"txt"</span>,</span><br><span class="line">    col_fill = <span class="string">"elm_frame"</span>,</span><br><span class="line">    <span class="comment">-- 对这个 Button 指派为触发 main() 函数，这里的函数触发不需要写括号</span></span><br><span class="line">    func = main</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">GUI.New(<span class="string">"input_value"</span>, <span class="string">"Textbox"</span>, &#123;</span><br><span class="line">    z = <span class="number">11</span>,</span><br><span class="line">    x = <span class="number">192</span>,</span><br><span class="line">    y = <span class="number">64</span>,</span><br><span class="line">    w = <span class="number">96</span>,</span><br><span class="line">    h = <span class="number">20</span>,</span><br><span class="line">    caption = <span class="string">"Volume (&lt;12dB)    "</span>,</span><br><span class="line">    cap_pos = <span class="string">"left"</span>,</span><br><span class="line">    font_a = <span class="number">3</span>,</span><br><span class="line">    font_b = <span class="string">"monospace"</span>,</span><br><span class="line">    color = <span class="string">"txt"</span>,</span><br><span class="line">    bg = <span class="string">"wnd_bg"</span>,</span><br><span class="line">    shadow = <span class="literal">true</span>,</span><br><span class="line">    pad = <span class="number">4</span>,</span><br><span class="line">    undo_limit = <span class="number">20</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">GUI.Init()</span><br><span class="line">GUI.Main()</span><br></pre></td></tr></table></figure></p><p>之后我们需要让程序里的变量 <code>dB_input</code> 能够获取文本框控件 <code>input_value</code> 中的值，于是我们要在 <code>main()</code> 函数中加入一行 <code>local dB_input = tonumber(GUI.Val(&quot;input_value&quot;))</code>。<br>以下是最终完成的完整代码：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> lib_path = reaper.GetExtState(<span class="string">"Lokasenna_GUI"</span>, <span class="string">"lib_path_v2"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> lib_path <span class="keyword">or</span> lib_path == <span class="string">""</span> <span class="keyword">then</span></span><br><span class="line">    reaper.MB(<span class="string">"Couldn't load the Lokasenna_GUI library. Please install 'Lokasenna's GUI library v2 for Lua', available on ReaPack, then run the 'Set Lokasenna_GUI v2 library path.lua' script in your Action List."</span>, <span class="string">"Whoops!"</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">loadfile</span>(lib_path .. <span class="string">"Core.lua"</span>)()</span><br><span class="line"></span><br><span class="line">GUI.req(<span class="string">"Classes/Class - Button.lua"</span>)()</span><br><span class="line">GUI.req(<span class="string">"Classes/Class - Textbox.lua"</span>)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> missing_lib <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">GUI.name = <span class="string">"Batch Change Volume"</span></span><br><span class="line">GUI.x, GUI.y, GUI.w, GUI.h = <span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">200</span></span><br><span class="line">GUI.anchor, GUI.corner = <span class="string">"mouse"</span>, <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line">sel_item = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ValFromdB</span><span class="params">(dB_input)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>^(dB_input/<span class="number">20</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">VolChanger</span><span class="params">(vol_value)</span></span></span><br><span class="line">    reaper.Undo_BeginBlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">1</span>, count_sel_items <span class="keyword">do</span></span><br><span class="line">    sel_item[i] = reaper.GetSelectedMediaItem(<span class="number">0</span>, i - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> w = <span class="number">1</span>, #sel_item <span class="keyword">do</span></span><br><span class="line">    reaper.SetMediaItemInfo_Value(sel_item[w], <span class="string">"D_VOL"</span>, vol_value)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    reaper.Undo_EndBlock(<span class="string">"Batch Volumes"</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">input_cal</span><span class="params">(vol_value)</span></span></span><br><span class="line">    <span class="keyword">if</span> (vol_value &gt; <span class="number">12</span>) <span class="keyword">then</span></span><br><span class="line">        VolChanger(<span class="number">12.05</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        VolChanger(vol_value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">-- 注意这行代码，从控件 input_value 中获取了用户的输入值，因为默认输入值都会被转为 string，所以这里我先强制把它转为 number，以满足接下来我们的判断需求</span></span><br><span class="line">    <span class="keyword">local</span> dB_input = <span class="built_in">tonumber</span>(GUI.Val(<span class="string">"input_value"</span>))</span><br><span class="line"></span><br><span class="line">    count_sel_items = reaper.CountSelectedMediaItems(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> count_sel_items &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> t = <span class="built_in">type</span>(dB_input)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> t == <span class="string">"number"</span> <span class="keyword">then</span></span><br><span class="line">            vol_value = (ValFromdB(dB_input) - ValFromdB(dB_input) % <span class="number">0.1</span>)</span><br><span class="line">            input_cal(vol_value)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            reaper.ShowMessageBox(<span class="string">"Check your input first!"</span>, <span class="string">"Warning"</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        reaper.UpdateArrange()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        reaper.ShowMessageBox(<span class="string">"Please check your selected!"</span>, <span class="string">"Warning"</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">GUI.New(<span class="string">"do_it"</span>, <span class="string">"Button"</span>, &#123;</span><br><span class="line">    z = <span class="number">11</span>,</span><br><span class="line">    x = <span class="number">144</span>,</span><br><span class="line">    y = <span class="number">112</span>,</span><br><span class="line">    w = <span class="number">100</span>,</span><br><span class="line">    h = <span class="number">50</span>,</span><br><span class="line">    caption = <span class="string">"Do it!"</span>,</span><br><span class="line">    font = <span class="number">3</span>,</span><br><span class="line">    col_txt = <span class="string">"txt"</span>,</span><br><span class="line">    col_fill = <span class="string">"elm_frame"</span>,</span><br><span class="line">    func = main</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">GUI.New(<span class="string">"input_value"</span>, <span class="string">"Textbox"</span>, &#123;</span><br><span class="line">    z = <span class="number">11</span>,</span><br><span class="line">    x = <span class="number">192</span>,</span><br><span class="line">    y = <span class="number">64</span>,</span><br><span class="line">    w = <span class="number">96</span>,</span><br><span class="line">    h = <span class="number">20</span>,</span><br><span class="line">    caption = <span class="string">"Volume (&lt;12dB)    "</span>,</span><br><span class="line">    cap_pos = <span class="string">"left"</span>,</span><br><span class="line">    font_a = <span class="number">3</span>,</span><br><span class="line">    font_b = <span class="string">"monospace"</span>,</span><br><span class="line">    color = <span class="string">"txt"</span>,</span><br><span class="line">    bg = <span class="string">"wnd_bg"</span>,</span><br><span class="line">    shadow = <span class="literal">true</span>,</span><br><span class="line">    pad = <span class="number">4</span>,</span><br><span class="line">    undo_limit = <span class="number">20</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">GUI.Init()</span><br><span class="line">GUI.Main()</span><br></pre></td></tr></table></figure></p><h3 id="4-7-完成效果"><a href="#4-7-完成效果" class="headerlink" title="4.7. 完成效果"></a>4.7. 完成效果</h3><p>打开 Action List，加载之前创建的 Change_Volume.lua 脚本进 Action List。随后运行它，看一下它的执行效果。<br><img src="/images/%E8%84%9A%E6%9C%AC1.png" alt="脚本1"><br>主界面<br><img src="/images/%E8%84%9A%E6%9C%AC2.png" alt="脚本2"><br>当未选择对象时点击按钮的提示<br><img src="/images/%E8%84%9A%E6%9C%AC3.png" alt="脚本3"><br>当选择了对象，但输入的不是数字时点击按钮的提示<br><img src="/images/%E8%84%9A%E6%9C%AC4.png" alt="脚本4"><br>选中两个对象<br><img src="/images/%E8%84%9A%E6%9C%AC5.png" alt="脚本5"><br>输入-100，点击按钮，可见对象的音量已被调整</p><h2 id="通过举一反三学会更多脚本"><a href="#通过举一反三学会更多脚本" class="headerlink" title="通过举一反三学会更多脚本"></a>通过举一反三学会更多脚本</h2><p>脚本语言（如 Python、Lua 等）属于解释型语言，执行过程中与编译型语言预先编译不同，脚本语言只有在执行的时候才需要翻译为机器语言。<br>所以在 Reaper 中当你在编辑脚本时，你会发现所有的前辈们的代码都是以源码的方式展现在你面前，全部开源，毫无掩饰。<strong>当你在编写自己的脚本的时候，前辈们的代码会是最有效的参考。</strong><br>事实上，当你对某个脚本使用方法产生疑惑时，除了去 Cockos 论坛找原贴看介绍，脚本内的注释和更新 Log 一般也能找到答案。<br>鉴于本人的智商不太高，所以一直在用土办法（好记性不如烂笔头）学习。遇到有兴趣的脚本就开始对写注释以加深理解。<br><strong>建议在脚本学习过程中遵循以下步骤：</strong></p><ol><li>主动学习对自己的工作流提升有用的代码片段，并做注释或做笔记总结。</li><li>不要只看不写，练习阶段甚至可以尝试写一个已有的脚本，然后看看跟前辈们的代码差在哪里。</li><li>举一反三，把不同类型和不同作者脚本中用到的代码技巧总结后融会贯通。</li></ol><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>在本系列文的第一篇中，部分思路受到 Robert Randolph 先生的 ReaScript 教程影响。Raymond Radet（X-Raym）基于 Reaper 5 的老 ReaScript 教程也曾在我入门时给予帮助。Moy 老师关于脚本的几篇实例讲解在去年时也对我很有启发。（以上排名无先后）<br><strong>在这里感谢他们在 Reaper 脚本编程领域付出的努力！</strong></p><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2><p>在本篇文章中，我们的 ReaScript 脚本构建基于 Lua，并且都是使用 Reaper 内部的编辑器和 GUI 设计工具实现的。<br>下一篇中，<strong>我们会通过 ReaScript 在 Python 中的第三方库 Reapy，在 Reaper 外实现 ReaScript API 的调用。</strong>在实际工作中有时我们可能需要在外部调用 Reaper 的功能，这样只需让用户面对我们的脚本程序就可以了，通过减少用户与 Reaper 本身的纠缠，在某些场景下可能会比较方便。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reaper </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>人人都能用 WAAPI（二）wwise.core 分支</title>
      <link href="/2020/09/05/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/09/05/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>在《人人都能用 WAAPI（一）概述》中，我们用思维导图对 WAAPI 进行了重新归纳，并在配置好开发环境后，一起用 Python 写了几个简单的小程序，体验了 WAAPI 强大功能的冰山一角。<br>从第二篇起，我们会开始介绍 WAAPI 的所有分支。为了不当一个讨厌的<strong>“文档翻译官”</strong>，我会努力用简单化的语言来描述 WAAPI 的功能，并在最后把 API 组成简单的示例程序。<br>考虑到 Audiokinetic 官网无代码框，我在 GitHub 创建了一个仓库，其中包括了本系列文章中所有的代码，地址为：<a href="https://github.com/zcyh147/Everyone-can-use-WAAPI" target="_blank" rel="noopener">https://github.com/zcyh147/Everyone-can-use-WAAPI</a></p><blockquote><p>阅前须知：</p><ul><li><strong>把 API 逐条列出讲解的主要目的是为了快速阐述其功能，补充文档叙述中的一些不足，以帮助大家快速对 WAAPI 建立印象</strong>。在这里并非有意重写文档，所以建议看完本文后按照第一篇文中所提的方法，用自己喜欢的整理方式重新整理一次。</li><li>本文并不会把每个参数全都翻译并复述一遍功能，这里<strong>均假设读者已学会了概述中的 JSON 阅读方法，能够自行根据我的介绍查阅 WAAPI 参数及返回值等文档信息，并希望读者在阅读时能准确的找到在线文档中对应的章节以便于及时参考。</strong></li><li>为了照顾初学者，我尽量把注释写到每一行，以便快速入门。</li><li>学会 RTFM（Read The Fucking Manual），因为接下来的文章比较严肃。<strong>如发现某些概念看不懂或找不到，请善用 Wwise 文档强大的搜索功能或通过 Google 检索所需答案。</strong></li><li><strong>因为 WAAPI 的功能也是随版本更新逐渐添加的，建议安装最新版 Wwise 进行学习。</strong>当报错信息提示 “The procedure URI is unknown.” 时，就代表你的当前 WAAPI 版本并不支持此 API。</li></ul></blockquote><p>本文目录：</p><p>[toc]</p><h2 id="wwise-core-概览"><a href="#wwise-core-概览" class="headerlink" title="wwise.core 概览"></a>wwise.core 概览</h2><p><img src="/images/wwisecore.png" alt="wwisecore"><br><strong>作为 WAAPI 中最大的模块（以我在上一篇提出的分类逻辑），<code>wwise.core</code> 承载着最多的功能。</strong>除了它与 <code>soundengine</code> 模块外，执行类剩余的几个模块的功能相对简单，所以 <code>wwise.core</code> 会成为我们投入精力最多的一个部分。<br>简单的看一下上面的思维导图，不难看出本模块的功能主要针对 Wwise 音频设计部分，而不是对声音引擎。这也代表<strong>如果你有一些对 Wwise 操作级的优化想法，这会是对你最为重要的章节。</strong><br>注意：图中划线的部分代表 WAAPI 中已被新功能替代的部分。</p><h2 id="audio（导入音频并创建对象）"><a href="#audio（导入音频并创建对象）" class="headerlink" title="audio（导入音频并创建对象）"></a>audio（导入音频并创建对象）</h2><h3 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h3><p><code>audio</code> 分支下有 <code>import</code> 和 <code>importTabDelimited</code>，根据名字容易看出这是负责导入音频资源的功能。这两者的区别是<strong>前者只能导入音频并创建对象</strong>，<strong>后者为根据“制表符分割文件”中所定制的规则导入音频并执行相关操作</strong>。<br>所谓制表符分割文件导入文件，即<strong>在音频文件导入时使用一个制表符分割的文本文件读取提前规定的被导入相关属性（例如音频文件在本机的储存位置、Wwise 中它要所产生对象在各个层级〔各种容器、Event、Output Bus〕的位置、设定属性值和引用、Switch 指派子元素等）。</strong><br>这种文本文件可使用 Excel 或者其它电子表格工具生成，其中的第一行所填写的内容定义了每列的标题所定义的属性，每列中的内容决定了在 Wwise 中建立什么内容。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>不难看出，<code>audio</code> 分支是最重要的资源导入分支，<strong>也是大部分实用性 WAAPI 程序的起点。</strong>这类工具的功能致力于帮助减少人工导入大量文件时带来的繁琐操作，同时根据所定义的信息能够自动完成层级、属性、流播放等设定。<br><strong>如果想通过 <code>import</code> 导入音频文件，就需要再文件名上定义其在工程中的各种位置和属性。为此，要建立一个词典对应文件名中的代号，以减少文件名过长带来的报错可能。</strong><br>因为操作系统对于文件名和路径的长度有所限制，所以 Wwise 中的文件名长度要受此约束，理论只支持最大256字符长度文件名的资源导入。再加上系统路径所占用的字符数，最后往往给不到用户那么多可用字符，也会直接带来错误。<br>我们也可利用 <code>importTabDelimited</code> 通过制表符分割文件完成导入工作，因为需在 Excel 中定义符合 Wwise 可识别信息规则的制表符分隔 txt 文件。对于这个步骤其实也可进行优化。例如可通过 VBA 给声音设计师创建一个在 Excel 中快速对制表符分割文件结构构建的程序，或使用 Python 创建一个更完备的 GUI 程序以完成制表符分割文件的快速创建等。</p><h2 id="audioSourcePeaks（音频源峰值获取）"><a href="#audioSourcePeaks（音频源峰值获取）" class="headerlink" title="audioSourcePeaks（音频源峰值获取）"></a>audioSourcePeaks（音频源峰值获取）</h2><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>此分支下有 <code>getMinMaxPeaksInRegion</code> 和 <code>getMinMaxPeaksInTrimmedRegion</code>，其功能为获取音频峰值并返回相关信息。两者的区别是前者返回的是用户所选区域的峰值，后者是对修剪过后的音频取峰值。<strong>注意这个峰值不是唯一的 Max Peak，而是根据 numPeaks 参数指定数量的 Min/Max Peak。</strong><br>在 <code>getMinMaxPeaksInRegion</code> 的参数中，可看到 <code>timeFrom</code> 和 <code>timeTo</code>，这两者用来确定取值区域的开始和结束时间。<br><code>getMinMaxPeaksInTrimmedRegion</code> 则无需指定开始结束时间，会直接对 SFX 对象裁剪后的部分进行求值。<br><code>audioSourcePeaks</code> 两个功能的返回值都是使用 Base 64 编码的16位有符号 int 数组。所以要经过 Base 64 解码，按照给定的格式(fmt)解析字节流，再换算成 dB。</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>本人对 Wwise 插件开发了解还不够，但对一段音频取这么多最大/最小峰值点的操作看起来并不是普通的需求，这两个功能提供的最多点位可多达 14294967295。如有需求存在要在 Wwise 内获取音频片段的 Peak 点的操作，可使用此两者进行计算。</p><h2 id="object（对象操作）"><a href="#object（对象操作）" class="headerlink" title="object（对象操作）"></a>object（对象操作）</h2><h3 id="功能介绍-1"><a href="#功能介绍-1" class="headerlink" title="功能介绍"></a>功能介绍</h3><h4 id="create-copy-delete-move（对象基本操作）"><a href="#create-copy-delete-move（对象基本操作）" class="headerlink" title="create, copy, delete, move（对象基本操作）"></a>create, copy, delete, move（对象基本操作）</h4><p>这四个功能是最基本的对象操作，分别对应对象的创建、拷贝、删除、移动。所需参数都是围绕着对象名、类型、它现在的位置、之后的位置等跟对象有关的基本参数。<br><code>create</code> 与 <code>audio</code> 功能导入的音频时创建的对象的覆盖范围略有不同，<strong><code>create</code> 能够创建文档中 Wwise Objects Reference 中列出的海量对象，<code>audio</code> 在导入音频的时候则只能创建与音频相关的对象（各类容器、Event 等）。</strong><br><code>create</code> 的功能非常广泛，从创建简单的的 Sound SFX 对象或 Work Unit，创建复杂容器并指定元素，甚至能够创建效果器和声源插件等。</p><h4 id="setReference-setRandomizer-setAttenuationCurve-setName-setNotes-setProperty（设置对象的各种属性）"><a href="#setReference-setRandomizer-setAttenuationCurve-setName-setNotes-setProperty（设置对象的各种属性）" class="headerlink" title="setReference, setRandomizer, setAttenuationCurve, setName, setNotes, setProperty（设置对象的各种属性）"></a>setReference, setRandomizer, setAttenuationCurve, setName, setNotes, setProperty（设置对象的各种属性）</h4><p><code>create</code> 创建对象时只能设置即少量属性（比如本小节中提到的六个 API 里，只有 Notes 能在对象创建的时候被设置），所以我们需要通过上面的这些功能进一步设置对象属性。<br>其中 <code>setReference</code> 为设置引用，如想要为一个 SFX 对象设置输出 Bus，就需要为这个对象添加对某个 Bus 的引用。<br><code>setRandomizer, setAttenuationCurve, setName, setNotes</code> 这些功能为语义本身功能，设置随机、衰减曲线、名字、笔记。<br><code>setProperty</code> 是真正用来设置大量属性的命令，在文档的 Wwise Objects Reference 中我们可以看到大量有关对象的信息，点开某一个，你就可以看到其能被设置的所有属性名。<br>举例来说，如果想对 Mastering Suite 中的某项属性进行设置，只需提供它的 GUID 或路径这类位置信息，再把 “property” 键对应的值修改为要修改的属性名，最后提供合适的值即可完成属性修改。</p><h4 id="get-getTypes-getPropertyInfo-getAttenuationCurve-getPropertyAndReferenceNames（获取对象的各种属性）"><a href="#get-getTypes-getPropertyInfo-getAttenuationCurve-getPropertyAndReferenceNames（获取对象的各种属性）" class="headerlink" title="get, getTypes, getPropertyInfo, getAttenuationCurve, getPropertyAndReferenceNames（获取对象的各种属性）"></a>get, getTypes, getPropertyInfo, getAttenuationCurve, getPropertyAndReferenceNames（获取对象的各种属性）</h4><p>如果想获取现有工程的各种数据，就需要用 <code>get</code> 这几个功能。<br><strong><code>get</code> 是基于 query（查询）的功能，它能够获取到大量工程信息，例如 ID、名字、占用空间大小、路径、播放长度等，设定好合适的查询参数即可完成查询。</strong>就像我们在概述篇提到的，它可同时传入 Arguments 和 Options 两个参数，在使用时可按需设置 Options 来控制查询的返回结果。<br>这里解释一下其所使用的两个参数的含义。<br>其中 Arguments 中含有 from 和 transform 两个子参数：</p><ol><li>from 为查询的数据来源，即以名字、GUID、路径，类型等作为限制条件来搜寻对象。除了对单个对象 GUID 的查询，其中还有些条件比如 <code>ofType</code> 或者 <code>search</code> 能够找出符合条件的一整类对象。</li><li>transform 比较有趣，功能是对已选择的对象进行变换。比如我们现在在 from 中设定选择了某个层级下的 Random Container，此时在 transform 中再添加 select parent，就会转而选择上级对象。transform 是 from 的一种重要补充，能够方便的对已设定的 from 条件进行父级、子级和引用等的查询。</li></ol><p>Options 中含有 return 和 platform 两个子参数，注意 Options 是可以留空的：</p><ol><li>return 指定了对象被查询后返回什么内容，留空则默认返回 GUID 和对象名。</li><li>platform 指定了查询什么平台下的结果，留空的话会查询默认平台。</li></ol><p>那为什么还要有 <code>getTypes, getPropertyInfo, getAttenuationCurve, getPropertyAndReferenceNames, getPropertyNames</code> 呢？<br>其实这是 WAAPI 设计时对功能分工的不同，<code>get</code> 更针对对象的各种属性进行查询。另外四个查询更偏向对象的元属性，<code>getTypes</code> 返回当前所有注册的对象类型，<code>getPropertyInfo</code> 返回对象属性的具体信息（例如取值范围等），<code>getAttenuationCurve</code> 返回特定对象的衰减曲线设置，<code>getPropertyAndReferenceNames</code> 返回对象拥有的属性和当前引用名称。</p><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>对象操作的可应用之处非常多，例如可通过 <code>get</code> 系获取转码后音频文件的空间占用情况、获取对象的属性和引用状况、查询工程中所有的平台、所有正在使用的 Output Bus 等。如果对于 Wwise 的 Queries 功能有所了解，用这个功能会很顺手。 </p><h2 id="getInfo-和-log-get（工程信息和日志获取）"><a href="#getInfo-和-log-get（工程信息和日志获取）" class="headerlink" title="getInfo 和 log.get（工程信息和日志获取）"></a>getInfo 和 log.get（工程信息和日志获取）</h2><h3 id="功能介绍-2"><a href="#功能介绍-2" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>这是两个简单的信息获取功能，<code>getInfo</code> 用于获取当前工程全局信息，例如 Wwise 版本、平台信息、WAAPI 版本等。<code>log.get</code> 用于获取最新的日志，Logs 窗口中的那几个选项卡就对应本 API 中的参数 <code>channel</code>。此功能用于获取完整的日志。<br>如果想实现在自己的程序里动态更新日志的状态，则需要用订阅类的功能，有关这部分我们会在之后的章节里进行讨论。例如订阅类中的 <code>ak.wwise.core.log.itemAdded</code>，就是在有对象被添加时返回信息。</p><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p>在对工程全局信息和日志有需求时，可根据需求使用这两个功能。因为 <code>log.get</code> 能获取最新的日志，可以在 WAAPI 程序中某些步骤后加入这项功能，从而把每次的日志保存到数据库或进行预想的分析，以获得更为定制化的反馈报告。</p><h2 id="profiler（分析器功能）"><a href="#profiler（分析器功能）" class="headerlink" title="profiler（分析器功能）"></a>profiler（分析器功能）</h2><h3 id="功能介绍-3"><a href="#功能介绍-3" class="headerlink" title="功能介绍"></a>功能介绍</h3><h4 id="startCapture-stopCapture（Capture-开关）"><a href="#startCapture-stopCapture（Capture-开关）" class="headerlink" title="startCapture, stopCapture（Capture 开关）"></a>startCapture, stopCapture（Capture 开关）</h4><p>单纯的控制 Profiler Capture 的开始与停止，无需参数即可直接调用。</p><h4 id="getBusses-getCursorTime-getRTPCs-getVoiceContributions-getVoices（获取-Profiler-中特定时间点的信息）"><a href="#getBusses-getCursorTime-getRTPCs-getVoiceContributions-getVoices（获取-Profiler-中特定时间点的信息）" class="headerlink" title="getBusses, getCursorTime, getRTPCs, getVoiceContributions, getVoices（获取 Profiler 中特定时间点的信息）"></a>getBusses, getCursorTime, getRTPCs, getVoiceContributions, getVoices（获取 Profiler 中特定时间点的信息）</h4><p>其中 <code>getBusses</code>、<code>getRTPCs</code>、<code>getVoices</code> 为同一类功能，通过传入一个特定的时间作为参数，即可查询 Profiler 此刻的 Bus、RTPC ID、RTPC 值、相关声部等信息。<br><code>getCursorTime</code> 可获取当前 Profiler 光标的位置，并返回时间。<br><code>getVoiceContributions</code> 需要通过管线 ID 和 Profiler 的时间位置，可查询影响干声路径的音量和高低通等参数。<br>注意，其中的 <code>getBusses</code> 和 <code>getVoices</code> 也可传入两个参数，第二个参数用来指定查询范围。</p><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p>不难看出，<code>startCapture, stopCapture</code> 可集成到工具上进行手动或自动控制，方便进行比较复杂的捕捉需求。例如使用 Unity WAAPI 客户端，把一些分析的功能做进去，在 Unity 中的控制采集开关。<code>get</code> 类功能可根据需求获取分析数据，再根据需求进行分析之用。</p><h2 id="project-save（保存工程）"><a href="#project-save（保存工程）" class="headerlink" title="project.save（保存工程）"></a>project.save（保存工程）</h2><h3 id="功能介绍-4"><a href="#功能介绍-4" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>保存当前工程。</p><h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><p>单纯代替 Ctrl + S 过于简单，比较有用的场景可以是在追求稳定的时候根据触发条件自动保存工程。比如在批量导入上万文件或实行其他批处理操作时，为了工程安全，或许可在每导入100个甚至10个文件时就调用此功能保存一次，以避免任何潜在的不安全。</p><h2 id="remote（远程连接到游戏）"><a href="#remote（远程连接到游戏）" class="headerlink" title="remote（远程连接到游戏）"></a>remote（远程连接到游戏）</h2><h3 id="功能介绍-5"><a href="#功能介绍-5" class="headerlink" title="功能介绍"></a>功能介绍</h3><h4 id="connect-disconnect（连接，断开连接）"><a href="#connect-disconnect（连接，断开连接）" class="headerlink" title="connect, disconnect（连接，断开连接）"></a>connect, disconnect（连接，断开连接）</h4><p>对于看过 Wwise 一分钟的小伙伴，应该看过侯老师亲自配音的“如何使用WAAPI将Wwise连接到您的游戏”（<a href="https://www.bilibili.com/video/BV11E411P7GW），在视频中就是通过" target="_blank" rel="noopener">https://www.bilibili.com/video/BV11E411P7GW），在视频中就是通过</a> <code>connect</code> 完成了连接操作。注意，调用 <code>connect</code> 时需要提供主机 IP 并可选提供端口号，这也是为什么下面的 <code>getAvailableConsoles</code> 要存在，如果有连接到不同的游戏引擎中的需求，就可通过此功能先获取可连接的客户端列表再进行操作。</p><h4 id="getAvailableConsoles-getConnectionStatus（查看当前可用的控制台和获得当前连接状态）"><a href="#getAvailableConsoles-getConnectionStatus（查看当前可用的控制台和获得当前连接状态）" class="headerlink" title="getAvailableConsoles, getConnectionStatus（查看当前可用的控制台和获得当前连接状态）"></a>getAvailableConsoles, getConnectionStatus（查看当前可用的控制台和获得当前连接状态）</h4><p><code>getAvailableConsoles</code> 用来获取当前可用的控制台，即查看当前有哪些跟 Wwise 可连接的游戏引擎工程，并返回编辑器名字、IP、端口、平台等信息。<br><code>getConnectionStatus</code> 则是获取当前连接状态，只有已经跟游戏引擎连接上以后，才会返回它们的控制台信息和连接状态。</p><h3 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h3><p><code>remote</code> 中的连接和断开连接功能，就像 Wwise 一分钟里所讲可以直接设置到游戏中的菜单上，从而进行点击调用来达到快速连接游戏。或者通过 StreamDeck 和 Metagrid 这样的工具快速触发 Python 脚本来激活远程连接，能够有效减少操作浪费的时间。<br>对于 <code>getAvailableConsoles</code> 和 <code>getConnectionStatus</code>，如果大家记得 <code>profiler</code> 部分，相信能想到把这两个紧密相关的功能结合，可以把 Wwise 分析器的数据搬到自己的程序中。比如自动化提取想要的信息，或者简单的在自己的程序里告知用户当前连接状态如何，以实现比较完善的 Wwise 外工作流。</p><h2 id="soundbank（SoundBank-生成与内容设置）"><a href="#soundbank（SoundBank-生成与内容设置）" class="headerlink" title="soundbank（SoundBank 生成与内容设置）"></a>soundbank（SoundBank 生成与内容设置）</h2><h3 id="功能介绍-6"><a href="#功能介绍-6" class="headerlink" title="功能介绍"></a>功能介绍</h3><p><code>generate</code> 意如其名，负责生成 SoundBank。我们知道，日常生成 SoundBank 时除了全部生成外，还可勾选特定的 SoundBank、平台、语言来生成，同理，使用 <code>generate</code> 时也需要设置这些参数。<br><code>getInclusions</code> 可以返回 SoundBank 内包含所有 Event 的列表，其中包括 GUID 和 Event 所含的层级结构。<br><code>setInclusions</code> 负责设置 SoundBank 内包含的内容，可以对内容添加、删除、替换。</p><h3 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h3><p><code>soundbank</code> 类中如果想对不存在的 SoundBank 进行内容设置，需先通过 <code>create</code> 进行创建 SoundBank 对象和层级，之后才能继续设置包内内容。<br><strong>至此，一套完整的创建工作流就产生了，<code>audio</code> 类负责导入音频并创建音频层级结构，<code>create</code> 类可以创建并构建各种其他层级和 Event 等，最后由 <code>soundbank</code> 类负责收尾创建 SoundBank。</strong>这套工作流可用于根据外部设定的结构文件自动化创建，或在 Wwise 外的控制程序上通过 <code>soundbank</code> 检视工程内部结构。</p><h2 id="switchContainer（Switch-容器内操作）"><a href="#switchContainer（Switch-容器内操作）" class="headerlink" title="switchContainer（Switch 容器内操作）"></a>switchContainer（Switch 容器内操作）</h2><h3 id="功能介绍-7"><a href="#功能介绍-7" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>在讨论 <code>create</code> 类时我们谈到它可以创建各种容器，其中就包括 Switch Container。<strong>那为什么这里又出现了 <code>switchContainer</code> 呢</strong>？<br>众所周知，Switch Container 指派了控制当前容器的 Switch/State Group 后，需要对每一个引入的 Switch/State 指派容器中的对象，这样才让能 Switch Container 有实际的工作意义。<br>WAAPI 中把对 Switch Container 中进行指派的这类操作独立出来，使用 <code>switchContainer</code> 类来进行相关操作。<br><code>addAssignment</code> 和 <code>removeAssignment</code> 分别为添加与去除 Switch 指派的功能，只需要提供 Switch Container 中对象的 GUID 和目标 Switch/State Group 中的 Switch/State 的 GUID 即可轻松完成删减。<br><code>getAssignments</code>是一个非常简单的功能，给定 Switch Container 的 GUID，会返回当前容器下所有子对象的 GUID 和指定的 Switch/State 的 GUID。</p><h3 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h3><p><code>switchContainer</code> 的应用场景很简单，可作为自动化导入工具流的补充，对导入时创建的容器进行 Switch 元素指派。</p><h2 id="transport（走带条控制）"><a href="#transport（走带条控制）" class="headerlink" title="transport（走带条控制）"></a>transport（走带条控制）</h2><h3 id="功能介绍-8"><a href="#功能介绍-8" class="headerlink" title="功能介绍"></a>功能介绍</h3><h4 id="create-destroy-executeAction"><a href="#create-destroy-executeAction" class="headerlink" title="create, destroy, executeAction"></a>create, destroy, executeAction</h4><p><code>create, destroy</code> 为一对功能，前者是在当前工程中创建一个走带条对象（Transport Object），后者是销毁这个走带条对象。因为是针对对象的操作，所以创建时需要对象的 GUID，销毁时需要走带条对象的 ID。<br><strong>什么叫走带条对象？</strong>其实在 Wwise 日常的工作中我们无时无刻不在重复这两个动作。<br>例如选中 Event A，走带处的控制焦点会变成控制它的状态，即为其创建了一个走带条对象。此时选中其他对象，这个走带条对象销毁，创建下一个。如果点击了走带条上的 Pin，这个走带条对象就会持续存在，而其他对象的走带条对象创建被阻滞。<br>对于 Soundcaster 来说，每个 Session 其实就是一堆走带条对象的集合。<br><code>executeAction</code> 功能如其名，可以控制走带条对象的播放行为，它具有五种 Action 可供使用。</p><h4 id="getList-getState"><a href="#getList-getState" class="headerlink" title="getList, getState"></a>getList, getState</h4><p><code>getList</code> 为获取当前工程内所有走带条对象，在 WAAPI 中走带条对象创建后如没经过 <code>destroy</code> 手工销毁，可通过此功能查看当前还存在的走带条对象。<br><code>getState</code> 为获取走带条对象的状态，在 <code>executeAction</code> 为走带条对象指定播放状态后可通过此命令进行查询。</p><h3 id="应用场景-9"><a href="#应用场景-9" class="headerlink" title="应用场景"></a>应用场景</h3><p><code>transport</code> 类的功能应用场景比较简单，如果想在 Wwise 外的程序里创建简单的播放行为控制功能，可通过其进行实现。这个外部的程序可以是自己的外置集成工具，也可以是通过 WAAPI 在声音引擎中对 Wwise 中的声音进行预览，甚至在 Wwise 外可复刻一个 Soundcaster。</p><h2 id="undo（撤销）"><a href="#undo（撤销）" class="headerlink" title="undo（撤销）"></a>undo（撤销）</h2><h3 id="功能介绍-9"><a href="#功能介绍-9" class="headerlink" title="功能介绍"></a>功能介绍</h3><p><code>beginGroup</code> 和 <code>endGroup</code> 的概念对于接触过 ReaScript 的人可能更容易理解一些，功能类似 ReaScript 中的 Undo_BeginBlock() 和 Undo_EndBlock()。即执行完 <code>beginGroup</code> 后到执行 <code>endGroup</code> 之前所有的操作都会被保存为一个 Undo Group。其中 <code>beginGroup</code> 可以被堆叠使用。<br><code>cancelGroup</code> 为撤销最后一个 Undo Group 内的所有操作。</p><h3 id="应用场景-10"><a href="#应用场景-10" class="headerlink" title="应用场景"></a>应用场景</h3><p>Undo Group 是把一串行为一次性撤销的设计，当然，Undo Group 理应也可以作为 Redo 来使用，不过 WAAPI 中目前只有撤销功能，所以想实现 Redo 还需等待 API 更新。从应用场景来说，<code>undo</code> 类功能可为 Wwise 外工具增添撤销功能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>如果按照顺序读下来感到有些遗忘是正常的。</strong>这也是为什么在开头我建议大家看完这篇文章后自己对 WAAPI 进行一次重构的原因。<br>要把 WAAPI 做成自己的武器库，应该按照如下步骤进行：</p><ol><li>整理出你自己的 WAAPI 框架，无论是详细的笔记还是简略的思维导图</li><li>发散思维，思考自己要解决音频设计与整合工作中的哪些痛点</li><li>抽象出头脑中原型的逻辑，并寻找到可使用的 API</li><li>完成功能代码</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>单纯的介绍是枯燥的，下面通过实例体验一下 WAAPI 的应用。<br><strong>因示例更注重功能代码实现，故不会像真实项中一样进行交互设计或者加入 GUI。</strong>所以这部分代码实际上是从程序里抽象出的核心功能代码，如果想要应用到自己的程序上，只需为其设计交互层即可。<br>在这里我会尽量覆盖到 <code>wwise.core</code> 分支下的 API，少量没用上的功能大家可自行研究，使用原理上区别不大。</p><blockquote><p>以下代码的重点是参数调用方法，当遇到奇怪的 Bug 时仔细看看你写的和示例的区别，应该就能找到问题所在。<br>为了方便使用，我把每个功能都封装到了函数里，可修改概述中 Functions（执行类）示例的执行代码以上在本机试用。<br>Wwise 在 macOS 下的目录结构与 Windows 不同，因为其运行在 Wine 中，在 macOS 端进行尝试的同学请注意一下文件路径的问题（点击菜单中的 Project，在最近访问的工程处可查看 Wine 中 Wwise 的具体目录）。</p></blockquote><h3 id="1-导入-Sound-SFX-并建立层级结构并设置一些属性，随后为这个-Sound-SFX-创建-Event-并设置动作类型。最后创建-SoundBank，并添加之前创建的-Event，并生成这个-SoundBank"><a href="#1-导入-Sound-SFX-并建立层级结构并设置一些属性，随后为这个-Sound-SFX-创建-Event-并设置动作类型。最后创建-SoundBank，并添加之前创建的-Event，并生成这个-SoundBank" class="headerlink" title="1. 导入 Sound SFX 并建立层级结构并设置一些属性，随后为这个 Sound SFX 创建 Event 并设置动作类型。最后创建 SoundBank，并添加之前创建的 Event，并生成这个 SoundBank"></a>1. 导入 Sound SFX 并建立层级结构并设置一些属性，随后为这个 Sound SFX 创建 Event 并设置动作类型。最后创建 SoundBank，并添加之前创建的 Event，并生成这个 SoundBank</h3><p><strong>快速导入音频文件到 Wwise 中并建立所需的音频层级，甚至建立 Event，这无疑会极大提高音频整合时的效率。</strong>在下面的实例中我们需要手工的在参数中填写文件路径、属性、层级等相关信息，在实际工作中可以发挥想象力，把工具中这部分繁琐的工序也解决掉。<br>比如通过规范的文件名代号、与数据库联动、正则表达式等方法让文件在导入前有足够的元数据准备，再通过你所使用的编程语言自动把这种格式化好的文件名格转化为 WAAPI 导入文件所需设置 JSON 参数，即可真正实现把音频快速导入 Wwise 工程的目的。</p><h4 id="选定-API"><a href="#选定-API" class="headerlink" title="选定 API"></a>选定 API</h4><ul><li>导入文件：<code>import</code></li><li>设置属性：<code>setProperty</code> </li><li>创建 Event 并添加声音、创建 SoundBank：<code>create</code></li><li>组装并生成 SoundBank：<code>setInclusions</code>、<code>generate</code></li></ul><h4 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 导入文件并建立音频层级</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_import</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="comment"># 定义文件导入参数，imports 中包含了硬盘中的文件路径和目标路径，目标路径中包括对创建对象的类型定义。</span></span><br><span class="line">    <span class="comment"># 对于非语音的 Sound SFX，importLanguage 使用 SFX。importOperation 为 useExisting，这代表了如果已经有所需的容器存在就直接替换，如果没有就创建一个。</span></span><br><span class="line">    args_import = &#123;</span><br><span class="line">        <span class="string">"importOperation"</span>: <span class="string">"useExisting"</span>, </span><br><span class="line">        <span class="string">"default"</span>: &#123;</span><br><span class="line">            <span class="string">"importLanguage"</span>: <span class="string">"SFX"</span></span><br><span class="line">        &#125;, </span><br><span class="line">        <span class="string">"imports"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"audioFile"</span>: file_path, </span><br><span class="line">                <span class="string">"objectPath"</span>: <span class="string">"\\Actor-Mixer Hierarchy\\Default Work Unit\\&lt;Sequence Container&gt;Test 0\\&lt;Sound SFX&gt;My SFX 0"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 定义返回结果参数，让其只返回 Windows 平台下的信息，信息中包含 GUID 和新创建的对象名</span></span><br><span class="line">    opts = &#123;</span><br><span class="line">        <span class="string">"platform"</span>: <span class="string">"Windows"</span>,</span><br><span class="line">        <span class="string">"return"</span>: [</span><br><span class="line">            <span class="string">"id"</span>, <span class="string">"name"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> client.call(<span class="string">"ak.wwise.core.audio.import"</span>, args_import, options=opts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 设置音频属性</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_property</span><span class="params">(object_guid)</span>:</span></span><br><span class="line">    <span class="comment"># 设定参数里的目标对象为所需修改对象的 GUID，修改的属性为 Volume，对象所在的平台为 Mac，数值修改为 10。</span></span><br><span class="line">    args_property = &#123;</span><br><span class="line">        <span class="string">"object"</span>: object_guid, </span><br><span class="line">        <span class="string">"property"</span>: <span class="string">"Volume"</span>, </span><br><span class="line">        <span class="string">"platform"</span>: <span class="string">"Windows"</span>, </span><br><span class="line">        <span class="string">"value"</span>: <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client.call(<span class="string">"ak.wwise.core.object.setProperty"</span>, args_property)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 对 Sound SFX 创建 Event，并设定播放规则</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_event</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 对一个 Sound SFX 对象创建 Event 并定义其播放行为为播放</span></span><br><span class="line">    args_new_event = &#123;</span><br><span class="line">        <span class="comment"># 上半部分属性中分别为 Event 创建后存放的路径、类型、名称、遇到名字冲突时的处理方法</span></span><br><span class="line">        <span class="string">"parent"</span>: <span class="string">"\\Events\\Default Work Unit"</span>, </span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"Event"</span>, </span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"Play_SFX"</span>, </span><br><span class="line">        <span class="string">"onNameConflict"</span>: <span class="string">"merge"</span>, </span><br><span class="line">        <span class="string">"children"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment"># 为其创建播放行为，名字留空，使用 @ActionType 定义其播放行为为 Play，@Target 为被播放的声音对象</span></span><br><span class="line">                <span class="string">"name"</span>: <span class="string">""</span>, </span><br><span class="line">                <span class="string">"type"</span>: <span class="string">"Action"</span>, </span><br><span class="line">                <span class="string">"@ActionType"</span>: <span class="number">1</span>, </span><br><span class="line">                <span class="string">"@Target"</span>: <span class="string">"\\Actor-Mixer Hierarchy\\Default Work Unit\\Test 0\\My SFX 0"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> client.call(<span class="string">"ak.wwise.core.object.create"</span>, args_new_event&#123;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 创建 SoundBank，并对其添加 Event</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_soundbank</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 在 SoundBanks 文件夹的 Default Work Unit 里创建一个 Soundbank</span></span><br><span class="line">    args_new_event = &#123;</span><br><span class="line">        <span class="string">"parent"</span>: <span class="string">"\\SoundBanks\\Default Work Unit"</span>, </span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"SoundBank"</span>, </span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"Just_a_Bank"</span>, </span><br><span class="line">        <span class="string">"onNameConflict"</span>: <span class="string">"replace"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 接收返回值</span></span><br><span class="line">    soundbank_info = client.call(<span class="string">"ak.wwise.core.object.create"</span>, args_create_soundbank)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给刚创建完的 SoundBank 添加内容，把上面创建的 Event 放进去</span></span><br><span class="line">    args_set_inclusion = &#123;</span><br><span class="line">        <span class="string">"soundbank"</span>: <span class="string">"\\SoundBanks\\Default Work Unit\\Just_a_Bank"</span>, </span><br><span class="line">        <span class="string">"operation"</span>: <span class="string">"add"</span>, </span><br><span class="line">        <span class="string">"inclusions"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment"># 此处为 Just_a_Bank 内要放入的内容，filter 是要把哪些数据放进 SoundBank</span></span><br><span class="line">                <span class="string">"object"</span>: <span class="string">"\\Events\\Default Work Unit\\Play_SFX"</span>, </span><br><span class="line">                <span class="string">"filter"</span>: [</span><br><span class="line">                    <span class="string">"events"</span>, </span><br><span class="line">                    <span class="string">"structures"</span>,</span><br><span class="line">                    <span class="string">"media"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> client.call(<span class="string">"ak.wwise.core.soundbank.setInclusions"</span>, args_set_inclusion)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 生成 SoundBank</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_soundbank</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 设定需要导出的 SoundBank 名字，并设置为写入到磁盘</span></span><br><span class="line">    args_generate_soundbank = &#123;</span><br><span class="line">        <span class="string">"soundbanks"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"name"</span>: <span class="string">"Ambient"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"writeToDisk"</span>: <span class="keyword">True</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> client.call(<span class="string">"ak.wwise.core.soundbank.generate"</span>, args_generate_soundbank)</span><br></pre></td></tr></table></figure><h3 id="2-获取当前工程全局信息、Sound-SFX-大小、SoundBank-大小"><a href="#2-获取当前工程全局信息、Sound-SFX-大小、SoundBank-大小" class="headerlink" title="2. 获取当前工程全局信息、Sound SFX 大小、SoundBank 大小"></a>2. 获取当前工程全局信息、Sound SFX 大小、SoundBank 大小</h3><h4 id="选定-API-1"><a href="#选定-API-1" class="headerlink" title="选定 API"></a>选定 API</h4><ul><li>获取全局信息：<code>getInfo</code></li><li>获取 Sound SFX 转码后大小：<code>get</code></li><li>获取生成的 SoundBank 路径：<code>get</code></li></ul><h4 id="编写代码-1"><a href="#编写代码-1" class="headerlink" title="编写代码"></a>编写代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 获取全局信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_global_info</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 通过 getInfo 查询工程信息</span></span><br><span class="line">    <span class="keyword">return</span> client.call(<span class="string">"ak.wwise.core.getInfo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 获取 Sound SFX 的大小</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sfx_and_event_size</span><span class="params">(sound_sfx_guid)</span>:</span></span><br><span class="line">    <span class="comment"># 设置查询参数为对象的 GUID</span></span><br><span class="line">    args = &#123;</span><br><span class="line">        <span class="string">"from"</span>: &#123;</span><br><span class="line">            <span class="string">"id"</span>: [</span><br><span class="line">                sound_sfx_guid</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设定返回值为对象名字和转码后的大小</span></span><br><span class="line">    opts = &#123;</span><br><span class="line">        <span class="string">"return"</span>: [</span><br><span class="line">            <span class="string">"name"</span>, <span class="string">"totalSize"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> client.call(<span class="string">"ak.wwise.core.object.get"</span>, args, options=opts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 获取工程生成后的的 SoundBank 大小</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_soundbank_size</span><span class="params">(soundbank_guid)</span>:</span></span><br><span class="line">    <span class="comment"># 同上例</span></span><br><span class="line">    args = &#123;</span><br><span class="line">        <span class="string">"from"</span>: &#123;</span><br><span class="line">            <span class="string">"id"</span>: [</span><br><span class="line">                soundbank_guid</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设定返回值为 Windows 平台下 SoundBank 生成后的路径</span></span><br><span class="line">    opts = &#123;</span><br><span class="line">        <span class="string">"platform"</span> : <span class="string">"Windows"</span>,</span><br><span class="line">        <span class="string">"return"</span>: [</span><br><span class="line">            <span class="string">"soundbank:bnkFilePath"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment"># 对得到的 SoundBank 地址使用 os.path.getsize() 获取大小，并换算成 MB。Mac 下的 Wwise 返回目录值需处理才可使用，在此不加以讨论。</span></span><br><span class="line">    path =  client.call(<span class="string">"ak.wwise.core.object.get"</span>, args, options=opts)[<span class="string">'return'</span>][<span class="number">0</span>]</span><br><span class="line">    size = os.path.getsize(path) / (<span class="number">1024</span> ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> size</span><br></pre></td></tr></table></figure><h3 id="3-简易实现-Soundcaster-中-Session-和播放功能"><a href="#3-简易实现-Soundcaster-中-Session-和播放功能" class="headerlink" title="3. 简易实现 Soundcaster 中 Session 和播放功能"></a>3. 简易实现 Soundcaster 中 Session 和播放功能</h3><p>Soundcaster 的功能主要由两部分组成，其一是保存一组走带条对象数据方便复用（即 Soundcaster Session），其二是在播放时可控制 Game Sync 及对象的属性、M/S 等。<br>因为第二部分中有些功能比较复杂，在示例中我们只完成第一个部分。<br>注意：WAAPI 中的 Transport Object 创建后无法同 Wwise 工程保存，如果想复现 Soundcaster Session 功能，需要将每组 Session 的 GUID 单独保存以供下次重建 Transport Object。</p><h4 id="选定-API-2"><a href="#选定-API-2" class="headerlink" title="选定 API"></a>选定 API</h4><ul><li>走带条控制：<code>transport</code></li></ul><h4 id="编写代码-2"><a href="#编写代码-2" class="headerlink" title="编写代码"></a>编写代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 为对象创建 Transport Object（X 为自定编号或标记，以下简称为走带条对象），创建结束后会返回走带条对象的 GUID。为方便管理，我们把对象名跟走带条对象的 GUID 放在同一个字典里作为函数返回值</span></span><br><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transportX</span><span class="params">(object_guid)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> WaapiClient() <span class="keyword">as</span> client:</span><br><span class="line">            <span class="comment"># 设置查询参数为走带条可控对象的 GUID</span></span><br><span class="line">            transport_args = &#123;</span><br><span class="line">                <span class="string">"object"</span>: object_guid</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 返回值为字典格式的走带条对象 ID，如 &#123;'transport': 12&#125; </span></span><br><span class="line">            result_transport_id = client.call(<span class="string">"ak.wwise.core.transport.create"</span>, transport_args)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 通过 object_guid 设置条件，通过 `ak.wwise.core.object.get` 获取对象名字。当然，你如果在上面直接传入对象名字来创建走带条对象，也可省略此步</span></span><br><span class="line">            args = &#123;</span><br><span class="line">                <span class="string">"from"</span>: &#123;</span><br><span class="line">                    <span class="string">"id"</span>: [</span><br><span class="line">                        object_guid</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            opts = &#123;</span><br><span class="line">                <span class="string">"return"</span>: [</span><br><span class="line">                    <span class="string">"name"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 进行远程调用，得到返回值为字典格式的对象名称，如 &#123;'name': 'MyObjectName'&#125;</span></span><br><span class="line">            result_dict_name = client.call(<span class="string">"ak.wwise.core.object.get"</span>, args, options=opts)[<span class="string">'return'</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 合并对象名称和走带条对象 ID 这两个字典，从而获得 &#123;'name': 'MyObjectName', 'transport': 1234&#125; 这种字典结构的走带条 Session</span></span><br><span class="line">            <span class="keyword">return</span> result_dict_name.update(result_transport_id)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">        print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在获取了多个 Transport Object 的“字典+走带条 ID“格式的数据后，可将其放入一个列表中作为储存，这种结构就已经是一个初级的 Soundcaster Session 了，例如：</span></span><br><span class="line"><span class="comment"># env_session = [&#123;'name': 'MyObjectName1', 'transport': 1234&#125;, &#123;'name': 'MyObjectName2', 'transport': 12345&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 从 Transport Session 中获取需要被控制的走带条的 Transport ID 字典</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_transport_args</span><span class="params">(env_session, object_name, play_state)</span>:</span></span><br><span class="line">    <span class="comment"># 遍历储存走带条对象 Session 的列表 env_session，获取给定对象名 object_name 所对应的字典 transport_dict</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> env_session:</span><br><span class="line">        <span class="keyword">if</span> i[<span class="string">'name'</span>] == object_name:</span><br><span class="line">            transport_dict = i</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从 transport_dict 中获取走带条对象的 ID 对应的字典，并且与播放行为字典进行合并，准备作为参数传递</span></span><br><span class="line">    transport_id = &#123;<span class="string">'transport'</span>: transport_dict[transport]&#125;</span><br><span class="line">    args = &#123;<span class="string">"action"</span>: play_state&#125;</span><br><span class="line">    <span class="keyword">return</span> args.update(transport_id)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 传入 Transport Session、Session 内需要播放的走带条对象、播放行为，通过第二步的函数获得参数，远程调用 executeAction 来控制走带条的播放行为</span></span><br><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> WaapiClient() <span class="keyword">as</span> client:</span><br><span class="line">        args = get_transport_args(env_session, object_name, play_state)</span><br><span class="line">        client.call(<span class="string">"ak.wwise.core.transport.executeAction"</span>, args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">    print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br></pre></td></tr></table></figure><h3 id="4-抓取-Profiler-数据生成报告"><a href="#4-抓取-Profiler-数据生成报告" class="headerlink" title="4. 抓取 Profiler 数据生成报告"></a>4. 抓取 Profiler 数据生成报告</h3><h4 id="选定-API-3"><a href="#选定-API-3" class="headerlink" title="选定 API"></a>选定 API</h4><ul><li>开始连接：<code>startCapture, stopCapture</code></li><li>抓取信息：<code>getBusses, getCursorTime, getRTPCs, getVoiceContributions, getVoices</code></li></ul><h4 id="编写代码-3"><a href="#编写代码-3" class="headerlink" title="编写代码"></a>编写代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 开始 Profiler 数据抓取，并返回抓取开始时的时间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_capture</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> client.call(<span class="string">"ak.wwise.core.profiler.startCapture"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 结束抓取，并返回抓取结束时的时间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stop_capture</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> client.call(<span class="string">"ak.wwise.core.profiler.startCapture"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 从抓取到的数据中获取各种信息，注意 cursor_time 的取值范围需要在 tart_capture() 和 stop_capture() 之间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">capture_log_query</span><span class="params">(cursor_time)</span>:</span></span><br><span class="line">    <span class="comment"># 设定要查询的时间点</span></span><br><span class="line">    args_times = &#123;</span><br><span class="line">        <span class="string">"time"</span>: cursor_time</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取当前时间点上的声部名称、是否为虚声部、与其相关的 Game Object 名称与 ID</span></span><br><span class="line">    opts_get_voices = &#123;</span><br><span class="line">        <span class="string">"return"</span>: [</span><br><span class="line">            <span class="string">"objectName"</span>, <span class="string">"isVirtual"</span>, <span class="string">"gameObjectName"</span>, <span class="string">"gameObjectID"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取当前时间点上存在的 Bus</span></span><br><span class="line">    opts_get_busses = &#123;</span><br><span class="line">        <span class="string">"return"</span>: [</span><br><span class="line">            <span class="string">"objectName"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回当前活跃 RTPC ID 与值</span></span><br><span class="line">    log_rtpcs = client.call(<span class="string">"ak.wwise.core.profiler.getRTPCs"</span>, args_times)[<span class="string">"return"</span>]</span><br><span class="line">    <span class="comment"># 功能见上方相关函数的注释</span></span><br><span class="line">    log_voices = client.call(<span class="string">"ak.wwise.core.profiler.getVoices"</span>, args_times, options=opts_get_voices)[<span class="string">"return"</span>]</span><br><span class="line">    log_busses = client.call(<span class="string">"ak.wwise.core.profiler.getBusses"</span>, args_times, options=opts_get_busses)[<span class="string">"return"</span>]</span><br></pre></td></tr></table></figure><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2><p>下一篇文章中，我们会讨论执行类中剩下的模块，包括 UI 操作模块 <code>wwise.ui</code>、WAAPI 模块 <code>wwise.waapi</code>、Debug 模块 <code>wwise.debug</code>及声音引擎模块 <code>soundengine</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 音频编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>必看须知</title>
      <link href="/2020/09/03/%E6%9C%AC%E5%8F%B7%E9%A1%BB%E7%9F%A5/"/>
      <url>/2020/09/03/%E6%9C%AC%E5%8F%B7%E9%A1%BB%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>下面是在观看本号内容前的一些须知，还请您花费两分钟时间观看一下。</p><h2 id="关于文章更新频次"><a href="#关于文章更新频次" class="headerlink" title="关于文章更新频次"></a>关于文章更新频次</h2><blockquote><p>我认为只有更新过的技术文章，才会体现出作者对这篇作品的重视态度和诚意。</p></blockquote><p>基于这个概念，<strong>本公众号内所有文章都会不定时更新，取决于文章内容是否会改变、是否抓到了文章中的 Bug 等。</strong>对我来说只有下方各位真挚的留言有收藏意义，而点击、在看、赞这类都如过眼云烟，能给各位提供有价值的分享才是我的初心。<br>所以当诸位发现某些老文突然冠以“第 N 版”诈尸出现时请勿奇怪，可打开文章看看开头我的更新之处在哪里。</p><h2 id="关于本号文章的组织结构"><a href="#关于本号文章的组织结构" class="headerlink" title="关于本号文章的组织结构"></a>关于本号文章的组织结构</h2><p><strong>有结构的知识分享无比重要。</strong><br>目前来说，建议诸位通过公众号主菜单的历史文章进行文章查找。<br>本公众号内所有文章均以使用“话题”功能进行整理，等过一阵我会用一篇专门的整理文章来取代历史文章，通过“话题”功能把整理好的文章结构呈现给大家。</p><h2 id="更优的阅读方案"><a href="#更优的阅读方案" class="headerlink" title="更优的阅读方案"></a>更优的阅读方案</h2><p>以后涉及代码类的文章我会可能在 GitHub 上也建立一份，以提供更优秀的阅读和传播方案。<br>本人的个人博客比较混乱，待完善完毕后也会向诸位开放。</p><h2 id="关于转载"><a href="#关于转载" class="headerlink" title="关于转载"></a>关于转载</h2><p>如需转载，请对公众号直接发消息，我看到后会给与回复。</p><h2 id="关于打赏"><a href="#关于打赏" class="headerlink" title="关于打赏"></a>关于打赏</h2><p>人生苦短，世事无常，能通过技术分享的文字与诸君相识是一种缘分。我把打赏金额默认高于50的额度全部去掉了，技术分享遵循开源精神，不求赚取大额钱财。<br>若是诸位看到对自己有帮助的文章，愿意请我喝杯咖啡，那从瓶装咖啡到星巴克我都没问题。：）<br>不请亦无妨，千万不要在意这些细节，能够分享对大家有用的研究我很开心，您的阅读和收获才是对我最大的鼓励​。<br><strong>感谢诸位。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 置顶 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈阅读路线、以及阅读和做笔记的方法</title>
      <link href="/2020/09/02/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B9%A6%E4%BB%A5%E5%8F%8A%E6%80%8E%E4%B9%88%E8%AF%BB/"/>
      <url>/2020/09/02/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B9%A6%E4%BB%A5%E5%8F%8A%E6%80%8E%E4%B9%88%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>今天分享一下之前所列书单的推荐阅读路线。其实对这份书单来说，尤其是经过我重构后的第二版，本身就已经具有良好的可阅读及可选择性。但因为后台收到了一些朋友的询问，想咨询下学习路线推荐。为此，写一篇小文聊聊这个问题，顺便简单谈谈读书之道。因为这种文章技术含量不高，故在第二版书单推送时放在头条下方，以免有水文章之嫌。<br>但是互联网行业的技术日新月异，书籍的时效性是否能跟得上谁也说不准。文档和实践远比书籍重要，但书籍被整理后的知识密度也不可小视，这部分怎么取舍就还靠大家自己权衡了。</p><blockquote><p>核心原则：</p><ul><li>对英文不好的同学来说，<strong>谨遵 i + 1 原则</strong>。不要一口吃个胖子上来就对着原版书和英文文档开啃，评估好自己的英文水平再决定材料选择。</li><li>母语学习效率永远高于外语学习，除非对英文水平有信心，不然<strong>请尽量优先选择材料的中文版本</strong>。学有余力后，再对照英文原版或英文新版查漏补缺。</li><li>所有的领域都有入门或导论类书籍，找一本好的看完，其余的同类书通过跳读，查漏补缺即可，<strong>对任何书都一个字不差的阅读是最低效的阅读</strong>。</li><li>学习有方法，读书有方法，记笔记也有方法。方法无好坏，捕鼠无孬猫，选择适合自己的才最重要。</li></ul></blockquote><h2 id="浅谈阅读路线的选择"><a href="#浅谈阅读路线的选择" class="headerlink" title="浅谈阅读路线的选择"></a>浅谈阅读路线的选择</h2><p>对于图书推荐，主要基于书籍内容、阅读难易度、资料时效性的综合考量。</p><h3 id="1-1-游戏音频入门"><a href="#1-1-游戏音频入门" class="headerlink" title="1.1 游戏音频入门"></a>1.1 游戏音频入门</h3><p>如果对游戏音频所知甚少，想要入行，在“游戏音频导论”栏目中找几本适合自己的看一下。我个人建议优先阅读这些：</p><ul><li>《游戏音频完全指南（第2版）》</li><li><em>The Game Audio Strategy Guide: A Practical Course</em></li><li><em>Principles of Game Audio and Sound Design</em></li><li><em>The Bible of Getting a Job in Game Audio, 2020 Edition</em></li></ul><p><strong>最后这本关于找工作的“书”，本质上说是一份整理过后的文档，但它的详细和时效性非常好，是不可多得的入行好资料。</strong><br>成为能够独当一面的游戏音频设计师要学的远远不止这些，建议在书中快速汲取信息后画出自己想要发展的技能树，按照技能树进行下一步的阅读或回溯补充。</p><h3 id="1-2-精进声音设计"><a href="#1-2-精进声音设计" class="headerlink" title="1.2 精进声音设计"></a>1.2 精进声音设计</h3><p>鉴于不是所有公司都有完全从0开始的声音资源制作条件（如大量的引入实录、Foley、合成器），从阅读角度来说可以分成两部分。</p><h4 id="如果是为了精进音效库声音设计的审美水平的话："><a href="#如果是为了精进音效库声音设计的审美水平的话：" class="headerlink" title="如果是为了精进音效库声音设计的审美水平的话："></a>如果是为了精进音效库声音设计的审美水平的话：</h4><ul><li>《审美空间延伸与拓展: 电影声音艺术理论》</li><li>《声音设计: 电影中语言，音乐和音响的表现（第2版）》</li><li>《视听：幻觉的构建》</li><li>《动画声音设计》</li><li><em>Sound Design and Science Fiction</em></li><li>我的那篇关于声音设计词汇学习的文章</li></ul><h4 id="如果是为了精进合成器实用技术的话："><a href="#如果是为了精进合成器实用技术的话：" class="headerlink" title="如果是为了精进合成器实用技术的话："></a>如果是为了精进合成器实用技术的话：</h4><ul><li>《声音合成与采样技术（第3版）》</li><li>《自己动手做声音: 声音合成与制作基础》</li><li><em>Creating Sounds from Scratch: A Practical Guide to Music Synthesis for Producers and Composers</em></li><li><em>Welsh’s Synthesizer Cookbook: Synthesizer Programming, Sound Analysis, and Universal Patch Book 1、2</em><h3 id="1-3-技术音频入门"><a href="#1-3-技术音频入门" class="headerlink" title="1.3 技术音频入门"></a>1.3 技术音频入门</h3>技术音频需要学的东西太多了，我自己也在努力学习中。感觉除了导论类书籍之外，引擎、编程等大量东西需要学，这里只粗浅的列出我书单中我认为值得推荐的给大家。</li><li>《游戏引擎架构》</li><li><em>Game Audio Programming: Principles and Practices 1、2、3</em></li><li><em>Game Audio: Tales of a Technical Sound Designer 1、2</em></li><li><em>Game Audio Development with Unity 5.X</em></li><li><em>Game Audio Implementation: A Practical Guide Using the Unreal Engine</em></li><li><em>Game Audio with FMOD and Unity</em></li></ul><h2 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h2><p>阅读方法论可以说是遍地开花了，但还是推荐最经典的那本《如何阅读一本书》，在多年前的大学时期这本书对我有指导性意义。除此之外，别的阅读类书籍我并不是特别推荐，大多都是二次加工或融合几种不同方法的读物，非常无趣。<br>其实对于阅读，还是要想清楚你的目的。技术类书籍的目的无疑就是一点，获取信息整合到头脑当中，所以如何做笔记和提炼书籍内容才是最重要的。</p><h2 id="如何做笔记"><a href="#如何做笔记" class="headerlink" title="如何做笔记"></a>如何做笔记</h2><p>关于如何做笔记，其实研究明白思维导图和一些衍生类软件就足矣了，建议多看看不同专业的阅读笔记整理方法，跨行业的经验往往有着碾压性的效果。<br>如果要简单谈一下的话，那就是阅读的同时粗摘录，阅读结束后精细整理，再整理再整理，把知识变成主题阅读一样的一张网。这样无论是复习还是当做自己的知识库，这本书才是真正的为你所用了。对文档、视频教程来说亦是如此，看完就扔，扔了就忘，倒不如不看。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏音频 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>人人都能用 WAAPI（一）概述</title>
      <link href="/2020/09/01/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/09/01/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>去年下半年我接触到了 WAAPI（Wwise Authoring API），作为头脑不怎么灵光的非专业程序员，看到 WAMP、JSON 等陌生概念直犯晕。毕竟除了官方文档，只有极少数的开发者分享视频、文章和项目可参考。因为不太好意思麻烦别人，只好自己在这一年中断断续续的闷头尝试，踩了不少坑。<br>引用 Linus 的一句名言：</p><blockquote><p>In open source, we feel strongly that to really do something well, you have to get a lot of people involved.  — Linus Torvalds</p></blockquote><p><strong>思想只有被传播才能体现价值</strong>，为了体现开源精神，决定分享一系列 WAAPI 指南给大家。《人人都能用 WAAPI》系列文则更贴近对官方文档的补充，会更加友好且详细。<br>对初学者友好不代表从零讲起，人人都能用 WAAPI 只是代表大家都有潜力去掌握这门优秀的技能。<strong>因为个人习惯使用 Python，所以前置知识只讨论与其相关的内容。你也可以使用 WAAPI 支持的其他语言来进行远程调用（使用 C# 调用 WAAPI 其实也很简单）。</strong></p><blockquote><p>本系列文章阅读需要的前置知识：</p><ul><li>会配置开发环境，掌握 Python、Anaconda、pip、VS Code、PyCharm 等的安装使用。</li><li>掌握简单的 Python 语法。</li><li>对 Wwise 功能有较全面的认知，因为 WAAPI 涉及的功能比较广。</li><li>对现有 Wwise 工作流有优化的构思。</li><li>对思维导图有些许认知。</li></ul></blockquote><p>本文目录：</p><p>[toc]</p><h2 id="为什么要用-WAAPI？"><a href="#为什么要用-WAAPI？" class="headerlink" title="为什么要用 WAAPI？"></a>为什么要用 WAAPI？</h2><h3 id="1-1-请问你在用-Wwise-时怀疑过以下人生吗？"><a href="#1-1-请问你在用-Wwise-时怀疑过以下人生吗？" class="headerlink" title="1.1. 请问你在用 Wwise 时怀疑过以下人生吗？"></a>1.1. 请问你在用 Wwise 时怀疑过以下人生吗？</h3><ul><li>能不能少一些点击和拖拽操作？？</li><li>成百上千（3A 项目上万也正常）的资源导入后做播放规则想死怎么办？？</li><li>使用 Game Sync、Event、SoundBank 时能不能智能连接逻辑？？</li><li>不能把 DAW 和 Wwise 联动吗？？</li><li>如何联动 CI 系统优化持续集成管线？？</li><li>etc.</li></ul><h3 id="1-2-WAAPI-的目的：解放繁琐的工作流"><a href="#1-2-WAAPI-的目的：解放繁琐的工作流" class="headerlink" title="1.2. WAAPI 的目的：解放繁琐的工作流"></a>1.2. WAAPI 的目的：解放繁琐的工作流</h3><p>如果你有上面的烦恼，WAAPI 对你无疑是必备利器。<br>作为 Wwise 2017.1 中的重要的功能补充，WAAPI 诞生就被赋予了解决一切繁琐的使命。<br>从简单操作中的获取工程信息、导入音频文件、设定容器层级，到声音引擎级的发送事件、设定 Game Sync 等操作，WAAPI 均可完成。是 Wwise 音频设计师工作流改进中的必备一环，<strong>利用好 WAAPI，能够节省大量时间，让声音设计师有更多精力放在艺术创作上。</strong><br>在本文发布的当下，可能仍有公司未对技术音频（Game Audio Programmer / Technical Sound Designer）这个职位进行配备。如果碰巧你是这些公司的雇员，本文会对你很有帮助。<strong>对工作中重复和可优化的步骤进行不断优化，这才是智者的工作模式。与其等待戈多，不如自己动手。</strong></p><h3 id="1-3-官方的资料不够全吗？"><a href="#1-3-官方的资料不够全吗？" class="headerlink" title="1.3. 官方的资料不够全吗？"></a>1.3. 官方的资料不够全吗？</h3><p>Wwise 的官方文档是目前所有音频中间件中内容最完善，且本地化做的最好的一个。但文档中关于 WAAPI 的内容，对阅读对象的要求<strong>更偏向是有一定技术背景的人</strong>，存在些许门槛也是必然的。这系列文章的写作目的正是针对这一点，希望能对官网文档做出有用的补充，<br>官方博客中也有关于 WAAPI 好文，学有余力的朋友可以抽空翻阅。</p><h2 id="妙用思维导图整理-WAAPI"><a href="#妙用思维导图整理-WAAPI" class="headerlink" title="妙用思维导图整理 WAAPI"></a>妙用思维导图整理 WAAPI</h2><h3 id="2-1-通过导图理清-WAAPI-脉络"><a href="#2-1-通过导图理清-WAAPI-脉络" class="headerlink" title="2.1 通过导图理清 WAAPI 脉络"></a>2.1 通过导图理清 WAAPI 脉络</h3><p>思维导图作为一个重要的学习工具，在长达七八年中曾承载过我无数的发散思维。<br>如下图所示，<strong> WAAPI 这种点语法套大饼形式的 API（例如重要的查询 API 为 ak.wwise.core.object.get）在文档中检索时非常不便。</strong><br><img src="/images/%E7%B9%81%E7%90%90%E7%9A%84API.png" alt="繁琐的API"></p><p>那么有什么办法能够优雅的解决这个需求呢?<br>Bingo！思维导图一下出现在我脑中。<br>我通过对 WAAPI 进行逻辑归纳并整理为导图，以 ak.wwise.core.object.get 为例：</p><ol><li>忽略 ak（复用时可把 ak 视为等同为导图中心），分别把其拆为 wwise.core - object - get 形式的节点。</li><li>在此基础上，将 API 按功能重新排布顺序，并使用外框整理同类型的功能。</li></ol><p><img src="/images/%E5%AF%BC%E5%9B%BE1.png" alt="导图1"><br>导图概览</p><p><img src="/images/%E5%AF%BC%E5%9B%BE2.png" alt="导图2"><br>局部样例</p><h3 id="2-2-导入知识库进行知识完备"><a href="#2-2-导入知识库进行知识完备" class="headerlink" title="2.2. 导入知识库进行知识完备"></a>2.2. 导入知识库进行知识完备</h3><p>在此基础上就已完成 WAAPI 逻辑体系的初级构建，随后导入 MarginNote 3，在我的 Wwise 知识库中进行相关完善。<br><img src="/images/%E5%AF%BC%E5%9B%BE3.png" alt="导图3"><br>MN3 中的知识完备版</p><p>至此，WAAPI 的整体脉络清晰的出现在我眼前。对于 API 这种工具性极强的存在，用合理逻辑建立的“武器库”是高效利用的前提。这也是更最符合我自己理解记忆的方法，大家亦可根据自己的思维习惯选择适合自己的整理方法。<br><strong>这个导图我不会直接分享，</strong>原因很简单：看我的描述相信大家都能做出一样的导图，而知识库版本导图，这系列文章正是基于它的展开（会比导图详细的多），分享并没有什么意义。<br>相信有心的同学也会根据自己的想法重做一次，用什么思路无所谓。幕布和 XMind 这种导图工具或者笔记类软件均可，<strong>重点是亲自上手实现自己的版本，否则毫无意义。</strong></p><h2 id="系列文章架构"><a href="#系列文章架构" class="headerlink" title="系列文章架构"></a>系列文章架构</h2><p>了解我的 WAAPI 分类方法后，我们聊聊这系列文章的编写架构。<br>因 WAAPI 功能分为 Functions（执行）与 Topics（订阅）两种，两者的区别会在下面的章节中讲解。我会以这两者为主干，对下属分支进行拆分编写（注：我仍然省略了开头的“ak.“） 。<br>按照字数来划分，预计架构如下：</p><ol><li>概述</li><li>wwise.core（2-4为 Functions 类）</li><li>wwise.ui, wwise.debug, wwise.waapi</li><li>soundengine</li><li>wwise.core, wwise.debug, wwise.ui（Topics 类）</li><li>在游戏引擎中调用 WAAPI</li><li>完整实例</li></ol><h2 id="WAAPI-基础"><a href="#WAAPI-基础" class="headerlink" title="WAAPI 基础"></a>WAAPI 基础</h2><h3 id="4-1-什么是-WAAPI？"><a href="#4-1-什么是-WAAPI？" class="headerlink" title="4.1. 什么是 WAAPI？"></a>4.1. 什么是 WAAPI？</h3><p>WAAPI（Wwise Authoring API）作为 Wwise 的重要组件，通过调用 API 即可让 Wwise 直接执行大量操作，而不必通过传统方式操作鼠标键盘达成同样目的。<br>它的可控制范围很广，从 Wwise 的界面层级控制（视图、选项、命令）到核心功能控制（例如快速添加音频文件），到声音引擎层级的功能（RTPC Value、Post Event 等）均可完成。<br>文档中关于 WAAPI 的简介：<br><a href="https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi.html" target="_blank" rel="noopener">https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi.html</a></p><h3 id="4-2-WAAPI-支持的语言类型和使用方式"><a href="#4-2-WAAPI-支持的语言类型和使用方式" class="headerlink" title="4.2. WAAPI 支持的语言类型和使用方式"></a>4.2. WAAPI 支持的语言类型和使用方式</h3><h4 id="可用的编程语言"><a href="#可用的编程语言" class="headerlink" title="可用的编程语言"></a>可用的编程语言</h4><p>WAAPI 可通过 C++、C#、JavaScript、Python 等多种语言调用，对于初学者来说后三者都比较简单（其中 Python 需3.6以上版本，Python 2使用起来比较麻烦，并不推荐）。如果没有在插件中调用 WAAPI 的需求，可不考虑使用 C++。</p><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>WAAPI 提供三种调用方式：WAMP、HTTP POST、Wwise 插件中调用。<br>通常情况下我们只会使用 WAMP，因为只有这种方式才能支持执行和订阅两种类型的使用方法。<br>那么什么是 WAMP 呢？<br>这是一种通过 WebSocket 进行通信的方式。如果对网络通信原理没有了解的话，可以把它简单理解成是通过网络传输信息的方法，它需要 IP 地址和端口来满足通讯需求，所以 WAAPI 的使用过程中需要提供这两个参数。<br>当我们的程序通过 WAMP 和 Wwise 建立连接后，才能执行之后所需的操作。<br>官方文档中关于调用方式的介绍：<br><a href="https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi_gettingstarted.html" target="_blank" rel="noopener">https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi_gettingstarted.html</a></p><h3 id="4-3-配置开发环境"><a href="#4-3-配置开发环境" class="headerlink" title="4.3. 配置开发环境"></a>4.3. 配置开发环境</h3><blockquote><p>出于个人的写作习惯，开发环境这种重复造轮子的事情我不会再写一次。但会分享给大家较好的教程连接，请大家根据文内介绍的方法进行开发环境配置，顺便感谢文中作者的无私分享！</p></blockquote><p><strong>因为 Conda 中并没有 WAAPI 所需的 waapi-client 包，所以初学者懒得折腾 Anaconda 的话，建议直接用 pip 安装 waapi-client。</strong><br>如果跟我一样使用 Anaconda 管理开发环境，<strong>我推荐使用官方文档中的方法安装 Conda 中没收录的包。即先在环境中安装 pip ，再通过 Conda 里的 pip 管理 Conda 中没有的包。</strong>此部分文档我在下方有附上链接。<br>（初学者请不要看这句话）至于 <code>conda skeleton pypi package</code> 再 <code>conda build package</code> 这种 Conda 装 pypi 的方法我没试过，就不在这里讨论了。</p><h4 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h4><p><a href="https://segmentfault.com/a/1190000022797661" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022797661</a></p><h4 id="配置-Anaconda-并在本地环境中通过-pip-添加-waapi-client"><a href="#配置-Anaconda-并在本地环境中通过-pip-添加-waapi-client" class="headerlink" title="配置 Anaconda 并在本地环境中通过 pip 添加 waapi-client"></a>配置 Anaconda 并在本地环境中通过 pip 添加 waapi-client</h4><p><a href="https://zhuanlan.zhihu.com/p/25198543" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25198543</a><br><a href="https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-pkgs.html#installing-non-conda-packages" target="_blank" rel="noopener">https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-pkgs.html#installing-non-conda-packages</a><br><strong>注意：使用 pip 的同学可直接在 Python 3 环境下执行 <code>pip install waapi-client</code></strong></p><h4 id="配置-VS-Code-开发环境"><a href="#配置-VS-Code-开发环境" class="headerlink" title="配置 VS Code 开发环境"></a>配置 VS Code 开发环境</h4><p><a href="https://zhuanlan.zhihu.com/p/30324113" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30324113</a></p><h4 id="在-Wwise-中开启-WAAPI-支持"><a href="#在-Wwise-中开启-WAAPI-支持" class="headerlink" title="在 Wwise 中开启 WAAPI 支持"></a>在 Wwise 中开启 WAAPI 支持</h4><p><a href="https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi_prepare.html" target="_blank" rel="noopener">https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi_prepare.html</a></p><h3 id="4-4-Functions（执行类）与-Topics（订阅类）在功能上的区别"><a href="#4-4-Functions（执行类）与-Topics（订阅类）在功能上的区别" class="headerlink" title="4.4. Functions（执行类）与 Topics（订阅类）在功能上的区别"></a>4.4. Functions（执行类）与 Topics（订阅类）在功能上的区别</h3><blockquote><p>这里“执行类”和“订阅类”属于个人的称呼习惯，“执行类”代表功能为执行某些操作的 API，“订阅类”为执行后等待某些结果返回的 API。在 Wwise 官方文档中的对应术语为“远程调用”和“发布&amp;订阅”。</p></blockquote><p>Functions（执行类）：<br>与名字相同，其中所有的 API 均为执行具体的操作。<br>通过代码调用某个 API 后，会执行一次对应的操作。WAAPI 的三种使用方式中都可完成对“执行类”接口的调用，但 HTTP POST 方式下不具有最佳性能。<br>Topics（订阅类）：<br>当调用“订阅类”接口后，程序会等待 Wwise 中对应的动作发生。如果订阅了一个对象创建的动作，那只有动作被执行后才会收到发回的信息。这种调用方法只有 WAMP 能够做到，其余两种使用方法无法完成。</p><h3 id="4-5-什么是-JSON-与-WAAPI-文档的阅读方法"><a href="#4-5-什么是-JSON-与-WAAPI-文档的阅读方法" class="headerlink" title="4.5. 什么是 JSON 与 WAAPI 文档的阅读方法"></a>4.5. 什么是 JSON 与 WAAPI 文档的阅读方法</h3><h4 id="JSON-的概念"><a href="#JSON-的概念" class="headerlink" title="JSON 的概念"></a>JSON 的概念</h4><p>非专业程序员出身的人（比如我本人）第一次看到 WAAPI 的参数时都会奇怪，JSON 到底是什么东西？<br><strong>JSON（JavaScript Object Notation）是一种轻量的数据交换格式，用独立的文本格式在编程语言外存储和表示数据，本质上就是被格式化的字符串。</strong>如果有同学熟悉 XML 的格式，看到 JSON 应该比较眼熟这种定义格式。<br>之所以要了解它，是因为在远程调用 WAAPI 时无论传入参数还是返回值都要使用此类格式，<strong>作为阅读文档之前的基础，我们先要花点时间搞清它。</strong>为了方便理解，我们先看一下简单的例子。</p><h4 id="以-ak-wwise-core-object-create-为例详解-Arguments-和-Result-的含义"><a href="#以-ak-wwise-core-object-create-为例详解-Arguments-和-Result-的含义" class="headerlink" title="以 ak.wwise.core.object.create 为例详解 Arguments 和 Result 的含义"></a>以 <code>ak.wwise.core.object.create</code> 为例详解 Arguments 和 Result 的含义</h4><p>我们先看一下 <code>create</code> 的文档，会发现网页中存在两个表格。<br><img src="/images/%E5%8F%82%E6%95%B01.png" alt="参数1"><br>文档页面中的 Arguments 表格<br><img src="/images/%E7%BB%93%E6%9E%9C1-1.png" alt="结果1"><br>文档页面中的 Result 表格<br>可见表格中三列的分别为参数名、参数类型、功能描述。<br>我们都知道，定义了参数且设定 return 语句的函数在使用过程中可以传入参数与获得返回值。<strong>这两个表中，Arguments（参数）即函数调用时要传入的参数，Result（结果）则是它完成远程调用后返回的结果，并且如本小节开头所述，均为 JSON 格式。</strong><br>请注意，<strong>在 Arguments（参数）底部备注了星号代表必须提供的参数，这些参数必须提供，不带星号的参数则根据所需选填。</strong><br>我们先看 Arguments 表格，其中有三种代表性的参数模式：</p><ol><li><code>name *</code> 行只需要一个 string（字符串）作为参数用来定义名字，即在 JSON 参数中只需要提供一个字符串格式的名字即可。但为什么 <code>parent *</code> 却有四行参数？请看 <code>parent *</code> 的第一行表格，发现是 <code>any of:</code>，这就代表其实我们可选用下面三种参数类型的任意一种来定义参数。我们仔细观察，果然下面三行分别为父级的名字（需全局唯一）、GUID、父级完整路径。</li><li><code>notes</code> 行没有星号，这是一个非必须参数，由此可知在使用 <code>create</code> 时我们可根据需求决定是否传入笔记。</li><li><code>children</code> 可能让大家产生疑问，为什么表示方法和前面不是一个模式。其实因为它是一个数组，需要传入的参数要写在数组内。所以必须的两项参数 <code>children[...].type *</code> 和 <code>children[...].name *</code> 中的 type 和 name 实际上是要写在数组当中的。</li></ol><p>对于 Result（结果）表来说，大多数情况下只要你能弄明白传入的 Arguments，一般都能猜出来会有什么返回值。比如当你使用 <code>create</code> 创建了一些对象，根据自然逻辑来判断， Wwise 应该会返回已创建的对象名称、GUID、层级信息。毕竟如果创建不成功肯定会报错，所以创建成功后应该返回刚创建的对象才符合逻辑。观察 Result 表后发现确实如此，的确是这三条返回值。</p><h4 id="通过-ak-wwise-core-object-create-理解-JSON"><a href="#通过-ak-wwise-core-object-create-理解-JSON" class="headerlink" title="通过 ak.wwise.core.object.create 理解 JSON"></a>通过 <code>ak.wwise.core.object.create</code> 理解 JSON</h4><p>在上小节中理解完文档中参数和返回值表格的含义后，你肯定会想，这些参数需要怎么写才能让 WAAPI 正确接收呢？<br>为此，我们看一下本功能所使用的参数与返回值在实际中的样子，它们就是以 JSON 格式定义的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行 ak.wwise.core.object.create 所需的参数</span></span><br><span class="line">args = &#123;</span><br><span class="line">    <span class="string">"parent"</span>: parent_guid, </span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"Sound"</span>, </span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Simple_SFX"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 ak.wwise.core.object.create 并传入 args 后获得的结果</span></span><br><span class="line">result = &#123;</span><br><span class="line">    <span class="string">"id"</span>: object_guid, </span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Simple_SFX"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由例子可见，<strong>实际上 JSON 格式在 Python 中相当于一个字典。</strong>但与字典不同的是 JSON 内所有引号都需要使用双引号，而且 JSON 块应该为字符串类型。<strong>不过在 Python + WAAPI 的环境下似乎对这两条规则并没有进行严格校验</strong>，在使用过程中不必使用 Python 的 <code>json</code> 模块进行格式转换，直接按照字典格式书写也可正常工作。<br><img src="/images/%E5%AF%B9%E7%85%A7%E8%A1%A8.png" alt="对照表"><br>对照 Python 和 JSON 格式的对照表，亦可看出两者在数据结构上的对应关系。在使用 WAAPI 时这会是我们主要的操作对象，根据文档合理的设定参数才能获得我们想要的结果。</p><h4 id="如何把-JSON-的语法表格式化以方便阅读？"><a href="#如何把-JSON-的语法表格式化以方便阅读？" class="headerlink" title="如何把 JSON 的语法表格式化以方便阅读？"></a>如何把 JSON 的语法表格式化以方便阅读？</h4><p>WAAPI 的参数文档使用 JSON 来进行定义，这类格式的可读性非常不好。为了方便在使用 WAAPI 更清晰的参考各种参数。<strong>我们需要对其进行格式化，以把 JSON 彻底拆成方便阅读的形态。</strong><br>下面是 <code>create</code> 的传入参数语法：<br><img src="/images/%E5%8F%82%E6%95%B02.png" alt="参数2"></p><p>可读性非常的糟糕。<strong>在此我们使用 JSON 格式化工具进行操作，</strong>对于这个需求，个人习惯使用 JSON Editor（<a href="https://jsoneditoronline.org/）" target="_blank" rel="noopener">https://jsoneditoronline.org/）</a><br>还记得上图混乱的格式吗？用 JSON Editor 处理后会变的非常清晰！<br><img src="/images/JSON1.png" alt="JSON1"></p><p>当 Arguments 经过格式化后，可清晰看到 required 中注明了所需参数，properties 中提供了各种参数的类型和描述。下面还有两个属性。其中 <code>localDefinitions</code> 里实际就是上面提过的 <code>children</code> 里的定义，作为子类放进了这里。而 <code>patternProperties</code> 是通过 @propertyName 设置对象属性时可能出现的值的类型。</p><p><img src="/images/JSON2.png" alt="JSON2"></p><p>Result 经过格式化后也是一样，现在清晰可见其默认的三个返回值：GUID、创建的子对象、名称。在经过格式化后，JSON 无论是作为参数还是返回值来说都更易读了。<br><strong>当你想要调用某个 WAAPI 功能时，只需要在 JSON 的框架下依据文档修改所需的传入参数，再进行远程调用即可。</strong><br>如果想要清晰的理解 JSON 和参数之间对应的关系，一开始需要多阅读示例。我建议大家闲暇之余阅读 Wwise Authoring API Examples Index 中的所有例子。因其书写很简约，建议读透本文的描述再去阅读。<br>下面我们看一下参数的在完整程序中的用法。在官方文档中有个例子，功能是创建一个 Random Container 并且在其中同时创建两个 Sound SFX，这是它所提供 Arguments 的正确使用方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 示例代码里提供的 Arguments</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"># 父级的 GUID、类型、名称、属性值</span></span><br><span class="line">    <span class="string">"parent"</span>: <span class="string">"&#123;7A12D08F-B0D9-4403-9EFA-2E6338C197C1&#125;"</span>, </span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"RandomSequenceContainer"</span>, </span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Boom"</span>, </span><br><span class="line">    <span class="string">"@RandomOrSequence"</span>: <span class="number">1</span>, </span><br><span class="line">    <span class="comment"># 子级新对象的名称与类型</span></span><br><span class="line">    <span class="string">"children"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"Sound"</span>, </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"A"</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"Sound"</span>, </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"B"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 真实应用情况下的 Arguments</span></span><br><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> WaapiClient() <span class="keyword">as</span> client:</span><br><span class="line">        <span class="comment"># 把 JSON 格式的 Arguments 赋值给 args</span></span><br><span class="line">        args = &#123;</span><br><span class="line">            <span class="string">"parent"</span>: <span class="string">"&#123;7A12D08F-B0D9-4403-9EFA-2E6338C197C1&#125;"</span>, </span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"RandomSequenceContainer"</span>, </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"Boom"</span>, </span><br><span class="line">            <span class="string">"@RandomOrSequence"</span>: <span class="number">1</span>, </span><br><span class="line">            <span class="string">"children"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"Sound"</span>, </span><br><span class="line">                    <span class="string">"name"</span>: <span class="string">"A"</span></span><br><span class="line">                &#125;, </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"Sound"</span>, </span><br><span class="line">                    <span class="string">"name"</span>: <span class="string">"B"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 执行远程调用，第一个参数为 API 名，第二个为传入的 JSON 参数</span></span><br><span class="line">        client.call(<span class="string">"ak.wwise.core.object.create"</span>, args)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">    print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 3. 远程调用结束后控制台返回的结果，包括父级 GUID、父级容器名、子级 GUID、子级名称</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"&#123;66666666-7777-8888-9999-AAAAAAAAAAAA&#125;"</span>, </span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Boom"</span>, </span><br><span class="line">    <span class="string">"children"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"id"</span>: <span class="string">"&#123;46813545-2168-3547-8328-681AB678D6F5&#125;"</span>, </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"A"</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"id"</span>: <span class="string">"&#123;68465134-2548-2377-3541-321354318ABD&#125;"</span>, </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"B"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Topics（订阅类）中的参数为什么会有-Options-和-Publish？"><a href="#Topics（订阅类）中的参数为什么会有-Options-和-Publish？" class="headerlink" title="Topics（订阅类）中的参数为什么会有 Options 和 Publish？"></a>Topics（订阅类）中的参数为什么会有 Options 和 Publish？</h4><p>如果你仔细看过文档，会发现 Topics 类中的参数有所不同，<strong>它们的文档中只有 Options 和 Publish，这两个新参数和 Functions 类的 Arguments、Result 有什么区别吗？</strong><br>其实意思差不多，大家要知道 <strong>Topics 类的功能实现是基于话题发布时被执行的回调函数。</strong>所以其中的 Options 用来定义在回调函数内的返回值类型，从而避免不必要的查询。而 Publish 可理解为 Result 的另一种形式，本质上还是用 JSON 格式返回信息，只不过返回的是被订阅话题被更改后所发布的信息。<br>另外，在 Functions 类中的也有特例，比如 <code>ak.wwise.core.audio.importTabDelimited</code>、<code>ak.wwise.core.object.get</code>、<code>ak.wwise.core.profiler.getBusses</code>、<code>ak.wwise.core.profiler.getVoices</code>，它们同时拥有 Arguments 和 Options，所以在使用的时候需要传入查询范围（Arguments）和查询选项（Options，可选）两个参数，这部分功能会在 <code>wwise.core</code> 分支再加以讨论。</p><h3 id="4-6-来一杯-Hello-Wwise！"><a href="#4-6-来一杯-Hello-Wwise！" class="headerlink" title="4.6. 来一杯 Hello Wwise！"></a>4.6. 来一杯 Hello Wwise！</h3><p>说了这么多理论，现在“麻烦给我的爱人来一杯 Hello Wwise 吧！”</p><h4 id="确定使用哪个-API"><a href="#确定使用哪个-API" class="headerlink" title="确定使用哪个 API"></a>确定使用哪个 API</h4><p>很明显，对于 Hello World 这种需求应该使用 Functions（执行类）完成。<br>通过寻找，我们发现一条美妙的 <code>ak.soundengine.postMsgMonitor</code> 可以完成需求。</p><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><p>为了方便理解，我直接在代码里写上详细的注释，请大家对照每行的代码来阅读。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 的异常处理 try…except… 语句，为 WAAPI 连接不上的情况增加了错误输出。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 通过默认的地址连接 Wwise，如果想连接本地不同的 Wwise 可在这里修改对应的端口</span></span><br><span class="line">    <span class="keyword">with</span> WaapiClient() <span class="keyword">as</span> client:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># WAAPI 传入和传回的参数都使用 JSON 格式，我们使用字典定义一段要打印出的信息为 "Hello Wwise!"</span></span><br><span class="line">        print_args = &#123;</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"Hello Wwise!"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 远程调用 ak.soundengine.postMsgMonitor，并传入刚才设定好的参数</span></span><br><span class="line">        client.call(<span class="string">"ak.soundengine.postMsgMonitor"</span>, print_args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">    print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br></pre></td></tr></table></figure></p><h4 id="执行效果"><a href="#执行效果" class="headerlink" title="执行效果"></a>执行效果</h4><p>运行脚本之前记住点击 Start Capture 来让 Profiler 开始采集信息。当脚本运行后，我们可获得以下信息：<br><img src="/images/%E7%BB%93%E6%9E%9C1.png" alt="结果1"><br>在 Logs 的 WAAPI 选项卡中，可看到产生了 WAMP 类型连接。</p><p><img src="/images/%E7%BB%93%E6%9E%9C2.png" alt="结果2"><code>children</code><br>在 Profiler 中可看到打印出的信息 “Hello Wwise!”</p><h2 id="WAAPI-两种应用（注释写到每一行）"><a href="#WAAPI-两种应用（注释写到每一行）" class="headerlink" title="WAAPI 两种应用（注释写到每一行）"></a>WAAPI 两种应用（注释写到每一行）</h2><h3 id="5-1-Functions（执行类）示例"><a href="#5-1-Functions（执行类）示例" class="headerlink" title="5.1. Functions（执行类）示例"></a>5.1. Functions（执行类）示例</h3><h4 id="不带参数"><a href="#不带参数" class="headerlink" title="不带参数"></a>不带参数</h4><p>通过 getInfo 功能获得当前工程的信息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 略</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 通过默认的地址连接 Wwise</span></span><br><span class="line">    <span class="keyword">with</span> WaapiClient() <span class="keyword">as</span> client:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 调用 ak.wwise.core.getInfo 来获取 Wwise 的全局信息并存到 result 中</span></span><br><span class="line">        result = client.call(<span class="string">"ak.wwise.core.getInfo"</span>)</span><br><span class="line">        <span class="comment"># 为了避免 print 单行打印，需通过 pprint 来打印刚得到 JSON 结果</span></span><br><span class="line">        pprint(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">    print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br></pre></td></tr></table></figure></p><p>代码执行后结果如下，如所希望的返回了工程信息<br><img src="/images/%E7%BB%93%E6%9E%9C3-1.png" alt="结果3"></p><h4 id="带参数"><a href="#带参数" class="headerlink" title="带参数"></a>带参数</h4><p>请参考“来一杯 Hello Wwise！”的例子</p><h3 id="5-2-Topics（订阅类）"><a href="#5-2-Topics（订阅类）" class="headerlink" title="5.2. Topics（订阅类）"></a>5.2. Topics（订阅类）</h3><p>通过 ak.wwise.core.object.nameChanged 功能订阅工程中对象名称被修改时的信息，当有对象被修改时返回新、旧名字及设定的返回值类型（本例中为 type）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 的异常处理 try…except…else… 语句</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    client = WaapiClient()</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">    print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 建立 on_name_changed() 准备在订阅中作为回调函数，用来接收字典形式的返回参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_name_changed</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 获取对象类型</span></span><br><span class="line">        obj_type = kwargs.get(<span class="string">"object"</span>, &#123;&#125;).get(<span class="string">"type"</span>)</span><br><span class="line">        <span class="comment"># 获取之前的名字</span></span><br><span class="line">        old_name = kwargs.get(<span class="string">"oldName"</span>)</span><br><span class="line">        <span class="comment"># 获取新名字</span></span><br><span class="line">        new_name = kwargs.get(<span class="string">"newName"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用 format 格式化函数进行输出信息（其中的&#123;&#125;代表 format() 函数中的对应变量），告知用户XXX类型的对象从 A 改名到了 B</span></span><br><span class="line">        print(<span class="string">"Object '&#123;&#125;' (of type '&#123;&#125;') was renamed to '&#123;&#125;'\n"</span>.format(old_name, obj_type, new_name))</span><br><span class="line">        <span class="comment"># 执行完成后断开 WAMP 连接，当然，要是想一直监控信息也可以不断开</span></span><br><span class="line">        client.disconnect()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 订阅所需主题，传入回调函数，使用选项 type 以让名称修改时传回的字典里直接有被修改的对象类型</span></span><br><span class="line">    handler = client.subscribe(<span class="string">"ak.wwise.core.object.nameChanged"</span>, on_name_changed, &#123;<span class="string">"return"</span>: [<span class="string">"type"</span>]&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印信息，提醒用户已经订阅了 ak.wwise.core.object.nameChanged 并建议用户执行重命名操作以验证脚本功能</span></span><br><span class="line">    print(<span class="string">"Subscribed 'ak.wwise.core.object.nameChanged', rename an object in Wwise"</span>)</span><br></pre></td></tr></table></figure></p><p>代码执行后结果如下，如所希望的告知了对象的名称变化及类型<br><img src="/images/%E7%BB%93%E6%9E%9C4.png" alt="结果4"></p><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2><p>在第二期中，会就执行类里比较重要的 wwise.core 分支进行分享。官网对于执行类的 API 大多提供了例子，但我可能会通过结合起来的小实例来进行演示，这样有便于大家更快掌握。如喜欢本文，请持续关注。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 音频编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何在30天内彻底搞定声音设计英文 Keyword？</title>
      <link href="/2020/08/28/%E4%B8%80%E7%AF%87%E6%96%87%E7%AA%81%E7%A0%B4%E9%9F%B3%E6%95%88%E5%8D%95%E8%AF%8D%E9%9A%9C%E7%A2%8D/"/>
      <url>/2020/08/28/%E4%B8%80%E7%AF%87%E6%96%87%E7%AA%81%E7%A0%B4%E9%9F%B3%E6%95%88%E5%8D%95%E8%AF%8D%E9%9A%9C%E7%A2%8D/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>游戏音频与声音设计书单一文发出后，<strong>有几个朋友专门找我探讨如何提升英文水平以阅读原版书或英文资料</strong>。确实如此，英文无论是在音效库检索还是阅读原版书或外文资料的过程中，都非常重要。<strong>为此，我写一篇技术性“不那么重”的小文与大家分享一下心得。</strong>为了覆盖到更多可能的受众，把标题定为《如何用30天搞定声音设计 Keyword》。<br>虽然略有些标题党之嫌，但还是会用一点篇幅谈谈英文学习的基础路线供诸君参考。在第二部分，会提供一种针对性的方法解决声音设计术语掌握不全这个难题，只对怎么背音效库单词有兴趣的朋友可直接跳到第二部分。</p><blockquote><p>第二版更新内容：</p><ul><li><strong>音效库元数据样本数由31万个单词扩大到了1753万个单词</strong>，选用的音效库元数据几乎涵盖市面上所有商业音效库。</li><li>补充欧陆词典的使用技巧问题。</li><li>增改错别字与文字表述内容。</li></ul></blockquote><p><em>本文目录：</em></p><p>[toc]</p><h2 id="怎么学英文？"><a href="#怎么学英文？" class="headerlink" title="怎么学英文？"></a>怎么学英文？</h2><h3 id="1-1-为什么要学英文？"><a href="#1-1-为什么要学英文？" class="headerlink" title="1.1. 为什么要学英文？"></a>1.1. 为什么要学英文？</h3><p>不论是否在互联网行业，只要工作中需要接触国外的技术，英文就是一个必不可缺的技能。<br><strong>对一个智慧的人来说，英文、快速学习、解决问题、复盘等都是要终身锻炼的能力</strong>。李笑来老师对于英文的重要性，以及元认知、心智等对概念在他的著作中都有所提及。如果你还在怀疑学习英语和提升心智到底能不能对你产生改变，可翻翻他的书，会更深的体会到英文和学习是如何改变一个小城青年的命运的。<br><strong>传统音频行业中，就曾有着大型调音台进入国内无人会用，结果负责翻译说明书的人反而成为了业内好手的佳话。</strong>毕竟原汁原味的文档才是最准确的信息来源，当然，别人嚼过后再输出的也不一定是垃圾，<strong>但熵增后的信息一定不如从源头获取来的知识直接和准确。</strong><br>英文不好的后果很多：</p><ul><li>遇到问题不敢用 Google 搜索，怕看不懂，更可怕的是因为英文不行，都不知道怎么使用英文网站。</li><li>想开口讲点英语，结果全是错误的发音。虽说口音不决定一个人的英文水平，但满嘴奇怪发音的人说自己英语好，谁敢信？</li></ul><p>如此恶性循环，职场生涯必然备受阻碍。与其这样，倒不如找一个安静的晚上好好问问自己，<strong>到底要一辈子都卡死在英文上面，还是下定决心一鼓作气干翻它？</strong><br>回想起来，在大学临毕业时及刚上班的那阵子，我忍着无数人的白眼和质疑去学习英文。大家笑着说：<strong>你学这东西有什么用？瞧瞧你练发音时候像SB一样!认命吧你学不会的！</strong><br>但我坚信人是可以改变的，除非你自己放弃，否则什么都拦不住你。</p><h3 id="1-2-英文学习的基本概念"><a href="#1-2-英文学习的基本概念" class="headerlink" title="1.2. 英文学习的基本概念"></a>1.2. 英文学习的基本概念</h3><p>我跟晓光兄（微博：<em>恶魔奶爸</em>）认识七年，如果有早期知乎用的比较多的朋友，或许对这位传播英语学习方法论的“恶魔的奶爸”有所耳闻。他的一套英文学习方法论对大学后期的我产生了深刻的影响，也让我从一个“主谓宾”都不知是什么的渣，变成了还算“有点”英文能力的人。最起码能看懂些原版书，看英文说明书也算毫无压力了。</p><blockquote><p>赖世雄老师说过：There’s no shortcut to good English, but we do have a right way.</p></blockquote><p>受晓光兄影响，我对 SLA（二语习得）有些许了解。其中 Stephen Krashen 博士提过几条关于学习英语非常重要的假说：</p><ol><li>Input 假说：听力和阅读大量的输入才决定英文的水平，而不是漫无目的的跟老外瞎聊。</li><li>i + 1（可理解性输入假说）：学习新材料的时候，要比当前的水平 i 稍微高一点，即 i + 1，这样才是有效的可理解性输入。如果 i + 5或10，这种非可理解性的输入毫无意义。比如你单词量稀烂，看本 MIT 出版的书绝对头晕脑胀还学不到东西。</li><li>Narrow Input 假说：输入的材料要相对狭窄，不要什么领域都抓。比如你既学音频行业术语，又刷 VOA 和经济学人，再背着本语法书，反而一事无成。</li><li>情绪机制：学习的材料一定是让人产生兴趣的，轻松自如的，这样才能激发学习热情。</li></ol><p>为了避免做战略上的矮子，学习英文之前必须要认清英文学习的基本概念，在学习的路上会少走很多弯路。<br>但我想说，<strong>不少国人都有速成的神功大力丸思想，想要背点单词就突破阅读，口语角混半年就搞定口语，这种是绝对不可取的。</strong>希望大家明白，英语学习是要长期投入的一件事。<br>有些人可能觉得来不及了，那么请问，大学时算来不及吗？工作两年算来不及吗？大家都知道那句话，种一棵树最好的时间是十年前，其次是现在。怎么到了英语就忘了？<br>希望有心突破语言障碍的朋友坚持下去，经过此场全球大劫，活下来的人应该更认识到生命的潜力，而不是继续自暴自弃。</p><h3 id="1-3-学习路线推荐"><a href="#1-3-学习路线推荐" class="headerlink" title="1.3. 学习路线推荐"></a>1.3. 学习路线推荐</h3><p>晓光兄之前有视频录制的英语学习方法论课、发音课等，但我翻了一下发现现在全都不卖了，英语公众号更是荒废状态。周一问了一下，果然他现在已经不做这块，只在微博专做职场相关内容。<br><img src="/images/%E5%A5%B6%E7%88%B8.png" alt="奶爸"></p><p>如上所述，推荐有心系统学习英文的同学阅读晓光兄的著作《把你的英语用起来》，其中伍君仪老师关于透析法的部分可以不看。本书可能只有淘宝有货，大家也可选择去各大平台购买电子版。<br>书中方法论简单总结大概是：</p><ul><li>音标和正确的发音是必须掌握的。</li><li>其次是通过赖世雄或 ESLPod 这类播讲材料在满足 Krashen 博士假说的情境下快速对听说读写建立概念，并辅佐以正确的语法概念。</li><li>后期辅佐阅读或美剧输入等，以提高输入量彻底征服英文。</li></ul><p>具体的部分还是建议参照书中的介绍进行学习，<strong>如有精力查找奶爸微信公众号历史文章的朋友也可翻翻他后期的新文章</strong>，核心的学习路线变化不大。<br>至于书籍推荐，目前针对音频类英语的学习书籍国内只有《录音专业英语》一本，而《音乐英语》等书籍更偏向于音专所需的词汇。这部分只好靠大家自己积累了，对音频类书籍测词频意义也不是很大。<br><strong>不过不排除以后我会对一些好书进行词频测试或蓝思值分析，或者进行拆书活动，有兴趣的朋友可保持关注。</strong></p><h2 id="30天搞定声音设计-Keyword"><a href="#30天搞定声音设计-Keyword" class="headerlink" title="30天搞定声音设计 Keyword"></a>30天搞定声音设计 Keyword</h2><p>不管是用商业音效库或 Freesound 这类音效网站找资源，亦或去 YouTube 找想要的声音设计实现过程。<strong>新手都容易遇到一个问题，不知道该用什么关键词去搜。</strong><br>对于这种目的性极强且词汇量覆盖相对狭窄的需求，我提供给大家一个训练方法。</p><h3 id="2-1-通过-AntConc-对商业音效库进行语料库提取"><a href="#2-1-通过-AntConc-对商业音效库进行语料库提取" class="headerlink" title="2.1. 通过 AntConc 对商业音效库进行语料库提取"></a>2.1. 通过 AntConc 对商业音效库进行语料库提取</h3><p>在语言学、英语教学等领域经常会通过语料库来进行专项研究。作为一种针对性极强的存在，语料库往往对某个领域的词汇研究有更精准的帮助，这里要感谢早稻田大学 Laurence Anthony 博士的作品 AntConc。<br>我使用 AntConc 把目前能找到的商业音效库的 PDF 元数据文档中的<strong>1753万个单词</strong>全部进行了处理。并对得到的语料库文件根据词频（即在这份样本中单词出现的次数）进行排布，<strong>得到了一份近三万词的音效库词汇表</strong>。<br>鉴于音效库关键词里有些简单词汇也需重新理解其他意思，就不使用 BNC 进行反向剔除了（一种去除语料库中出现的高词频词汇的方法）。<strong>但我已经人工删除了一些干扰的单词，尽量减少大家在背诵时的干扰。</strong><br><img src="/images/%E6%96%B0%E9%9F%B3%E9%A2%91%E5%BA%93.png" alt="新音频库"></p><p><strong>其中词频1000次以上有715个，100次以上有2930个，10次以上有7783个。</strong><br>基于词频的分布，我把生成的词汇表做成词频1000+、词频100+和词频10+三种，并做成去除词频排名和出现次数的 txt 文件，以方便按照下一步进行导入欧陆词典。<br><img src="/images/%E6%96%B0%E8%AF%8D%E9%A2%91%E8%A1%A8.png" alt="新词频表"></p><p>大家可根据需求进行选用，<strong>如希望快速改善音效库单词量，建议使用词频100+的版本（2930词）。</strong>如果学有余力，也可学完词频10+的版本。<br>当你背完这份高词频的词表，你会发现在音效库中见到的词汇全都会非常熟悉。当然，这是建立在你深入学习的基础上，而不是认识了就刷掉，重点是对单词的反思与结合音效库进行的搜索尝试。<br>对于词频在10次以下的单词，虽然这部分还有2万左右的，但其中词汇都过于冷门，还有部分则是简单词汇组合而成的复合词。没有什么参考价值，在这里不建议大家背诵。</p><p>下载地址：<br>链接：<a href="https://share.weiyun.com/0y8L9Vph" target="_blank" rel="noopener">https://share.weiyun.com/0y8L9Vph</a> 密码：wh5dgm</p><h3 id="2-2-使用欧陆词典进行背诵"><a href="#2-2-使用欧陆词典进行背诵" class="headerlink" title="2.2. 使用欧陆词典进行背诵"></a>2.2. 使用欧陆词典进行背诵</h3><p>欧陆词典可以导入我整理好的词频文件进行背诵。我建议大家使用付费版本，这样单词背诵记录等才可云端同步。在背诵过程中，亦可把生词再添加到新的生词本，以方便添加笔记和二次整理。<br>首先打开欧陆笔记网页版（<a href="http://my.eudic.net/），登录自己的账户。" target="_blank" rel="noopener">http://my.eudic.net/），登录自己的账户。</a><br>在左边点击“导入其他软件的生词”<br><img src="/images/%E6%AC%A7%E9%99%861.png" alt="欧陆1"></p><p>使用默认的“导入其他软件生词本”，点击上传，选择所需的语料库文件。并选择合适的生词本，这里我新建了一个新的生词本。<br><img src="/images/%E6%AC%A7%E9%99%862.png" alt="欧陆2"></p><p>随后点击左侧“我的生词本”，即可看到新导入的生词本。<br><img src="/images/%E6%96%B0%E6%AC%A7%E9%99%861.png" alt="新欧陆1"></p><p>在手机端同步完成后，可看到“生词笔记”中出现了刚创建的生词本。切换到“学习”选项卡，找到刚创建的生词本，选择计划的天数即可开始学习。<br><strong>可以看一下，若选择每天背150个单词（包括新词与复习），正好30天刷一遍。</strong>因为其中有一些大家熟悉的词汇，所以每天的任务实际要比150个单词轻松，1小时左右差不多能完成。<br>欧陆词典具体的使用我就不赘述了，背单词的回忆方式多种多样。与扇贝、百词斩等无太大差异，支持多种背诵和回忆模式，请自行研究。<br><img src="/images/%E6%96%B0%E6%AC%A7%E9%99%862.jpeg" alt="新欧陆2"></p><p>因为没通过 BNC 剔除高频词，所以可能会有少数极简单的单词出现，在学习过程中划掉即可。<br>但请注意，<strong>快速记忆单词课本不是最终目的，这个过程主要是快速熟悉的声音设计术语。</strong>有心的同学可以在生词本中增加笔记，或使用笔记软件和思维导图等进行符合自己思维习惯的整理。</p><h3 id="2-2-欧陆词典使用技巧-自定义词库"><a href="#2-2-欧陆词典使用技巧-自定义词库" class="headerlink" title="2.2. 欧陆词典使用技巧 - 自定义词库"></a>2.2. 欧陆词典使用技巧 - 自定义词库</h3><p>欧陆词典的厉害之处在于其非常棒的可扩展性，比如我的欧陆词典是如下图这样的词库配置。</p><p><img src="/images/%E6%96%B0%E6%AC%A7%E9%99%863.png" alt="新欧陆3"></p><p>除了第一个是保证离线发音的美音库，其余的分别是柯林斯双解、韦氏高阶学习词典、朗文高阶英英、剑桥高阶学习词典。<br>因为其支持 mdx 在内的海量词典格式，完全可以按照用户的需求进行自定义。这也给了我们更多的便利性，比如根据需求选择使用英汉还是英英词典，是否要使用学习词典等。<br><strong>关于如何打磨高效的欧陆词典，有兴趣的读者可以看看知乎这个问题：</strong><br><a href="https://www.zhihu.com/question/21328313" target="_blank" rel="noopener">https://www.zhihu.com/question/21328313</a></p><h3 id="2-3-最重要的还是多用"><a href="#2-3-最重要的还是多用" class="headerlink" title="2.3. 最重要的还是多用"></a>2.3. 最重要的还是多用</h3><p>背完单词表就万事大吉了吗？<br>不，一定要多用。无论是工作中还是搜索相关信息时，都要主动的联想并使用起曾经背过的单词，单词脱离了语境、语法、不同义等情况下很容易出现使用问题。短期背诵只能带给你的是对声音设计相关术语的快速印象，反复使用让其变成头脑的“肌肉记忆”才是最终目的。<br><strong>背单词这件事是英文学习中最不值得鼓励的一种方法，但对于词汇量极度匮乏或急需快速掌握某一领域词汇的人来说也勉强值得一用。</strong>希望大家明白什么是英语学习的正道，一时急于求成可以，一直抄近路只会自讨苦吃。<br>愿本文对诸君在英语及声音设计术语的学习上有所帮助。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 声音设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写给声音设计师的敏捷 GUI 开发大法（一）基础篇</title>
      <link href="/2020/08/27/PySimpleGUI%20%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>/2020/08/27/PySimpleGUI%20%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>当作为声音设计师或技术音频的你完成了 Python 脚本时，除了感叹这门语言的便利性和丰富的第三方库，可能也会思考，<strong>为什么现有的 Python GUI 库都这么麻烦？</strong>毕竟要为团队中非程序背景的同事开发工具，看得见的界面无疑比命令行的用户体验更加友好。<br><strong>这一系列分享的目的，就是为了打通脚本和 GUI 程序之间的障碍，把开发图形界面这个浪费时间的过程彻底简单化，让技术音频工作中的小工具开发变的门槛更低一些。</strong>其实使用 Tkinter、PyQt、wxPython 等来开发 GUI 也没什么难度，参考实例几分钟就能上手，一下午就能熟悉。但它们使用起来语法繁琐，不太直观，非常浪费时间。<br>作为生产力解放狂魔，我认为<strong>应该把宝贵的精力应该放在更重要的事上，而不是费劲吧啦的在控件和语法间挣扎。</strong>这也是我个人的<strong>学习理念，其一为多向自己提问并解答之，其二是遇到重复、繁琐、有潜力被自动化的东西就喜欢思考去优化。</strong><br>希望此文能给大家提供一套高效的工作流，人人都能轻松定制自己想要的工具。</p><blockquote><p>本系列文章阅读需要的前置知识：</p><ul><li>会配置开发环境，掌握 Python、Anaconda、VS Code、PyCharm 的安装配置。</li><li>掌握简单的 Python 语法和 WAAPI 知识。作为一门写工具时要求技术水平不是很高的脚本语言，没接触过的同学可以敲几天《Python编程：从入门到实践》，或看看廖雪峰老师的课程。对于 WAAPI，照着例子调用几个 API 即可轻松上手。</li><li>掌握 GUI 基础概念。了解窗体、面板、构件等即可，有志向深入研究的朋友可翻翻 UI、UX 相关书籍。</li></ul></blockquote><p><em>文章目录：</em></p><ol><li>基本概念与示例</li><li>配置开发环境与 PySimpleGUI</li><li>一个完整的程序例子</li><li>接下来讲什么？</li></ol><h2 id="基本概念与示例"><a href="#基本概念与示例" class="headerlink" title="基本概念与示例"></a>基本概念与示例</h2><p>对于 GUI 而言，只需了解它是一个具有图形界面的应用程序外壳即可。至于事件循环、布局构建、回调函数等概念，大可先把它们当成黑箱。只管使用，不必探究深层原理。</p><h3 id="1-1-UI-和程序之间需要“钩上”才能产生互动"><a href="#1-1-UI-和程序之间需要“钩上”才能产生互动" class="headerlink" title="1.1. UI 和程序之间需要“钩上”才能产生互动"></a>1.1. UI 和程序之间需要“钩上”才能产生互动</h3><p>图形界面之所以能够让程序发挥功能，是因为其组件被用户触发后，与程序的功能代码产生了互动。<br>例如可以用一个按钮点击代表一个函数的执行，用一个弹出式窗口显示 Print() 函数的打印信息，每一个行为与背后的代码关联在一起。我们实际要做的就是设计好壳子，再用钩子把它们连接起来。</p><h3 id="1-2-举个最简单的例子（另类的-Hello-World）"><a href="#1-2-举个最简单的例子（另类的-Hello-World）" class="headerlink" title="1.2. 举个最简单的例子（另类的 Hello World）"></a>1.2. 举个最简单的例子（另类的 Hello World）</h3><p>现在讨论一个最简单的程序。用户输入内容，点击按钮后，程序会把用户输入值通过窗口打印出来。<br>我们为它设计一个 GUI 原型：<br><img src="/images/UI%20%E5%8E%9F%E5%9E%8B%E4%B8%80.png" alt="UI 原型一"><br>上图上部分是程序打开时的界面，当用户输入完内容点击 Print 后，下部分会出现弹出式窗口告知用户刚输入的值。</p><h4 id="这个例子说明了什么？"><a href="#这个例子说明了什么？" class="headerlink" title="这个例子说明了什么？"></a>这个例子说明了什么？</h4><p>看三个重要的功能组件：</p><ul><li>Input 文本框：用于暂存用户输入的数据</li><li>Print 按钮：用于把 Input 文本框中的数据传进程序内（把用户输入的值存到变量中）</li><li>Input is XXXXXXXXX：通过弹出式窗口输出用户输入值</li></ul><h4 id="通过这个例子类比到工具的真实需求上"><a href="#通过这个例子类比到工具的真实需求上" class="headerlink" title="通过这个例子类比到工具的真实需求上"></a>通过这个例子类比到工具的真实需求上</h4><p>图形界面下 Input() 和 Print() 等函数组成的程序就会是我们的功能脚本，而图形界面上的控件就是本文的讨论方向，我们要用一种高效优雅的方法将两者连接。</p><h3 id="1-3-代码实现："><a href="#1-3-代码实现：" class="headerlink" title="1.3. 代码实现："></a>1.3. 代码实现：</h3><p>下面我写两段简单的代码，分别把这个程序用 Tkinter 和 PySimpleGUI 实现，并附上效果截图。</p><h4 id="使用-Tkinter"><a href="#使用-Tkinter" class="headerlink" title="使用 Tkinter"></a>使用 Tkinter</h4><p><img src="/images/Tkinter.png" alt="Tkinter"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> messagebox</span><br><span class="line"></span><br><span class="line">window = Tk() </span><br><span class="line">window.title(<span class="string">'小刘鸭之窗'</span>) </span><br><span class="line">window.geometry(<span class="string">'200x60'</span>) </span><br><span class="line"></span><br><span class="line">user_input = StringVar()</span><br><span class="line">user = Entry(window, textvariable=user_input)</span><br><span class="line">user_input.set(<span class="string">' '</span>)</span><br><span class="line">user.pack()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">click</span><span class="params">()</span>:</span></span><br><span class="line">    duckyo = user_input.get()</span><br><span class="line">    string = str(<span class="string">'Imput is%s'</span> %(duckyo))</span><br><span class="line">    print(<span class="string">'Imput is%s'</span> %(duckyo))</span><br><span class="line">    messagebox.showinfo(title=<span class="string">'鼻孔猫输出'</span>, message=string)</span><br><span class="line"></span><br><span class="line">Button(window, text=<span class="string">'Print'</span>, command=click).pack()</span><br><span class="line"></span><br><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure><h4 id="使用-PySimpleGUI"><a href="#使用-PySimpleGUI" class="headerlink" title="使用 PySimpleGUI"></a>使用 PySimpleGUI</h4><p><img src="/images/PySimpleGUI.png" alt="PySimpleGUI"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line">sg.theme(<span class="string">'Light Brown 11'</span>)   </span><br><span class="line"></span><br><span class="line">layout = [[sg.InputText(size=(<span class="number">30</span>, <span class="keyword">None</span>)), sg.Button(button_text=<span class="string">'Ok'</span>, size=(<span class="number">10</span>, <span class="number">1</span>))]]</span><br><span class="line">window = sg.Window(<span class="string">'小刘鸭之窗'</span>, layout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    event, values = window.read()</span><br><span class="line">    <span class="keyword">if</span> event == sg.WIN_CLOSED:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    sg.popup(<span class="string">'Input is '</span> + values[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure><h4 id="大家认为谁更简单一些？"><a href="#大家认为谁更简单一些？" class="headerlink" title="大家认为谁更简单一些？"></a>大家认为谁更简单一些？</h4><p>相信诸君无论熟悉 Python 与否，都能看出 PySimpleGUI 的代码具有高度可读性，更符合自然语义。不需要过多的设置即可做到优雅的主题、窗口排布。<br>这段代码给一个从未接触过 PySimpleGUI 的人看，一般也可轻松看出上半部分是布局实现，下半部分的循环是 Event Loop。<br>回过头来再看 Tkinter 的实现，对初学者来说很容易不知所云。<br>关于 QtDesigner，其实它的操作和语法也没有 PySimpleGUI 简单直观。不过下一篇中我会提到通过 QtDesigner 快速创建 Layout 代码，也算一种另类的物尽其用。</p><h2 id="配置开发环境与-PySimpleGUI"><a href="#配置开发环境与-PySimpleGUI" class="headerlink" title="配置开发环境与 PySimpleGUI"></a>配置开发环境与 PySimpleGUI</h2><p>这部分我不会说废话重复造轮子，那样有凑字数之嫌，直接放出比较好的文章供大家参考（感谢下文中作者们的贡献）。希望读者诸君自我实现一遍，加深印象。<br>因为个人习惯用 VS Code + Anaconda 配置开发环境，使用 pip、PyCharm 等的朋友可自行配置所需组件。关于 Anaconda、VS Code 和 PyCharm 的使用疑问请自行参考下述文档解决，其中的内容比较具体。关于各种开发环境的优劣性对比，请自行用搜索引擎解答疑问。</p><h3 id="2-1-Windows-下配置"><a href="#2-1-Windows-下配置" class="headerlink" title="2.1. Windows 下配置"></a>2.1. Windows 下配置</h3><h4 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h4><p><a href="https://segmentfault.com/a/1190000022797661" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022797661</a></p><h4 id="配置-Anaconda-并在本地环境中添加-PySimpleGUI"><a href="#配置-Anaconda-并在本地环境中添加-PySimpleGUI" class="headerlink" title="配置 Anaconda 并在本地环境中添加 PySimpleGUI"></a>配置 Anaconda 并在本地环境中添加 PySimpleGUI</h4><p><a href="https://zhuanlan.zhihu.com/p/25198543" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25198543</a></p><h4 id="配置-VS-Code-开发环境"><a href="#配置-VS-Code-开发环境" class="headerlink" title="配置 VS Code 开发环境"></a>配置 VS Code 开发环境</h4><p><a href="https://zhuanlan.zhihu.com/p/30324113" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30324113</a></p><h3 id="2-2-macOS-下配置"><a href="#2-2-macOS-下配置" class="headerlink" title="2.2. macOS 下配置"></a>2.2. macOS 下配置</h3><h4 id="安装-Anaconda-1"><a href="#安装-Anaconda-1" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h4><p><a href="https://blog.csdn.net/lq_547762983/article/details/81003528" target="_blank" rel="noopener">https://blog.csdn.net/lq_547762983/article/details/81003528</a></p><h4 id="配置-Anaconda-并在本地环境中添加-PySimpleGUI-1"><a href="#配置-Anaconda-并在本地环境中添加-PySimpleGUI-1" class="headerlink" title="配置 Anaconda 并在本地环境中添加 PySimpleGUI"></a>配置 Anaconda 并在本地环境中添加 PySimpleGUI</h4><h4 id="配置-VS-Code开发环境"><a href="#配置-VS-Code开发环境" class="headerlink" title="配置 VS Code开发环境"></a>配置 VS Code开发环境</h4><p>此两步可参考上面的链接，操作类似。</p><h2 id="绘制-GUI-原型"><a href="#绘制-GUI-原型" class="headerlink" title="绘制 GUI 原型"></a>绘制 GUI 原型</h2><p>对于绘制原型，有些人立刻会想到 Sketch 或 Axure 这样的重型武器，但它们学起来时间成本过高。还有一些 Web 端收费的原型制作工具，但那些在做 APP 原型设计才比较常用，做桌面端小工具开发也没必要。<br>在寻求解决方案的时候我发现了一个很棒的工具，对于简单的绘制 UI 原型的需求，推荐大家使用 Pencil，这是一款<strong>免费、开源、轻量、跨平台（Windows、macOS、Linux、火狐拓展）的原型设计工具</strong>。<br><img src="/images/Pencil%201.png" alt="Pencil 1"><br>附上样图一张</p><p>下载地址：<a href="https://pencil.evolus.vn/" target="_blank" rel="noopener">https://pencil.evolus.vn/</a><br>在“举个最简单的例子（另类的 Hello World）”处的黑白稿 UI 原型图，即使用 Pencil 所绘。相对于糟糕的手绘稿或请公司的 UI 设计师帮忙，不如花点时间学会 Pencil 后自己画。<br>如何学习 Pencil 呢？在官网文档中有比较简单的入门介绍。或者我建议大家可直接拖拽控件试一试，很容易上手。</p><h2 id="一个完整的例子"><a href="#一个完整的例子" class="headerlink" title="一个完整的例子"></a>一个完整的例子</h2><p>文档“翻译官“是种非常无聊的行为。下面我就直接通过一个具有实际应用意义的小工具模型，来讲述脚本代码通过 PySimpleGUI 如何优雅且快速的变成图形界面小工具。</p><h3 id="4-1-程序目的"><a href="#4-1-程序目的" class="headerlink" title="4.1. 程序目的"></a>4.1. 程序目的</h3><p>把一个文件夹内的 wav 文件根据声道数，对文件自动进行重命名加到后缀上。非常简单的需求，下面我先写出功能代码。</p><h3 id="4-2-编写功能代码"><a href="#4-2-编写功能代码" class="headerlink" title="4.2. 编写功能代码"></a>4.2. 编写功能代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nchannels_rename</span><span class="params">(input_path)</span>:</span> <span class="comment"># 重命名功能模块</span></span><br><span class="line">    f = wave.open(input_path, <span class="string">'rb'</span>)</span><br><span class="line">    params = f.getnchannels()</span><br><span class="line">    oldname = input_path</span><br><span class="line">    <span class="keyword">if</span> params == <span class="number">1</span>:</span><br><span class="line">        newname = input_path.rstrip(<span class="string">'.wav'</span>) + <span class="string">'_mono'</span> + <span class="string">'.wav'</span></span><br><span class="line">        os.rename(oldname, newname)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        newname = input_path.rstrip(<span class="string">'.wav'</span>) + <span class="string">'_stereo'</span> + <span class="string">'.wav'</span></span><br><span class="line">        os.rename(oldname, newname)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wav_rename</span><span class="params">(input_path)</span>:</span> <span class="comment"># 对目录进行判断并重命名</span></span><br><span class="line">    fileend = []</span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(input_path):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(input_path):</span><br><span class="line">            fileend.append(os.path.splitext(file)[<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">'.wav'</span>):</span><br><span class="line">                nchannels_rename(input_path + os.sep + file)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'.wav'</span> <span class="keyword">in</span> fileend:</span><br><span class="line">            print(<span class="string">'Processing Complete.'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'No wave file be found!'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Check your input!'</span>)</span><br></pre></td></tr></table></figure><h3 id="4-3-PySimpleGUI-基础"><a href="#4-3-PySimpleGUI-基础" class="headerlink" title="4.3. PySimpleGUI 基础"></a>4.3. PySimpleGUI 基础</h3><p>那么接下来就要使用 PySimpleGUI 添加图形界面了，在这之前需要知道一些基础的概念。</p><h4 id="PySimpleGUI-基于什么构建？"><a href="#PySimpleGUI-基于什么构建？" class="headerlink" title="PySimpleGUI 基于什么构建？"></a>PySimpleGUI 基于什么构建？</h4><p>虽然 PySimpleGUI 默认基于 Tkinter，但实际上还具有 WxPython、QT 和 Remi 等版本。具体的区别可参考官方的“散文“文档。其中对于 Remi 的支持是十分方便的。这代表着当代码进行以下简单的引用库修改后，程序可直接生成 Web 端在浏览器中运行。对于某些轻需求下的开发，省去了大量的时间和精力。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="comment"># tkinter version</span></span><br><span class="line"><span class="keyword">import</span> PySimpleGUIWeb <span class="comment"># Web(Remi) version</span></span><br><span class="line"><span class="comment"># and PySimpleGUI27, PySimpleGUIWx, PySimpleGUIQt</span></span><br></pre></td></tr></table></figure></p><h4 id="如何实现一个基础的-GUI-结构"><a href="#如何实现一个基础的-GUI-结构" class="headerlink" title="如何实现一个基础的 GUI 结构"></a>如何实现一个基础的 GUI 结构</h4><p>这里我直接引用官方的示例代码并加上注释，一个简单的窗口布局结构代码其实很清晰：</p><ol><li>sg.theme 行代表使用哪个主题，这也是 PySimpleGUI 一开始就很注重的一点。程序的美观性很重要，而且要轻松的被实现。</li><li>layout 使用列表来定义布局，其中的每个子列表代表当前行的元素（即 Widgets，PySimpleGUI 中称控件为 Elements，本系列教程也会统一使用此术语），每个控件的属性中亦可设置各种所需的参数。</li><li>window 行创建了窗体，默认情况下自动适应控件所需的尺寸。</li><li>Event Loop 用于支撑软件功能运行到窗体关闭或点击 Cancel 退出。<br><img src="/images/PySimpleGUI%202.png" alt="PySimpleGUI 2"></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line">sg.theme(<span class="string">'DarkAmber'</span>)   <span class="comment"># 设定主题为 DarkAmber</span></span><br><span class="line"><span class="comment"># 窗口内的共含三行元素，在列表中清晰可见</span></span><br><span class="line">layout = [  [sg.Text(<span class="string">'Some text on Row 1'</span>)],</span><br><span class="line">            [sg.Text(<span class="string">'Enter something on Row 2'</span>), sg.InputText()],</span><br><span class="line">            [sg.Button(<span class="string">'Ok'</span>), sg.Button(<span class="string">'Cancel'</span>)] ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建窗体，名称为 Window Title</span></span><br><span class="line">window = sg.Window(<span class="string">'Window Title'</span>, layout)</span><br><span class="line"><span class="comment"># Event Loop，不断的从窗体中读取事件与返回值，并检测窗口是否被关闭</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    event, values = window.read()</span><br><span class="line">    <span class="keyword">if</span> event == sg.WIN_CLOSED <span class="keyword">or</span> event == <span class="string">'Cancel'</span>: </span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">'You entered '</span>, values[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure><h4 id="PySimpleGUI-能做出什么样的程序？"><a href="#PySimpleGUI-能做出什么样的程序？" class="headerlink" title="PySimpleGUI 能做出什么样的程序？"></a>PySimpleGUI 能做出什么样的程序？</h4><p>在这里我放几张官方的图片供大家观看，相信诸位能看出它内置丰富控件元素及优雅设计。<br><img src="/images/pytheme.jpg" alt="pytheme"><br>所有内置的主题</p><p><img src="/images/pyml.jpg" alt="pyml"><br>引入机器学习模块判断车辆的存在</p><p><img src="/images/pywidget.jpg" alt="pywidget"><br>用到了13种元素的示例程序（实际上还有更多）</p><p><img src="/images/pywindow.png" alt="pywindow"><br>多窗口示例程序</p><h3 id="4-4-构建-GUI-代码"><a href="#4-4-构建-GUI-代码" class="headerlink" title="4.4. 构建 GUI 代码"></a>4.4. 构建 GUI 代码</h3><p>回到我们的程序设计上。对于这个简单的程序，我们需要程序中包含路径输入框、处理按钮、处理提示文本框等。为此，我简单绘制一个原型。<br><img src="/images/pyui.png" alt="pyui"></p><p>有了原型，下面我写一段简单的 GUI 实现并附上注释：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设计布局为四行元素，分别用到文字、输入框、文件夹浏览器、输出、按钮等元素。</span></span><br><span class="line">layout = [  [sg.Text(<span class="string">'Browse Folders'</span>)],</span><br><span class="line">            [sg.Input(), sg.FolderBrowse(<span class="string">'Browse'</span>, key=<span class="string">'folder'</span>)],</span><br><span class="line">            [sg.Output(size=(<span class="number">70</span>, <span class="number">20</span>), font=(<span class="string">"宋体"</span>, <span class="number">10</span>))],</span><br><span class="line">            [sg.Button(<span class="string">'Cock it'</span>), sg.Button(<span class="string">'Cancel'</span>)] ]</span><br><span class="line"><span class="comment"># 构建窗体 GUI Enemy No. 1</span></span><br><span class="line">window = sg.Window(<span class="string">'GUI Enemy No. 1'</span>, layout)</span><br><span class="line"><span class="comment"># 创建 Event Loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    event, values = window.read()</span><br><span class="line">    <span class="keyword">if</span> event <span class="keyword">in</span> (<span class="keyword">None</span>, <span class="string">'Cancel'</span>): <span class="comment"># 如果用户点击“Cancel”按钮或者关闭窗口，退出循环并关闭窗口</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'Cock it'</span>: <span class="comment"># 如果用户点击“Cock it”按钮，就执行判断体判断是否为文件夹输入，是的话输出文字并调用 wav_rename() 函数进行操作</span></span><br><span class="line">        <span class="keyword">if</span> values[<span class="string">'folder'</span>]:</span><br><span class="line">            print(<span class="string">'&#123;0&#125;Renaming&#123;0&#125;'</span>.format(<span class="string">'*'</span>*<span class="number">10</span>))</span><br><span class="line">            wav_rename(values[<span class="string">'folder'</span>])</span><br><span class="line">            print(<span class="string">'&#123;0&#125;Done&#123;0&#125;'</span>.format(<span class="string">'*'</span>*<span class="number">10</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'Choose some folder first!'</span>)</span><br><span class="line"></span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure></p><h4 id="4-5-组装代码"><a href="#4-5-组装代码" class="headerlink" title="4.5. 组装代码"></a>4.5. 组装代码</h4><p>写完功能代码和 GUI 代码，肯定需要把它们组装到一起。根据项目的复杂程度，你也可以决定是否按模块整理代码。<br>注：为了避免浪费篇幅，其中函数体直接省略。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nchannels_rename</span><span class="params">(input_path)</span>:</span></span><br><span class="line">    Function body</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wav_rename</span><span class="params">(input_path)</span>:</span></span><br><span class="line">    Function body</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gui</span><span class="params">()</span>:</span></span><br><span class="line">    Function body</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>    </span><br><span class="line">    gui()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><h4 id="4-6-执行效果"><a href="#4-6-执行效果" class="headerlink" title="4.6. 执行效果"></a>4.6. 执行效果</h4><p>我稍微修改了一下代码，让被修改后的文件名输出到文本框中。从输出结果可见，程序如预先构思执行，我们仅用不到20行代码就优雅的完成了这个工具。<br><img src="/images/pyresult-1.png" alt="pyresult"></p><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2><p>聪明的读者一定很好奇这些部分：</p><ul><li>如何添加菜单栏？</li><li>窗体内元素能否实现双栏或不对称布局？</li><li>之前你提到过用 QtDesigner 能快速生成布局？不用自己写布局代码了吗？</li><li>有没有对声音设计师来说更实用或更复杂的程序案例详解（例如跟 WAAPI 或 ReaScript 联动）？</li></ul><p>在之后的文章中我会就这些部分继续展开介绍，欢迎诸位持续关注。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 音频编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>游戏音频与声音设计相关书籍推荐（第二版）</title>
      <link href="/2020/08/15/%E6%B8%B8%E6%88%8F%E9%9F%B3%E9%A2%91%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
      <url>/2020/08/15/%E6%B8%B8%E6%88%8F%E9%9F%B3%E9%A2%91%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>在游戏音频与声音设计领域的探索过程中，我发现国内的相关书籍比较匮乏。对于游戏行业中一个有趣的行业分支，我很惊讶居然没有一个像样的书单或学习路线。作为喜好钻研和分享的人，深感应该把最近一年多的挖掘与发现做成书单来分享。希望与大家交流学习，共同提高。<br>文中为我认为值得推荐的书籍（包括我已读和准备读的），少部分书籍之所以不推荐，是因为其中内容过于古老，或内容空洞没参考价值。<strong>中文书籍我认为大多数朋友应该已经读过或翻过，此部分书籍尽量省略介绍。</strong>书单这种东西，希望它不仅仅是躺在你的收藏夹里，而是对你的知识体系建设有帮助。<br>与著名的“保姆级” Unity 教程作者 Jasper Flick 相同，我对<strong>知识应该成体系的去分享这种思维表示极度的赞同。</strong>所以与直接的列书单不同，我会增加参考性的评价，供诸君选书之用。<br>诚然，作为实践中才能获取更多经验的工作类型。对于 Sound Designer 或 Audio Programmer 来说，绝大多数的经验都是难以从书籍中获取的。除非某一日出版《Wwise Implementation FAQ 要你命3000》、《游戏音效声音设计实例 For Dummies》、《21天成为 ReaScript 自动化大师》等“史诗级”书籍……<br>此书单会根据本人学习情况不定时更新，请关注公众号以获得最新版本推送。<br>希望这个书单对你有帮助，有任何疑问欢迎留言到本文下。</p><blockquote><p>约定：</p><ul><li>本文的中英文符号与书名标记，根据《夹用英文的中文文本的标点符号用法（草案）》进行标准化，如英文书名一律使用斜体英文表示。</li><li>绝大部分英文书籍可在 Amazon 购买实体书或 Kindle 版，亦可购买 Focal Press 或 CRC Press 等数字压制的 PDF 版本。中文书籍可轻松的在各大图书网站寻得购买途径，此处便不赘述。</li><li>本文不提供任何盗版获取方式，如有能力请支持正版。作为知识的载体，图书的价格已是低到不可想象。如暂时看了盗版，请记住日后有钱补票，这才是知识流动的正循环。</li><li>文中图书封面严谨的进行过横向900像素的统一，以获得公众号上最完美的阅读体验，请大家欣赏标准化带来的美感。</li></ul></blockquote><blockquote><p>第二版更新内容：</p><ol><li>改正错别字、增改介绍文字内容、增加目录</li><li>聊聊如何选择阅读顺序以及怎么读</li><li>增加“游戏音频导论”下关于求职、项目规划的书目</li><li>增加“声音设计”下更多声音设计、电影声音和空间音频的书目</li><li>增加“技术音频”下关于 Unity 音频整合及 Unity、Unreal Engine 使用相关书目</li></ol><p>注：新增加的书目一律排在每个细节分类的前面（英文书籍会排在英文书籍部分的最前面），以方便大家查看变化的部分。</p></blockquote><p>todo:<br>Mastering Unity Scripting<br>Extending Unity with Editor Scripting<br>From Pac-Man to Pop Music Interactive Audio in Games and New Media<br>Game Sound Technology and Player Interaction - Concepts and Developments<br>Ludomusicology Approaches to Video Game Music<br>Begin Audio Scripting with Reaper<br>FFmpeg Basics<br>Spatial Audio</p><p>书籍目录：</p><p>1 游戏音频导论</p><ul><li>《游戏音频完全指南（第2版）》</li><li>The Bible of Getting a Job in Game Audio, 2020 Edition</li><li>Audio for Games：Planning, Process, and Production</li><li>The Beep Book: Documenting the History of Game Sound</li><li>Game Sound: An Introduction to the History, Theory, and Practice of Video Game Music and Sound Design</li><li>Principles of Game Audio and Sound Design</li><li>Playing with Sound: A Theory of Interacting with Sound and Music in Video Games</li><li>The Essential Guide to Game Audio: The Theory and Practice of Sound for Games</li><li>Creating Music and Sound for Games</li><li>The Game Audio Strategy Guide: A Practical Course</li></ul><p>2 声音设计<br>2.1 声音设计理论与实践</p><ul><li>《视听：幻觉的构建》</li><li>《放低话筒杆》</li><li>《声音》</li><li>《电影之声：电影音效师访谈录》</li><li>《声频信号的仪表计量》</li><li>《音效圣经: 好莱坞音效创作及录制技巧》</li><li>《电影电视声音（第3版）》</li><li>《电影声音实用艺术（第3版）》</li><li>《动画声音设计》</li><li>《审美空间延伸与拓展: 电影声音艺术理论》</li><li>《声音设计: 电影中语言，音乐和音响的表现（第2版）》</li><li>Sound Design and Science Fiction</li><li>Post Sound Design: The Art and Craft of Audio Post Production for the Moving Image</li><li>Hollywood Sound Design and Moviesound Newsletter: A Case Study of the End of the Analog Age</li><li>The Oxford Handbook of Interactive Audio</li><li>Producing Great Sound for Film and Video</li><li>Studying Sound: A Theory and Practice of Sound Design</li><li>Foundations in Sound Design for Interactive Media: A Multidisciplinary Approach</li><li>Foundations in Sound Design for Linear Media: A Multidisciplinary Approach</li><li>Sound Design Theory and Practice: Working with Sound</li><li>Sound Works: A Cultural Theory of Sound Design</li><li>The Fundamentals of Sonic Art and Sound Design</li><li>The Plagrave Handbook of Sound Design and Music in Screen Media</li></ul><p>2.2 拟音（Foley）</p><ul><li>《拟音圣经: 电影、游戏和动画片中的声音表演艺术》</li><li>《影视拟音技巧》</li></ul><p>2.3 Pure Data</p><ul><li>《设计声音》</li><li>《电子音乐技术》</li><li>《交互式音频程序开发》</li><li>《Pure Data 图形化音乐编程技术与应用》</li><li>Multimedia Programming with Pure Data</li><li>Programming Sound with Pure Data: Make Your Apps Come Alive with Dynamic Audio</li></ul><p>2.4 VCV Rack</p><ul><li>How to Rack</li><li>VCV Rack: How it Works</li><li>Developing Virtual Synthesizers with VCV Rack</li></ul><p>2.4 Reaktor</p><ul><li>《声音合成平台 Reaktor 操作指南》</li></ul><p>2.5 合成器</p><ul><li>《自己动手做声音: 声音合成与制作基础》</li><li>《声音合成与采样技术（第3版）》</li><li>《软件合成器技术实战手册: 音色制作与模块编程》</li><li>Creating Sounds from Scratch: A Practical Guide to Music Synthesis for Producers and Composers</li><li>The Synthesizer: A Comprehensive Guide to Understanding, Programming, Playing, and Recording the Ultimate Electronic Music Instrument</li><li>Computer Sound Design: Synthesis Techniques and Programming 2nd edition</li><li>Becoming a Synthesizer Wizard: From Presets to Power User</li><li>Welsh’s Synthesizer Cookbook: Synthesizer Programming, Sound Analysis, and Universal Patch Book 1、2</li><li>Refining Sound: A Practical Guide to Synthesis and Synthesizers</li><li>Analog Synthesizers: Understanding, Performing, Buying 2nd edition</li><li>Microsound</li></ul><p>2.6 空间音频</p><ul><li>《空间声原理》</li><li>《空间线索在3D音频中的应用研究》</li><li>Ambisonics</li><li>Immersive Sound</li></ul><p>3 技术音频<br>3.1 导论及文集</p><ul><li>《游戏引擎架构》</li><li>《游戏编程算法与技巧》</li><li>The Audio Programming Book</li><li>Game Audio Programming: Principles and Practices 1、2、3</li><li>Beep To Boom: The Development Of Advanced Runtime Sound Systems For Games And Extended Reality</li><li>Game Audio: Tales of a Technical Sound Designer 1、2</li></ul><p>3.2 引擎使用</p><ul><li>《Unity 3D 游戏开发（第二版）》</li><li>Unity Game Development Cookbook</li><li>Unreal Engine Game Development Cookbook</li></ul><p>3.3 游戏引擎音频整合</p><ul><li>Game Audio Development with Unity 5.X</li><li>Game Audio Implementation: A Practical Guide Using the Unreal Engine</li><li>Game Audio with FMOD and Unity</li><li>The Handbook of Game Audio Using Wwise</li></ul><p>3.4 插件开发</p><ul><li>Getting Started with JUCE</li><li>Audio Effects: Theory, Implementation and Application</li><li>DAFX Digital Audio Effects</li><li>Designing Audio Effect Plug-Ins in C++ With Digital Audio Signal Processing Theory</li><li>Designing Software Synthesizer Plug-Ins in C++ For RackAFX, VST3, and Audio Units</li></ul><h2 id="1-游戏音频导论"><a href="#1-游戏音频导论" class="headerlink" title="1. 游戏音频导论"></a>1. 游戏音频导论</h2><p>导论部分多为适合入门者的读物，内容偏向综合介绍游戏音频行业的工作内容与常见技巧。</p><h4 id="《游戏音频完全指南（第2版）》"><a href="#《游戏音频完全指南（第2版）》" class="headerlink" title="《游戏音频完全指南（第2版）》"></a>《游戏音频完全指南（第2版）》</h4><p><img src="/images/%E6%B8%B8%E6%88%8F%E9%9F%B3%E9%A2%91%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97_900.jpg" alt="游戏音频完全指南_900"><br>Aaron Marks，人民邮电出版社，2014<br>这本应该是想入行的绝大大多数人搜到的前几本书之一。从功利阅读角度出发，4-6章关于如何接私活的内容大可不看，只读其他部分的内容足矣。<br>作为音频技术与录音艺术译丛中不太被重视的一本，第3版被夏老师重译的几率看来很低，这也让这本书的内容略显陈旧（例如关于中间件和录音的内容几乎没有）。建议有条件的朋友翻阅原版第3版，其中新增大量诱人的内容，包括游戏音频必备技能、音效设计技巧、田野录音（Field Recording）、对白录音，以及最重要的部分——对 Wwise 等几大中间件的介绍并引入引擎整合时脚本的概念，如此升级后的内容才能让初学者对游戏音频有一套比较好的认知，而不是单纯停留在简单的资源制作层面。</p><h4 id="The-Bible-of-Getting-a-Job-in-Game-Audio-2020-Edition"><a href="#The-Bible-of-Getting-a-Job-in-Game-Audio-2020-Edition" class="headerlink" title="The Bible of Getting a Job in Game Audio, 2020 Edition"></a><em>The Bible of Getting a Job in Game Audio, 2020 Edition</em></h4><p><img src="/images/The%20Bible%20of%20Getting%20a%20Job%20in%20Game%20Audio,%202020%20Edition_900.jpg" alt="The Bible of Getting a Job in Game Audio, 2020 Edition_900"><br>Florian Titus Ardelean, 2020<br>作为一名热心的音频设计师，Florian 前几个月放出的这份如何在游戏音频行业找到工作的文档很有推荐价值。超过60多位业内专家对这份工作的方方面面都给出了有价值的见解，需要的朋友可以去 Florian 的推置顶获取下载地址。</p><h4 id="Audio-for-Games：Planning-Process-and-Production"><a href="#Audio-for-Games：Planning-Process-and-Production" class="headerlink" title="Audio for Games：Planning, Process, and Production"></a><em>Audio for Games：Planning, Process, and Production</em></h4><p><img src="/images/Audio%20for%20Games_900.jpg" alt="Audio for Games_900"><br>Alexander Brandon, New Riders, 2004<br>侯老师推荐的一本，虽然比较老，但其中对于声音资源的计划、管理方法有很好的介绍。</p><h4 id="The-Beep-Book-Documenting-the-History-of-Game-Sound"><a href="#The-Beep-Book-Documenting-the-History-of-Game-Sound" class="headerlink" title="The Beep Book: Documenting the History of Game Sound"></a><em>The Beep Book: Documenting the History of Game Sound</em></h4><p><img src="/images/The%20Beep%20Book_900.jpg" alt="The Beep Book_900"><br>Karen Collins, Chris Greening, Ehtonal, 2016<br>采访了96位著名游戏音频从业者，复现出游戏音频行业的发展历史。如果想要系统的展望一下这个行业，可以翻翻看有没有你喜欢的声音设计师。</p><h4 id="Game-Sound-An-Introduction-to-the-History-Theory-and-Practice-of-Video-Game-Music-and-Sound-Design"><a href="#Game-Sound-An-Introduction-to-the-History-Theory-and-Practice-of-Video-Game-Music-and-Sound-Design" class="headerlink" title="Game Sound: An Introduction to the History, Theory, and Practice of Video Game Music and Sound Design"></a><em>Game Sound: An Introduction to the History, Theory, and Practice of Video Game Music and Sound Design</em></h4><p><img src="/images/Game%20Sound%20-%20An%20Introduction%20to%20the%20History,%20Theory,%20and%20Practice%20of%20Video%20Game%20Music%20and%20Sound%20Design_900.jpg" alt="Game Sound - An Introduction to the History, Theory, and Practice of Video Game Music and Sound Design_900"><br>Karen Collins, The MIT Press, 2008<br>滑铁卢大学游戏学院副教授 Karen Collins N 部作品之一，简单梳理了游戏和音频的发展史。其中对音频团队构成和音频处理阶段有比较清晰的探讨。限制于篇幅，比较泛泛而谈，新手入门时跳着翻翻查漏补缺会有些启发。</p><h4 id="Principles-of-Game-Audio-and-Sound-Design"><a href="#Principles-of-Game-Audio-and-Sound-Design" class="headerlink" title="Principles of Game Audio and Sound Design"></a><em>Principles of Game Audio and Sound Design</em></h4><p><img src="/images/Principles%20of%20Game%20Audio%20and%20Sound%20Design*.jpg" alt="Principles of Game Audio and Sound Design*"><br>Jean-Luc Sinclair, Focal Press, 2020<br>一本详实的入门书籍，内容包括游戏引擎、声音引擎、编程、整合、过程式音频等对初学者很友好的概念。作者除了声音设计外还作曲，与九寸钉 Trent 叔和 RATM 乐队均有合作。</p><h4 id="Playing-with-Sound-A-Theory-of-Interacting-with-Sound-and-Music-in-Video-Games"><a href="#Playing-with-Sound-A-Theory-of-Interacting-with-Sound-and-Music-in-Video-Games" class="headerlink" title="Playing with Sound: A Theory of Interacting with Sound and Music in Video Games"></a><em>Playing with Sound: A Theory of Interacting with Sound and Music in Video Games</em></h4><p><img src="/images/Playing%20with%20Sound%20-%20A%20Theory%20of%20Interacting%20with%20Sound%20and%20Music%20in%20Video%20Games_900.jpg" alt="Playing with Sound - A Theory of Interacting with Sound and Music in Video Games_900"><br>Karen Collins, The MIT Press, 2013<br>同为 Karen Collins 的作品，这本偏向理论，探讨了各种交互式声音在游戏中的使用。从电影研究、哲学、心理学到计算机科学，综合探讨了一个交互式声音体验理论。</p><h4 id="The-Essential-Guide-to-Game-Audio-The-Theory-and-Practice-of-Sound-for-Games"><a href="#The-Essential-Guide-to-Game-Audio-The-Theory-and-Practice-of-Sound-for-Games" class="headerlink" title="The Essential Guide to Game Audio: The Theory and Practice of Sound for Games"></a><em>The Essential Guide to Game Audio: The Theory and Practice of Sound for Games</em></h4><p><img src="/images/The%20Essential%20Guide%20to%20Game%20Audio%20-%20The%20Theory%20and%20Practice%20of%20Sound%20for%20Games_900.jpg" alt="The Essential Guide to Game Audio - The Theory and Practice of Sound for Games_900"><br>Steve Horowitz, Scott Looney, Routledge, 2014<br>同样是近乎完美的一本入门读物，只可惜停留在14年的版本再无更新。从游戏历史、交互式声音、Middleman 中间件，一直讲到使用 Unity 自己的音频功能进行整合声音。非常基础。适合初学者花一天时间好好读一遍，拓宽视野（虽然本书的范围并不够）。</p><h4 id="Creating-Music-and-Sound-for-Games"><a href="#Creating-Music-and-Sound-for-Games" class="headerlink" title="Creating Music and Sound for Games"></a><em>Creating Music and Sound for Games</em></h4><p><img src="/images/Creating%20Music%20and%20Sound%20for%20Games_900.jpg" alt="Creating Music and Sound for Games_900"><br>G. W. Childs IV, Course Technology PTR, 2006<br>给星战游戏做声音设计的老前辈的老著作，因为他写过 Reason 的书，所以其中会夹带不少用 Reason 做声音设计的私货。不过看年份就知道书里不少东西已经过时，入门随便翻翻看看前辈的思路还是可以的，记住别傻乎乎的去下 GigaStudio。</p><h4 id="The-Game-Audio-Strategy-Guide-A-Practical-Course"><a href="#The-Game-Audio-Strategy-Guide-A-Practical-Course" class="headerlink" title="The Game Audio Strategy Guide: A Practical Course"></a><em>The Game Audio Strategy Guide: A Practical Course</em></h4><p><img src="/images/The%20Game%20Audio%20Strategy%20Guide_900.jpg" alt="The Game Audio Strategy Guide_900"><br>Gina Zdanowicz, Spencer Bambrick, Focal Press, 2019<br>从去年开始就颇为感兴趣的一本书，推上关注 Gina 的话能看出她是想把这本书做成非常系统的入门书籍。举些例子，在声音设计部分就分别讲了从音效库、合成、拟音和田野录音等方法获取素材加以合成，在整合部分少有的把音频和音乐整合分开讲，入门直接看这本应该也很棒。</p><h2 id="2-声音设计"><a href="#2-声音设计" class="headerlink" title="2. 声音设计"></a>2. 声音设计</h2><p>在这部分，本清单着重于考虑声音设计理论和后期制作，亦包括合成器内容。此处假设读者诸君已对录音艺术有足够的了解，故《现代录音技术》这类书目不在本清单考虑范围之内。有需要的同学请自行检索“音频技术与录音艺术译丛”、“录音技术与艺术系列丛书 ”、“录音艺术专业‘十二五’规划教材”等经典丛书。</p><h3 id="2-1-声音设计理论与实践"><a href="#2-1-声音设计理论与实践" class="headerlink" title="2.1 声音设计理论与实践"></a>2.1 声音设计理论与实践</h3><p>影视声音设计多为线性声音，但众所周知，其中大量的技巧都可运用到游戏交互式声音设计中来，故此部分含影视相关书籍。</p><h4 id="《视听：幻觉的构建》"><a href="#《视听：幻觉的构建》" class="headerlink" title="《视听：幻觉的构建》"></a>《视听：幻觉的构建》</h4><p><img src="/images/%E8%A7%86%E5%90%AC_900.jpg" alt="视听_900"><br>Michel Chion，北京联合出版公司，2014<br>后浪电影学院中关于影视声音设计的一本重要著作，从多个层面分析了声音如何带给电影图像以时间感、空间感的增值效果，如何通过声音构建了影视幻觉。</p><h4 id="《放低话筒杆》"><a href="#《放低话筒杆》" class="headerlink" title="《放低话筒杆》"></a>《放低话筒杆》</h4><p><img src="/images/%E6%94%BE%E4%BD%8E%E8%AF%9D%E7%AD%92%E6%9D%86_900.jpg" alt="放低话筒杆_900"><br>Jay Beck，Tony Grajeda，中国电影出版社，2013<br>对诸多著名电影进行了声音上的反思，如《沉默的羔羊》、《穆赫兰道》等，探索了电影声音与文化研究之间的关系。</p><h4 id="《声音》"><a href="#《声音》" class="headerlink" title="《声音》"></a>《声音》</h4><p><img src="/images/%E5%A3%B0%E9%9F%B3_900.jpg" alt="声音_900"><br>Michel Chion，北京大学出版社，2013<br>作者作为 IRCAV 的客座教授，本书汇集了他三十年来的研究成果。构建了“纯声学”这个学科。纯声学所希望研究的声音是处于认知系统中的声音，偏向声音符号学。</p><h4 id="《电影之声：电影音效师访谈录》"><a href="#《电影之声：电影音效师访谈录》" class="headerlink" title="《电影之声：电影音效师访谈录》"></a>《电影之声：电影音效师访谈录》</h4><p><img src="/images/%E7%94%B5%E5%BD%B1%E4%B9%8B%E5%A3%B0-%E7%94%B5%E5%BD%B1%E9%9F%B3%E6%95%88%E5%B8%88%E8%AE%BF%E8%B0%88%E5%BD%95_900.jpg" alt="电影之声-电影音效师访谈录_900"><br>Vincent LoBrutto，北京大学出版社，2015<br>对27位著名电影音效师的访谈，内容包括同期录音、剪辑、声音设计、对白编辑、混录等，可以从其中观看自己喜欢的电影声音设计师的思路。</p><h4 id="《声频信号的仪表计量》"><a href="#《声频信号的仪表计量》" class="headerlink" title="《声频信号的仪表计量》"></a>《声频信号的仪表计量》</h4><p><img src="/images/%E5%A3%B0%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BB%AA%E8%A1%A8%E8%AE%A1%E9%87%8F_900.jpg" alt="声频信号的仪表计量_900"><br>Eddy Bogh Brixen, 人民邮电出版社, 2012<br>之所以把这本老书放上来，是建议大家都仔细学习一下音频测量标准的相关内容。新手入门容易出现对响度、动态范围之类的概念混淆，更别看懂不同标准。不过本书比较老，英文第三版前一阵也出了，愿意看关于音频测量最新严谨标准的朋友建议翻阅一下。</p><h4 id="《音效圣经-好莱坞音效创作及录制技巧》"><a href="#《音效圣经-好莱坞音效创作及录制技巧》" class="headerlink" title="《音效圣经: 好莱坞音效创作及录制技巧》"></a>《音效圣经: 好莱坞音效创作及录制技巧》</h4><p><img src="/images/%E9%9F%B3%E6%95%88%E5%9C%A3%E7%BB%8F%20%20%E5%A5%BD%E8%8E%B1%E5%9D%9E%E9%9F%B3%E6%95%88%E5%88%9B%E4%BD%9C%E5%8F%8A%E5%BD%95%E5%88%B6%E6%8A%80%E5%B7%A7%20%20%E6%8F%92%E5%9B%BE%E7%89%88_900.jpg" alt="音效圣经  好莱坞音效创作及录制技巧  插图版_900"><br>Ric Viers，北京联合出版公司·后浪出版公司，2016<br>两个十诫值得学习，第17章稍微值得稍微一看。对有录音基础的人来说，其余部分很乏味。</p><h4 id="《电影电视声音（第3版）》"><a href="#《电影电视声音（第3版）》" class="headerlink" title="《电影电视声音（第3版）》"></a>《电影电视声音（第3版）》</h4><p><img src="/images/%E7%94%B5%E5%BD%B1%E7%94%B5%E8%A7%86%E5%A3%B0%E9%9F%B3%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89_900.jpg" alt="电影电视声音（第3版）_900"><br>Tomlinson Holman，人民邮电出版社，2015<br>对声音设计师来说，目光可集中在第10章附近。前面的心理声学、音频基础、扬声器技术等过于老生常谈。</p><h4 id="《电影声音实用艺术（第3版）》"><a href="#《电影声音实用艺术（第3版）》" class="headerlink" title="《电影声音实用艺术（第3版）》"></a>《电影声音实用艺术（第3版）》</h4><p><img src="/images/%E7%94%B5%E5%BD%B1%E5%A3%B0%E9%9F%B3%E5%AE%9E%E7%94%A8%E8%89%BA%E6%9C%AF_900-1.jpg" alt="电影声音实用艺术_900"><br>Davis Lewis Yewdall, 人民邮电出版社，2011<br>相对《电影电视声音》来说，对声音设计师的启发就大的多了。毕竟做声音设计的时候本质也是在反复拉片，故本书有一半以上的内容值得深入学习。看着35mm胶片上的光学声迹，你会感叹用 DAW 做 Sound Design 是多么幸福。</p><h4 id="《动画声音设计》"><a href="#《动画声音设计》" class="headerlink" title="《动画声音设计》"></a>《动画声音设计》</h4><p><img src="/images/%E5%8A%A8%E7%94%BB%E5%A3%B0%E9%9F%B3%E8%AE%BE%E8%AE%A1_900.jpg" alt="动画声音设计_900"><br>Robin Beauchamp，人民邮电出版社，2011<br>国内的第1版排版是横向的，读起来很不舒服是一大缺点。书本身的内容极好，完整的从基础带着读者过了一遍影视动画声音设计，关于画外音、节奏、知觉引导等部分很棒。随书光盘有3GB+的内容，后面两个例子非常详细。<br>对有条件阅读原版的读者，仍推荐加读第2版，新版除了内容增减外，后面的例子数量变的非常多，可仔细把作者的理论套上去研究一番。</p><h4 id="《审美空间延伸与拓展-电影声音艺术理论》"><a href="#《审美空间延伸与拓展-电影声音艺术理论》" class="headerlink" title="《审美空间延伸与拓展: 电影声音艺术理论》"></a>《审美空间延伸与拓展: 电影声音艺术理论》</h4><p><img src="/images/%E5%AE%A1%E7%BE%8E%E7%A9%BA%E9%97%B4%E5%BB%B6%E4%BC%B8%E4%B8%8E%E6%8B%93%E5%B1%95_900.jpg" alt="审美空间延伸与拓展_900"><br>姚国强、孙欣，中国电影出版社，2002<br>北电的新世纪电影学论丛中一本著名书籍，尚未读完，不敢妄加评论。但就随便翻翻带来的观感而言，令人醍醐灌顶。电影声音艺术的研究对游戏声音设计的帮助是巨大的，要多多学习。</p><h4 id="《声音设计-电影中语言，音乐和音响的表现（第2版）》"><a href="#《声音设计-电影中语言，音乐和音响的表现（第2版）》" class="headerlink" title="《声音设计: 电影中语言，音乐和音响的表现（第2版）》"></a>《声音设计: 电影中语言，音乐和音响的表现（第2版）》</h4><p><img src="/images/%E5%A3%B0%E9%9F%B3%E8%AE%BE%E8%AE%A1_900.jpg" alt="声音设计_900"><br>David Sonnenschein，浙江大学出版社，2009<br>声音和画面、声音和叙事二章非常棒，可了解电影声音设计的方法论。与《审美空间延伸与拓展: 电影声音艺术理论》类比阅读，都是影视声音设计逆向输出的经典文献，值得深入学习。</p><h4 id="Sound-Design-and-Science-Fiction"><a href="#Sound-Design-and-Science-Fiction" class="headerlink" title="Sound Design and Science Fiction"></a><em>Sound Design and Science Fiction</em></h4><p><img src="/images/Sound%20Design%20and%20Science%20Fiction_900.jpg" alt="Sound Design and Science Fiction_900"><br>William Whittington, University of Texas Press, 2007<br>如果你对科幻电影中的声音设计很有兴趣，这本书的内容会很适合你。其中的声音研讨范围霸气阔《2001太空漫游》、《星球大战》、《异形》、《黑客帝国》及《终结者2》等，是科幻类电影声音设计的详实论述。</p><h4 id="Post-Sound-Design-The-Art-and-Craft-of-Audio-Post-Production-for-the-Moving-Image"><a href="#Post-Sound-Design-The-Art-and-Craft-of-Audio-Post-Production-for-the-Moving-Image" class="headerlink" title="Post Sound Design: The Art and Craft of Audio Post Production for the Moving Image"></a><em>Post Sound Design: The Art and Craft of Audio Post Production for the Moving Image</em></h4><p><img src="/images/Post%20Sound%20Design_900.jpg" alt="Post Sound Design_900"><br>John Avarese, Bloomsbury Academic, 2017<br>一本电影声音设计的完全论述，从什么是声音设计、设备连接、麦克风选择、DAW 的原理开始，到对白剪辑、音乐编辑、效果器应用、终混等，把影视声音全套流程过了一遍。</p><h4 id="Hollywood-Sound-Design-and-Moviesound-Newsletter-A-Case-Study-of-the-End-of-the-Analog-Age"><a href="#Hollywood-Sound-Design-and-Moviesound-Newsletter-A-Case-Study-of-the-End-of-the-Analog-Age" class="headerlink" title="Hollywood Sound Design and Moviesound Newsletter: A Case Study of the End of the Analog Age"></a><em>Hollywood Sound Design and Moviesound Newsletter: A Case Study of the End of the Analog Age</em></h4><p><img src="/images/Hollywood%20Sound%20Design%20and%20Moviesound%20Newsletter_900.jpg" alt="Hollywood Sound Design and Moviesound Newsletter_900"><br>David Stone, Focal Press, 2016<br>关于电影声音设计的一本详实著作，作者 David Stone 为奥斯卡奖获得者，有100多部电影的经验（爱德华剪刀手、夺宝奇兵3、蝙蝠侠归来等）。如果对好莱坞的声音设计很感兴趣，这本书是很好的切入点。</p><h4 id="The-Oxford-Handbook-of-Interactive-Audio"><a href="#The-Oxford-Handbook-of-Interactive-Audio" class="headerlink" title="The Oxford Handbook of Interactive Audio"></a><em>The Oxford Handbook of Interactive Audio</em></h4><p><img src="/images/The%20Oxford%20Handbook%20of%20Interactive%20Audio_900.jpg" alt="The Oxford Handbook of Interactive Audio_900"><br>Karen Collins, Bill Kapralos, Holly Tessler, Oxford University Press, 2017<br>牛津出版社的一本关于交互式音频的论文集，内容包括交互式音频实践、在游戏和 VR 中的应用、互动声音装置、相关工具和技巧等。</p><h4 id="Producing-Great-Sound-for-Film-and-Video"><a href="#Producing-Great-Sound-for-Film-and-Video" class="headerlink" title="Producing Great Sound for Film and Video"></a><em>Producing Great Sound for Film and Video</em></h4><p><img src="/images/Producing%20Great%20Sound%20for%20Film%20and%20Video_900.jpg" alt="Producing Great Sound for Film and Video_900"><br>Jay Rose, Focal Press, 2014<br>比较综合的书，之所以推荐这本，是因为其中对于同期录音、对白剪辑、后期的部分对声音设计师有一些可取之处，如果能看到的话可跳读一下。</p><h4 id="Studying-Sound-A-Theory-and-Practice-of-Sound-Design"><a href="#Studying-Sound-A-Theory-and-Practice-of-Sound-Design" class="headerlink" title="Studying Sound: A Theory and Practice of Sound Design"></a><em>Studying Sound: A Theory and Practice of Sound Design</em></h4><p><img src="/images/Studying%20Sound_900.jpg" alt="Studying Sound_900"><br>Karen Collins, The MIT Press, 2020<br>Karen Collins 的一本偏向实践的书，<em>Studying Sound</em> 我还没读到，但介绍中提到有多达175个练习，是颇为偏向练手的一本。其中的练习从练耳开始，看起来相当注重基础。</p><h4 id="Foundations-in-Sound-Design-for-Interactive-Media-A-Multidisciplinary-Approach"><a href="#Foundations-in-Sound-Design-for-Interactive-Media-A-Multidisciplinary-Approach" class="headerlink" title="Foundations in Sound Design for Interactive Media: A Multidisciplinary Approach"></a><em>Foundations in Sound Design for Interactive Media: A Multidisciplinary Approach</em></h4><p><img src="/images/Foundations%20in%20Sound%20Design%20for%20Interactive%20Media_900.jpg" alt="Foundations in Sound Design for Interactive Media_900"><br>Michael Filimowicz, Routledge, 2019<br>一本交互式媒体声音设计论文集，从游戏声音设计到装置艺术声音设计和网页交互声音设计均有涉猎。</p><h4 id="Foundations-in-Sound-Design-for-Linear-Media-A-Multidisciplinary-Approach"><a href="#Foundations-in-Sound-Design-for-Linear-Media-A-Multidisciplinary-Approach" class="headerlink" title="Foundations in Sound Design for Linear Media: A Multidisciplinary Approach"></a><em>Foundations in Sound Design for Linear Media: A Multidisciplinary Approach</em></h4><p><img src="/images/Foundations%20in%20Sound%20Design%20for%20Linear%20Media%20-%20A%20Multidisciplinary%20Approach_900.jpg" alt="Foundations in Sound Design for Linear Media - A Multidisciplinary Approach_900"><br>Michael Filimowicz, Routledge, 2019<br>同上，一本线性媒体声音设计论文集（其实还有本嵌入式媒体声音设计），这本偏影视的多。</p><h4 id="Sound-Design-Theory-and-Practice-Working-with-Sound"><a href="#Sound-Design-Theory-and-Practice-Working-with-Sound" class="headerlink" title="Sound Design Theory and Practice: Working with Sound"></a><em>Sound Design Theory and Practice: Working with Sound</em></h4><p><img src="/images/Sound%20Design%20Theory%20and%20Practice_900.jpg" alt="Sound Design Theory and Practice_900"><br>Leo Murray, Routledge, 2019<br>一本简单的小书，从电影、电视、游戏分析了声音设计的理论基础，闲暇可翻（电影分析的是1933年版金刚，很有历史感）。</p><h4 id="Sound-Works-A-Cultural-Theory-of-Sound-Design"><a href="#Sound-Works-A-Cultural-Theory-of-Sound-Design" class="headerlink" title="Sound Works: A Cultural Theory of Sound Design"></a><em>Sound Works: A Cultural Theory of Sound Design</em></h4><p><img src="/images/Sound%20Works_900.jpg" alt="Sound Works_900"><br>Holger Schulze, Bloomsbury Academic, 2020<br>什么是声音设计？它在21世纪早期的功能是什么？这本书从文化理论角度出发讨论了这些问题。听起来非常理论化，其实第二部分 Sonic Labor 的插图对声音设计师的视觉化描述非常有趣。</p><h4 id="The-Fundamentals-of-Sonic-Art-and-Sound-Design"><a href="#The-Fundamentals-of-Sonic-Art-and-Sound-Design" class="headerlink" title="The Fundamentals of Sonic Art and Sound Design"></a><em>The Fundamentals of Sonic Art and Sound Design</em></h4><p><img src="/images/The%20Fundamentals%20of%20Sonic%20Art%20and%20Sound%20Design_900.jpg" alt="The Fundamentals of Sonic Art and Sound Design_900">Tony Gibbs, Fairchild Books, 2007<br>一句话：声音装置艺术爱好者的福音。想把声音设计掺和到声音艺术领域的人大可从本书中汲取营养，看看大家是怎么玩的。</p><h4 id="The-Plagrave-Handbook-of-Sound-Design-and-Music-in-Screen-Media"><a href="#The-Plagrave-Handbook-of-Sound-Design-and-Music-in-Screen-Media" class="headerlink" title="The Plagrave Handbook of Sound Design and Music in Screen Media"></a><em>The Plagrave Handbook of Sound Design and Music in Screen Media</em></h4><p><img src="/images/The%20Plagrave%20Handbook%20of%20Sound%20Design%20and%20Music%20in%20Screen%20Medi_900.jpg" alt="The Plagrave Handbook of Sound Design and Music in Screen Medi_900">Liz Greene, Danijela Kulezic-Wilson, Palgrave Macmillan, 2016<br>影视配乐与声音设计之间的关系越来越模，这本文集就集合了相关的一些文章。仅少量声音设计相关的论述值得一看。</p><h3 id="2-2-拟音（Foley）"><a href="#2-2-拟音（Foley）" class="headerlink" title="2.2 拟音（Foley）"></a>2.2 拟音（Foley）</h3><h4 id="《拟音圣经-电影、游戏和动画片中的声音表演艺术》"><a href="#《拟音圣经-电影、游戏和动画片中的声音表演艺术》" class="headerlink" title="《拟音圣经: 电影、游戏和动画片中的声音表演艺术》"></a>《拟音圣经: 电影、游戏和动画片中的声音表演艺术》</h4><p><img src="/images/%E6%8B%9F%E9%9F%B3%E5%9C%A3%E7%BB%8F_900.jpg" alt="拟音圣经_900">Vanessa Theme Ament，人民邮电出版社，2010<br>必读书籍，无需赘述，掰芹菜和砸湿抹布都是拿手好戏。</p><h4 id="《影视拟音技巧》"><a href="#《影视拟音技巧》" class="headerlink" title="《影视拟音技巧》"></a>《影视拟音技巧》</h4><p><img src="/images/%E5%BD%B1%E8%A7%86%E6%8B%9F%E9%9F%B3%E6%8A%80%E5%B7%A7_900.jpg" alt="影视拟音技巧_900"><br>魏俊华，高超，高士义，中国广播电视出版社，2012<br>虽然权威，但废话极多，且图片编辑极其不专业（直接拍照），建议跳读+一张导图完事。</p><h3 id="2-3-Pure-Data"><a href="#2-3-Pure-Data" class="headerlink" title="2.3 Pure Data"></a>2.3 Pure Data</h3><p>之所以这部分只放 Pure Data 而没有 Max、Csound、SuperCollider、ChucK 等。是因为在下着实精力有限，以后学到了再更相关资料。不过这些东西其实读文档和看 YouTube 足矣，纸质出版物远没有 Pd 多。</p><h4 id="《设计声音》"><a href="#《设计声音》" class="headerlink" title="《设计声音》"></a>《设计声音》</h4><p><img src="/images/%E8%AE%BE%E8%AE%A1%E5%A3%B0%E9%9F%B3_900.jpg" alt="设计声音_900"><br>Andy Farnell，中国邮电出版社，2017<br>过程式音频设计原理 + Pure Data 入门，很有趣的书（前面理论部分若已知悉一些跳读起来更爽快）。</p><h4 id="《电子音乐技术》"><a href="#《电子音乐技术》" class="headerlink" title="《电子音乐技术》"></a>《电子音乐技术》</h4><p><img src="/images/%E7%94%B5%E5%AD%90%E9%9F%B3%E4%B9%90%E6%8A%80%E6%9C%AF_900.jpg" alt="电子音乐技术_900"><br>Miller Puckette，人民邮电出版社，2011<br>Pure Data 作者本人写的书，从头带你玩声音合成。英语基础不好看不懂文档的同学可以先看这个。</p><h4 id="《交互式音频程序开发》"><a href="#《交互式音频程序开发》" class="headerlink" title="《交互式音频程序开发》"></a>《交互式音频程序开发》</h4><p><img src="/images/%E4%BA%A4%E4%BA%92%E5%BC%8F%E9%9F%B3%E9%A2%91%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91_900.jpg" alt="交互式音频程序开发_900"><br>童雷，韩柯，人民邮电出版社，2018<br>一本简单的 Pure Data 介绍类书籍，把基础的合成方法过了一遍，最后配置了 OSC 来应了书的主题。</p><h4 id="《Pure-Data-图形化音乐编程技术与应用》"><a href="#《Pure-Data-图形化音乐编程技术与应用》" class="headerlink" title="《Pure Data 图形化音乐编程技术与应用》"></a>《Pure Data 图形化音乐编程技术与应用》</h4><p><img src="/images/Pure%20Data%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E9%9F%B3%E4%B9%90%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8_900.jpg" alt="Pure Data 图形化音乐编程技术与应用_900">杨万钧，西南师范大学出版社，2017<br>川音电子音乐理论与技术丛书中讲 Pure Data 的一本，算是本土化不错的一本详细的 Pd 介绍。本套丛书还涉及了 Kyma、Max、Csound、VVVV 等令人兴奋的内容，值得一看。</p><h4 id="Multimedia-Programming-with-Pure-Data"><a href="#Multimedia-Programming-with-Pure-Data" class="headerlink" title="Multimedia Programming with Pure Data"></a><em>Multimedia Programming with Pure Data</em></h4><p><img src="/images/Multimedia%20Programming%20with%20Pure%20Data_900.jpg" alt="Multimedia Programming with Pure Data_900">Bryan WC Chung, Packt Publishing, 2013<br>这本更着重讲 Pure Data 里视频组件做多媒体艺术的部分。</p><h4 id="Programming-Sound-with-Pure-Data-Make-Your-Apps-Come-Alive-with-Dynamic-Audio"><a href="#Programming-Sound-with-Pure-Data-Make-Your-Apps-Come-Alive-with-Dynamic-Audio" class="headerlink" title="Programming Sound with Pure Data: Make Your Apps Come Alive with Dynamic Audio"></a><em>Programming Sound with Pure Data: Make Your Apps Come Alive with Dynamic Audio</em></h4><p><img src="/images/Programming%20Sound%20with%20Pure%20Data_%20Make%20Your%20Apps%20Come%20Alive%20with%20Dynamic%20Audio_900.jpg" alt="Programming Sound with Pure Data_ Make Your Apps Come Alive with Dynamic Audio_900"><br>Tony Hillerson, Pragmatic Bookshelf, 2014<br>除了前面的基础部分，让 App 使用动态音频实际指的是对一个 Web 游戏添加 Pd Patch 来产生交互。</p><h3 id="2-4-VCV-Rack"><a href="#2-4-VCV-Rack" class="headerlink" title="2.4 VCV Rack"></a>2.4 VCV Rack</h3><p>VCV Rack 文档配合 YouTube 视频实际已经可以满足学习需求，但鉴于我一开始找到了相关资料，就一并放出供初学者参考。</p><h4 id="How-to-Rack"><a href="#How-to-Rack" class="headerlink" title="How to Rack"></a><em>How to Rack</em></h4><p><img src="/images/How%20to%20Rack_900.jpg" alt="How to Rack_900">Jim Aikin, Self-Publishing</p><h4 id="VCV-Rack-How-it-Works"><a href="#VCV-Rack-How-it-Works" class="headerlink" title="VCV Rack: How it Works"></a><em>VCV Rack: How it Works</em></h4><p><img src="/images/VCV%20Rack%20-%20How%20it%20Works_900.jpg" alt="VCV Rack - How it Works_900"><br>Edgar Rothermich, Self-Publishing, 2018<br>作者是中国女婿，册子也是非常友好的图文交互册子。</p><h4 id="Developing-Virtual-Synthesizers-with-VCV-Rack"><a href="#Developing-Virtual-Synthesizers-with-VCV-Rack" class="headerlink" title="Developing Virtual Synthesizers with VCV Rack"></a><em>Developing Virtual Synthesizers with VCV Rack</em></h4><p><img src="/images/Developing%20Virtual%20Synthesizers%20with%20VCV%20Rack_900.jpg" alt="Developing Virtual Synthesizers with VCV Rack_900"><br>Leonardo Gabrielli, Focal Press, 2020<br>开发自己的模块，对官网文档做了一个很好的整理。</p><h3 id="2-4-Reaktor"><a href="#2-4-Reaktor" class="headerlink" title="2.4 Reaktor"></a>2.4 Reaktor</h3><h4 id="《声音合成平台-Reaktor-操作指南》"><a href="#《声音合成平台-Reaktor-操作指南》" class="headerlink" title="《声音合成平台 Reaktor 操作指南》"></a>《声音合成平台 Reaktor 操作指南》</h4><p><img src="/images/%E5%A3%B0%E9%9F%B3%E5%90%88%E6%88%90%E5%B9%B3%E5%8F%B0REAKTOR%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97_900.jpg" alt="声音合成平台REAKTOR操作指南_900">夏田，人民邮电出版社，2016<br>夏老师经典之作，看不懂 Youtube 和 Kadenze 的朋友可以先看这本。虽然用的是 Reaktor 5，但对学习影响不大。</p><h3 id="2-5-合成器"><a href="#2-5-合成器" class="headerlink" title="2.5 合成器"></a>2.5 合成器</h3><h4 id="《自己动手做声音-声音合成与制作基础》"><a href="#《自己动手做声音-声音合成与制作基础》" class="headerlink" title="《自己动手做声音: 声音合成与制作基础》"></a>《自己动手做声音: 声音合成与制作基础》</h4><p><img src="/images/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%81%9A%E5%A3%B0%E9%9F%B3_900.jpg" alt="自己动手做声音_900"><br>程伊兵，中央音乐学院出版社，2009<br>程老师声音合成经典著作，唯一的缺点是例子基于 Nord Modular G2，但单纯的学思路是没有任何影响的。</p><h4 id="《声音合成与采样技术（第3版）》"><a href="#《声音合成与采样技术（第3版）》" class="headerlink" title="《声音合成与采样技术（第3版）》"></a>《声音合成与采样技术（第3版）》</h4><p><img src="/images/%E5%A3%B0%E9%9F%B3%E5%90%88%E6%88%90%E4%B8%8E%E9%87%87%E6%A0%B7%E6%8A%80%E6%9C%AF%20%20%E7%AC%AC3%E7%89%88_OCR_900.jpg" alt="声音合成与采样技术  第3版_OCR_900">Martin Russ，人民邮电出庵社，2011<br>夏老师翻译的一本对声音合成解释非常详细的制作，非常底层的从 VCA、VCO、VCF 这种初上模块容易令人困惑的概念讲起，值得深入学习的一本好书。</p><h4 id="《软件合成器技术实战手册-音色制作与模块编程》"><a href="#《软件合成器技术实战手册-音色制作与模块编程》" class="headerlink" title="《软件合成器技术实战手册: 音色制作与模块编程》"></a>《软件合成器技术实战手册: 音色制作与模块编程》</h4><p><img src="/images/%E8%BD%AF%E4%BB%B6%E5%90%88%E6%88%90%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98%E6%89%8B%E5%86%8C_900.jpg" alt="软件合成器技术实战手册_900"><br>飞来音，清华大学出版社，2008<br>看不懂英文说明书和教程的同学可翻翻这本老书。</p><h4 id="Creating-Sounds-from-Scratch-A-Practical-Guide-to-Music-Synthesis-for-Producers-and-Composers"><a href="#Creating-Sounds-from-Scratch-A-Practical-Guide-to-Music-Synthesis-for-Producers-and-Composers" class="headerlink" title="Creating Sounds from Scratch: A Practical Guide to Music Synthesis for Producers and Composers"></a><em>Creating Sounds from Scratch: A Practical Guide to Music Synthesis for Producers and Composers</em></h4><p><img src="/images/Creating%20Sounds%20from%20Scratch_900.jpg" alt="Creating Sounds from Scratch_900"><br>Andrea Pejrolo, Scott B. Metcalfe, Oxford University Press, 2017<br>基本可以看做是《声音合成与采样技术》更符合阅读学习体验的版本，贴心的从历史到基础术语讲起。每种合成方式独占一章，且配合详细的聆听指南让读者记忆音色中所用的模块，非常人性化。</p><h4 id="The-Synthesizer-A-Comprehensive-Guide-to-Understanding-Programming-Playing-and-Recording-the-Ultimate-Electronic-Music-Instrument"><a href="#The-Synthesizer-A-Comprehensive-Guide-to-Understanding-Programming-Playing-and-Recording-the-Ultimate-Electronic-Music-Instrument" class="headerlink" title="The Synthesizer: A Comprehensive Guide to Understanding, Programming, Playing, and Recording the Ultimate Electronic Music Instrument"></a><em>The Synthesizer: A Comprehensive Guide to Understanding, Programming, Playing, and Recording the Ultimate Electronic Music Instrument</em></h4><p><img src="/images/The%20Synthesizer_900.jpg" alt="The Synthesizer_900"><br>Mark Vail, Oxford University Press, 2014<br>相比 <em>Creating Sounds from Scratch</em>，这本小书更强调介绍合成器历史，并拉人入坑到模块世界去。</p><h4 id="Computer-Sound-Design-Synthesis-Techniques-and-Programming-2nd-edition"><a href="#Computer-Sound-Design-Synthesis-Techniques-and-Programming-2nd-edition" class="headerlink" title="Computer Sound Design: Synthesis Techniques and Programming 2nd edition"></a><em>Computer Sound Design: Synthesis Techniques and Programming 2nd edition</em></h4><p><img src="/images/Computer%20Sound%20Design_900.jpg" alt="Computer Sound Design_900">Eduardo Reck Miranda, Focal Press, 2002<br>作为一本老书，前面的声音合成理论自然不会过时。但有趣的部分是，可一览当年的声音合成程序，如命令行的 pcmusic、Som-A，史前 Reaktor 等。</p><h4 id="Becoming-a-Synthesizer-Wizard-From-Presets-to-Power-User"><a href="#Becoming-a-Synthesizer-Wizard-From-Presets-to-Power-User" class="headerlink" title="Becoming a Synthesizer Wizard: From Presets to Power User"></a><em>Becoming a Synthesizer Wizard: From Presets to Power User</em></h4><p><img src="/images/Becoming%20a%20Synthesizer%20Wizard%20From%20Presets%20to%20Power%20User_900.jpg" alt="Becoming a Synthesizer Wizard From Presets to Power User_900"><br>Simon Cann, Cengage Learning PTR, 2009<br>也算一本不错的合成器教程，缺点是示例软件过老，建议用模块复刻其中的 Patch。</p><h4 id="Welsh’s-Synthesizer-Cookbook-Synthesizer-Programming-Sound-Analysis-and-Universal-Patch-Book-1、2"><a href="#Welsh’s-Synthesizer-Cookbook-Synthesizer-Programming-Sound-Analysis-and-Universal-Patch-Book-1、2" class="headerlink" title="Welsh’s Synthesizer Cookbook: Synthesizer Programming, Sound Analysis, and Universal Patch Book 1、2"></a><em>Welsh’s Synthesizer Cookbook: Synthesizer Programming, Sound Analysis, and Universal Patch Book 1、2</em></h4><p><img src="/images/Welsh&#39;s%20Synthesizer%20Cookbook_900.jpg" alt="Welsh&#39;s Synthesizer Cookbook_900"><br>Fred Welsh, 2006<br>没有废话，讲完点前置知识后直接上各种 Patch 的配置表，都是通用的参数，可直接在自己的合成器里复刻研究，十分实用。</p><h4 id="Refining-Sound-A-Practical-Guide-to-Synthesis-and-Synthesizers"><a href="#Refining-Sound-A-Practical-Guide-to-Synthesis-and-Synthesizers" class="headerlink" title="Refining Sound: A Practical Guide to Synthesis and Synthesizers"></a><em>Refining Sound: A Practical Guide to Synthesis and Synthesizers</em></h4><p><img src="/images/Refining%20Sound_900.jpg" alt="Refining Sound_900"><br>Brian K. Shepard, Oxford University Press, 2013<br>一本合成器快速入门的小册子，讲的不够详细，快速翻翻入门还不错。</p><h4 id="Analog-Synthesizers-Understanding-Performing-Buying-2nd-edition"><a href="#Analog-Synthesizers-Understanding-Performing-Buying-2nd-edition" class="headerlink" title="Analog Synthesizers: Understanding, Performing, Buying 2nd edition"></a><em>Analog Synthesizers: Understanding, Performing, Buying 2nd edition</em></h4><p><img src="/images/Analog%20Synthesizers_900.jpg" alt="Analog Synthesizers_900"><br>Mark Jenkins, Routledge, 2020<br>伴随模拟和数字合成器的历史更迭，讲述合成器的使用。</p><h4 id="Microsound"><a href="#Microsound" class="headerlink" title="Microsound"></a><em>Microsound</em></h4><p><img src="/images/Microsound_900.jpg" alt="Microsound_900"><br>Curtis Roads, The MIT Press, 2001<br>伟大的 <em>The Computer Music Tutorial</em> 的作者，这本主讲微分音与声音合成。</p><h3 id="2-6-空间音频"><a href="#2-6-空间音频" class="headerlink" title="2.6 空间音频"></a>2.6 空间音频</h3><p>关于空间音频，这几本可能是目前领域最前沿的研究材料了。</p><h4 id="《空间声原理》"><a href="#《空间声原理》" class="headerlink" title="《空间声原理》"></a>《空间声原理》</h4><p><img src="/images/%E7%A9%BA%E9%97%B4%E5%A3%B0%E5%8E%9F%E7%90%86_900_900.jpg" alt="空间声原理_900_900"><br>谢菠荪，科学出版社，2019<br>作为“现代声学科学与技术丛书”中比较贴近民用的一本（这套书里关于声呐和噪声控制的较多），由华南理工大学的谢菠荪教授所著，是国内第一本讨论空间声领域的全面著作。内容包括空间环绕声、Ambisonics、矩阵环绕声、双耳 HRTF 等诸多内容，书后附有1000多篇领域论文名，可供对空间音频有意深究的朋友阅读。</p><h4 id="《空间线索在3D音频中的应用研究》"><a href="#《空间线索在3D音频中的应用研究》" class="headerlink" title="《空间线索在3D音频中的应用研究》"></a>《空间线索在3D音频中的应用研究》</h4><p><img src="/images/%E7%A9%BA%E9%97%B4%E7%BA%BF%E7%B4%A2%E5%9C%A83D%E9%9F%B3%E9%A2%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E7%A0%94%E7%A9%B6_900.jpg" alt="空间线索在3D音频中的应用研究_900">张聪，中国水利水电出版社，2019<br>本书主要讨论的是影视下3D音频优化，通过实验手段验证合理降低多声道的参数码率。</p><h4 id="Ambisonics"><a href="#Ambisonics" class="headerlink" title="Ambisonics"></a><em>Ambisonics</em></h4><p><img src="/images/Ambisonics_900.jpg" alt="Ambisonics_900"><br>Franz Zotter, Matthias Frank, Springer, 2019<br>关于 Ambisonics 的概念和应用，一站式解决。</p><h4 id="Immersive-Sound"><a href="#Immersive-Sound" class="headerlink" title="Immersive Sound"></a><em>Immersive Sound</em></h4><p><img src="/images/Immersive%20Sound_900.jpg" alt="Immersive Sound_900"><br>Agnieszka Roginska, Paul Geluso, Routledge, 2018<br>沉浸式声音有关概念和应用。</p><h2 id="3-技术音频"><a href="#3-技术音频" class="headerlink" title="3. 技术音频"></a>3. 技术音频</h2><h3 id="3-1-导论及文集"><a href="#3-1-导论及文集" class="headerlink" title="3.1 导论及文集"></a>3.1 导论及文集</h3><p>导论与文集中大多为对引擎架构、游戏音频编程有关内容的书。作为与技术美术相仿的职位，技术音频还是应该对整个游戏的开发都有一个概念性的认知。<br>叶大有一个游戏程序员开发的书单，大家如果对游戏开发有兴趣可以寻找自己喜欢的书观看。缺点是这份书单三年没维护，且其中关于游戏音频的部分更是匮乏，这也是我这份书单存在的意义。<br>叶大书单：<a href="https://github.com/miloyip/game-programmer/" target="_blank" rel="noopener">https://github.com/miloyip/game-programmer/</a></p><h4 id="《游戏引擎架构》"><a href="#《游戏引擎架构》" class="headerlink" title="《游戏引擎架构》"></a>《游戏引擎架构》</h4><p><img src="/images/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%20_900.jpg" alt="游戏引擎架构 _900"><br>Jason Gregory, 电子工业出版社, 2014<br>叶大知名译作，虽然刚出了第2版但鉴于还没买……就先推荐第1版吧。原作在 Amazon 上也是评价颇高，对不熟悉引擎的人来说快速摸一遍结构，再读说明书也会明朗不少。</p><h4 id="《游戏编程算法与技巧》"><a href="#《游戏编程算法与技巧》" class="headerlink" title="《游戏编程算法与技巧》"></a>《游戏编程算法与技巧》</h4><p><img src="/images/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7_900.jpg" alt="游戏编程算法与技巧_900"><br>Sanjay Madhav，电子工业出版社，2016<br>侯老师推荐给我的一本，来自腾讯的瀚阳老师精心译作。作为南加州大学的本科教材，系统讲解了游戏开发中基础的各方面，4-11章中充满亮点。关于物理、声音和脚本语言的部分很不错，初学者跟着实现一遍附带的项目会很有帮助。</p><h4 id="The-Audio-Programming-Book"><a href="#The-Audio-Programming-Book" class="headerlink" title="The Audio Programming Book"></a><em>The Audio Programming Book</em></h4><p><img src="/images/The%20Audio%20Programming%20Book_900.jpg" alt="The Audio Programming Book_900"><br>Richard Boulanger, eVictor Lazzarini, The MIT Press, 2011<br>一本关于音频编程的文集，不仅探讨了 C, C++, Csound，对 DFT、FFT、卷积等经典概念也有专门的文章进行讨论。是非常好的音频编程益智类读物，适合休闲娱乐时补充营养之用。</p><h4 id="Game-Audio-Programming-Principles-and-Practices-1、2、3"><a href="#Game-Audio-Programming-Principles-and-Practices-1、2、3" class="headerlink" title="Game Audio Programming: Principles and Practices 1、2、3"></a><em>Game Audio Programming: Principles and Practices 1、2、3</em></h4><p><img src="/images/GAP%20all_900.jpg" alt="GAP all_900"><br>Guy Somberg, CRC Press, 2016 2018 2020<br>Guy 老哥作为这系列游戏音频编程文集的编者，估计技术音频们没有不知道的。之前简单翻了翻前言，说说刚出版的第三册的内容：音频资源管理、DSP 编程、语音管线、抽象游戏音频层级为 Patch Cable、声部管理等迷人的部分。<br>文中具体的作者均是行业先锋，有兴趣考据可翻翻作者介绍。</p><h4 id="Beep-To-Boom-The-Development-Of-Advanced-Runtime-Sound-Systems-For-Games-And-Extended-Reality"><a href="#Beep-To-Boom-The-Development-Of-Advanced-Runtime-Sound-Systems-For-Games-And-Extended-Reality" class="headerlink" title="Beep To Boom: The Development Of Advanced Runtime Sound Systems For Games And Extended Reality"></a><em>Beep To Boom: The Development Of Advanced Runtime Sound Systems For Games And Extended Reality</em></h4><p><img src="/images/Beep%20To%20Boom_900.jpg" alt="Beep To Boom_900"><br>Simon N Goodwin, Focal Press, 2019<br>主要内容是关于交互式音频系统的设计开发，内容详实。</p><h4 id="Game-Audio-Tales-of-a-Technical-Sound-Designer-1、2"><a href="#Game-Audio-Tales-of-a-Technical-Sound-Designer-1、2" class="headerlink" title="Game Audio: Tales of a Technical Sound Designer 1、2"></a><em>Game Audio: Tales of a Technical Sound Designer 1、2</em></h4><p><img src="/images/Game%20Audio%20Tales_900.jpg" alt="Game Audio Tales_900"><br>Damian Kastbauer, 2017<br>Audiokinetic 产品经理胡子哥，WAG 的前身 Wwise 工程大冒险的奠基人。他的两本书收集了他关于技术音频或技术声音设计师（Technical Sound Designer）的诸多博文与采访，其中关于整合工具的部分令人大开眼界。</p><h3 id="3-2-引擎使用"><a href="#3-2-引擎使用" class="headerlink" title="3.2 引擎使用"></a>3.2 引擎使用</h3><p>关于两大主流商业引擎（Unity、Unreal Engine）的使用，除了必看的文档之外，还有一些我看过蛮不错的参考书籍。</p><h4 id="《Unity-3D-游戏开发（第二版）》"><a href="#《Unity-3D-游戏开发（第二版）》" class="headerlink" title="《Unity 3D 游戏开发（第二版）》"></a>《Unity 3D 游戏开发（第二版）》</h4><p><img src="/images/Unity%203D%20%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_900.jpg" alt="Unity 3D 游戏开发_900"><br>宣雨松，人民邮电出版社，2018<br>雨松老师是天马时空的 Unity 技术专家，这本书对 Unity 的各个方面都进行了详细的讲解。对于入门的人来说比较友好，比如对脚本、AB 包、自动打包之类的技术感兴趣可直接跳跃翻看雨松老师的讲解，部分比文档更有针对性。</p><h4 id="Unity-Game-Development-Cookbook"><a href="#Unity-Game-Development-Cookbook" class="headerlink" title="Unity Game Development Cookbook"></a><em>Unity Game Development Cookbook</em></h4><p><img src="/images/Unity%20Game%20Development%20Cookbook_900.jpg" alt="Unity Game Development Cookbook_900"><br>Paris Buttfield-Addison, Jon Manning, Tim Nugent, O’Reilly Media, 2019<br>Cookbook 是一种很棒的书籍交流形式，书中没有以章节为中心的讲述形式。相反，每个章节只代表一类问题的集合。比如 Prefab，书中提出的问题就是“想把一个游戏对象保存为文件，好方便复用”，随后给出详细的解决方案、讨论、提醒等。<br>在翻文档和搜索问题之前抽空扫一眼目录，或许你的问题就有答案。</p><h4 id="Unreal-Engine-Game-Development-Cookbook"><a href="#Unreal-Engine-Game-Development-Cookbook" class="headerlink" title="Unreal Engine Game Development Cookbook"></a><em>Unreal Engine Game Development Cookbook</em></h4><p><img src="/images/Unreal%20Engine%20Game%20Development%20Cookbook_900.jpg" alt="Unreal Engine Game Development Cookbook_900"><br>John P. Doran, Packt Publishing, 2015<br>与上一本书相同，这本针对 UE4，把常见的问题都拎出来放在目录中供你挑拣，针对需要的问题直接点对点查看解决方案。</p><h3 id="3-3-游戏引擎音频整合"><a href="#3-3-游戏引擎音频整合" class="headerlink" title="3.3 游戏引擎音频整合"></a>3.3 游戏引擎音频整合</h3><h4 id="Game-Audio-Development-with-Unity-5-X"><a href="#Game-Audio-Development-with-Unity-5-X" class="headerlink" title="Game Audio Development with Unity 5.X"></a><em>Game Audio Development with Unity 5.X</em></h4><p><img src="/images/Game%20Audio%20Development%20with%20Unity%205.X_900.jpg" alt="Game Audio Development with Unity 5.X_900"><br>Micheal Lanham, Packt Publishing, 2017<br>虽然使用的 Unity 版本比较老，但这本是少有的对 Unity 音频部分拿出整本篇幅来介绍的书。在后半部分包括对 FMOD Studio 的介绍、音频可视化、Lip Syncing、性能优化等非常有价值的内容。非常适合作为学习 Unity 整合前的引擎自带音频功能补课，远比官网文档要详细。</p><h4 id="Game-Audio-Implementation-A-Practical-Guide-Using-the-Unreal-Engine"><a href="#Game-Audio-Implementation-A-Practical-Guide-Using-the-Unreal-Engine" class="headerlink" title="Game Audio Implementation: A Practical Guide Using the Unreal Engine"></a><em>Game Audio Implementation: A Practical Guide Using the Unreal Engine</em></h4><p><img src="/images/Game%20audio%20implementation_900.jpg" alt="Game audio implementation_900">Richard Stevens, Dave Raybould, Focal Press, 2016<br>主讲使用 UE4 自带的音频功能进行声音整合。</p><h4 id="Game-Audio-with-FMOD-and-Unity"><a href="#Game-Audio-with-FMOD-and-Unity" class="headerlink" title="Game Audio with FMOD and Unity"></a><em>Game Audio with FMOD and Unity</em></h4><p><img src="/images/Game%20Audio%20with%20FMOD%20and%20Unity_900.jpg" alt="Game Audio with FMOD and Unity_900"><br>Ciarán Robinson, Routledge, 2019<br>使用 FMOD 给 Unity 进行音频整合，不过聪明的同学应该想得出，从本书学会怎么改脚本，一样能套到 Wwise Unity 整合上。（奸笑</p><h4 id="The-Handbook-of-Game-Audio-Using-Wwise"><a href="#The-Handbook-of-Game-Audio-Using-Wwise" class="headerlink" title="The Handbook of Game Audio Using Wwise"></a><em>The Handbook of Game Audio Using Wwise</em></h4><p>Gordon Durity, Aleksandar Zecevic, A K Peters, 2021<br>跳票已久的 Wwise 书，作者是 EA 的两位老哥，封面欠缺。</p><h3 id="3-4-插件开发"><a href="#3-4-插件开发" class="headerlink" title="3.4 插件开发"></a>3.4 插件开发</h3><p>鉴于在下的插件开发了解着实较少，就只列基本常见书籍，以后再更。</p><h4 id="Getting-Started-with-JUCE"><a href="#Getting-Started-with-JUCE" class="headerlink" title="Getting Started with JUCE"></a><em>Getting Started with JUCE</em></h4><p><img src="/images/Getting%20Started%20with%20JUCE_900.jpg" alt="Getting Started with JUCE_900"><br>Martin Robinson, Packt Publishing, 2013<br>关于 JUCE 的一本小书，其实看文档和 Kadenze 会更好些。</p><h4 id="Audio-Effects-Theory-Implementation-and-Application"><a href="#Audio-Effects-Theory-Implementation-and-Application" class="headerlink" title="Audio Effects: Theory, Implementation and Application"></a><em>Audio Effects: Theory, Implementation and Application</em></h4><p><img src="/images/Audio%20Effects_900.jpg" alt="Audio Effects_900"><br>Joshua D. Reiss, Andrew McPherson, CRC Press, 2014<br>跟接下来三本比，算是插件设计里比较轻松的一本读物。比较适合对新手理解效果器原理学习，每章更是友好的提供习题，最后例子的实现仍基于 JUCE。</p><h4 id="DAFX-Digital-Audio-Effects"><a href="#DAFX-Digital-Audio-Effects" class="headerlink" title="DAFX Digital Audio Effects"></a><em>DAFX Digital Audio Effects</em></h4><p><img src="/images/DAFX%20Digital%20Audio%20Effects_900.jpg" alt="DAFX Digital Audio Effects_900"><br>Udo Zölzer, Wiley, 2011<br>著名的 DAFX，目前还找不出需求读这本，不过对做音频算法的朋友来说应该是都知道的了。</p><h4 id="Designing-Audio-Effect-Plug-Ins-in-C-With-Digital-Audio-Signal-Processing-Theory"><a href="#Designing-Audio-Effect-Plug-Ins-in-C-With-Digital-Audio-Signal-Processing-Theory" class="headerlink" title="Designing Audio Effect Plug-Ins in C++ With Digital Audio Signal Processing Theory"></a><em>Designing Audio Effect Plug-Ins in C++ With Digital Audio Signal Processing Theory</em></h4><p><img src="/images/Designing%20Audio%20Effect%20Plug-Ins%20in%20C++%20With%20Digital%20Audio%20Signal%20Processing%20Theory_900.jpg" alt="Designing Audio Effect Plug-Ins in C++ With Digital Audio Signal Processing Theory_900"><br>Will C. Pirkle, Focal Press, 2012<br>DSP 开发宝典之一。</p><h4 id="Designing-Software-Synthesizer-Plug-Ins-in-C-For-RackAFX-VST3-and-Audio-Units"><a href="#Designing-Software-Synthesizer-Plug-Ins-in-C-For-RackAFX-VST3-and-Audio-Units" class="headerlink" title="Designing Software Synthesizer Plug-Ins in C++ For RackAFX, VST3, and Audio Units"></a><em>Designing Software Synthesizer Plug-Ins in C++ For RackAFX, VST3, and Audio Units</em></h4><p><img src="/images/Designing%20Software%20Synthesizer%20Plug-Ins%20in%20C++%20For%20RackAFX,%20VST3,%20and%20Audio%20Units_900.jpg" alt="Designing Software Synthesizer Plug-Ins in C++ For RackAFX, VST3, and Audio Units_900"><br>Will C. Pirkle, Focal Press, 2014<br>开发宝典之二。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏音频 </tag>
            
            <tag> 音频编程 </tag>
            
            <tag> 声音设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>人人都能用 WAAPI（四）Topics（订阅类 API）（暂时作废）</title>
      <link href="/2019/09/30/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2019/09/30/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>本篇是对 WAAPI 分析的最后一篇文章，目前只剩下 Topics（订阅类）的 API 尚未讨论。我们会继续对其进行拆解，以帮助大家理解其功能。<br>在《人人都能用 WAAPI（一）概述》中曾经简单讲解过订阅类 API 的功能，它的主要功能就是订阅 Wwise 内某一类变化的发生状态，比如对象创建、属性改变、执行动作等，并发回消息提醒用户。订阅类 API 的功能实现基于动作发生时的回调函数，这部分会在实例中详细讲解。</p><blockquote><p>阅前须知：</p><ul><li><strong>把 API 逐条列出讲解是为了快速阐述其功能，补充文档的一些不足，以帮助大家快速对 WAAPI 建立印象</strong>，并非重写参考文档。所以建议看完本文后按照第一篇文中所提的方法，用自己喜欢的整理方式重新整理一次。</li><li>本文并不会把每个参数全都翻译并复述一遍功能，这里<strong>均假设读者已学会了概述中的 JSON 阅读方法，能够自行根据我的介绍查阅 WAAPI 参数及返回值等文档信息，此外还希望读者能准确的找到在线文档中对应的章节。</strong></li><li>为了照顾初学者，我尽量把注释写到每一行，以便快速入门。</li><li>RTFM，因为接下来的文章比较严肃。<strong>如发现某些概念看不懂或找不到，请善用 Wwise 文档强大的搜索功能或通过 Google 检索所需答案。</strong></li><li><strong>因为 WAAPI 的功能也是随版本更新逐渐添加的，建议安装最新版 Wwise 进行操作。</strong>当报错信息提示 “The procedure URI is unknown.” 时，就代表你的当前 WAAPI 版本并不支持此 API。</li></ul></blockquote><p>本文目录：</p><p>[toc]</p><h2 id="wwise-core-概览"><a href="#wwise-core-概览" class="headerlink" title="wwise.core 概览"></a>wwise.core 概览</h2><p><img src="/images/%E8%AE%A2%E9%98%85wwise.core.png" alt="订阅wwise.core"></p><p>与 Functions（执行类 API）相同，Topics（订阅类 API）中最大的功能模块也是 <code>wwise.core</code>。<br><strong>在开始前请注意这些 API 的一个共性，它们的可选的 Options 中绝大多数存在两个公用选项</strong>。其一是 <code>platform</code>（平台），另一个是通过 <code>return</code> 设置的 Wwise 对象内置的存取器提供的诸多标准属性（可参考文档中有关 “built-in accessors for Wwise objects” 的描述，以下简称为“基本信息”）。</p><h2 id="object（订阅有关对象属性的改变）"><a href="#object（订阅有关对象属性的改变）" class="headerlink" title="object（订阅有关对象属性的改变）"></a>object（订阅有关对象属性的改变）</h2><h3 id="created-preDeleted-postDeleted"><a href="#created-preDeleted-postDeleted" class="headerlink" title="created, preDeleted, postDeleted"></a>created, preDeleted, postDeleted</h3><p><code>created</code> 可在工程中有对象被创建时，发布此对象被订阅的信息。具体的信息类型需要使用 Options 参数指定，如果此参数留空，发布的信息中只会包含 <code>object</code> 基本信息（包括 GUID 与对象类型）。<br><code>preDeleted</code> 与 <code>postDeleted</code> 的功能近似，区别是发布订阅的信息的时间点不同，<strong>前者在对象删除前发布消息，后者在删除后发布消息</strong>。对于需要精确时间戳的情况下，<code>preDeleted</code> 能够更精确的获得准确删除操作开始的时间点。与 <code>created</code> 一样，如果不提供 Options 指定订阅返回值，默认也只会返回 <code>object</code> 的基本信息。</p><h3 id="childAdded-childRemoved"><a href="#childAdded-childRemoved" class="headerlink" title="childAdded, childRemoved"></a>childAdded, childRemoved</h3><p><code>childAdded</code> 与 <code>childRemoved</code> 订阅了父对象（容器对象）中子对象的状态，当子对象被添加或移除时，会发布订阅的信息类型。<br>它们需要提供 Options 参数，来决定发布的信息中返回哪些对象信息类型。当不提供 Options 参数时，默认只会返回 <code>parent</code>（父对象） 和 <code>child</code>（对象的基本信息）。</p><h3 id="attenuationCurveChanged-attenuationCurveLinkChanged"><a href="#attenuationCurveChanged-attenuationCurveLinkChanged" class="headerlink" title="attenuationCurveChanged, attenuationCurveLinkChanged"></a>attenuationCurveChanged, attenuationCurveLinkChanged</h3><p><code>attenuationCurveChanged</code> 可订阅对象的衰减曲线的使用情况，但这个改变情况并非指衰减曲线本身（分割点位置、曲线类型）的变化，而是 Attenuation Editor 中衰减曲线的使用状态。<br><code>attenuationCurveLinkChanged</code> 订阅了衰减曲线在不同平台下的 Link 情况。<br><strong>我进行了多次测试，发现实际使用中这两者的功能相同，都会响应彼此的设计功能而发布相同的返回信息</strong>，因此这两个 API 可以混用。它们的可选 Options 参数中可设定所需的对象的基本信息。</p><h3 id="curveChanged-nameChanged-notesChanged"><a href="#curveChanged-nameChanged-notesChanged" class="headerlink" title="curveChanged, nameChanged, notesChanged"></a>curveChanged, nameChanged, notesChanged</h3><p><code>curveChanged</code> 可订阅对象属性曲线发生改变的情况，并不会返回曲线改变了多少。如不指定 Options，默认会返回 <code>owner</code>（被修改的对象）和 <code>curve</code>（被修改的曲线对象）的基本信息。<br><code>nameChanged</code> 可订阅对象名称的变化，如不指定 Options，默认会返回 <code>oldName</code>（修改前的对象名），<code>newName</code>（修改后的对象名），<code>object</code>（对象的基本信息）。<br><code>notesChanged</code> 可订阅对象备注的变化，如不指定 Options，默认会返回 <code>oldNotes</code>（修改前的备注），<code>newNotes</code>（修改后的备注），<code>object</code>（对象的基本信息）。</p><h3 id="propertyChanged-referenceChanged"><a href="#propertyChanged-referenceChanged" class="headerlink" title="propertyChanged, referenceChanged"></a>propertyChanged, referenceChanged</h3><p><code>propertyChanged</code> 可订阅对象的属性发生改变的具体情况，<strong>它也是 <code>wwise.core.object</code> 订阅子类中唯一需要提供必须参数的 API</strong>，Options 中必备的参数有 property（被修改的属性名）和 object（对象名或 GUID）。同时也指定基本参数来决定发布信息的返回值。默认情况下会返回 <code>property</code>（被修改的属性名），<code>object</code>（对象的基本信息），<code>old</code>（之前的属性值），<code>new</code>（新的属性值），<code>platform</code>（被修改属性值所在的平台）。<br><code>referenceChanged</code> 用来订阅对象引用发生变化的情况，如不指定 Options，默认会返回 <code>old</code>（之前的引用对象），<code>new</code>（之的的引用对象），<code>object</code>（引用被修改的对象），<code>reference</code>（被修改的引用对象的名字）。</p><h2 id="project（订阅工程的状态改变）"><a href="#project（订阅工程的状态改变）" class="headerlink" title="project（订阅工程的状态改变）"></a>project（订阅工程的状态改变）</h2><h3 id="loaded-saved"><a href="#loaded-saved" class="headerlink" title="loaded, saved"></a>loaded, saved</h3><p><code>loaded</code> 可在工程被正确加载后发布信息，无需参数，这个 API 指的是通过菜单打开工程或 <code>ak.wwise.ui.project.open</code> 打开工程并加载完成后发布消息。<br><code>saved</code> 可在工程保存后发布被修改文件的路径消息，<strong>它所返回的 <code>modifiedPaths</code> 很详细，每个被修改的 wwu 文件和工程内文件的的路径都会被返回。</strong></p><h3 id="preClosed-postClosed"><a href="#preClosed-postClosed" class="headerlink" title="preClosed, postClosed"></a>preClosed, postClosed</h3><p><code>preClosed</code> 和 <code>postClosed</code> 分别可在工程开始关闭和关闭完成时发布消息，注意这个关闭指的是通过 Crtl + F4 快捷键或 <code>ak.wwise.ui.project.close</code> 来关闭的工程，并不是点击窗口关闭按钮关闭整个 Wwise。</p><h2 id="soundbank（订阅-SoundBank-生成状态）"><a href="#soundbank（订阅-SoundBank-生成状态）" class="headerlink" title="soundbank（订阅 SoundBank 生成状态）"></a>soundbank（订阅 SoundBank 生成状态）</h2><h3 id="generated-generationDone"><a href="#generated-generationDone" class="headerlink" title="generated, generationDone"></a>generated, generationDone</h3><p><code>generated</code> 可订阅 SoundBank 开始生成时的信息，在每个平台的每个 SoundBank 开始生成时都会被触发，因此会发布多个消息。Options 中除了设定 SoundBank 对象的基础信息（Wwise 对象基本信息）外，还可选择加入 <code>bankData</code>（base64 编码的包内数据及编码后的大小），<code>infoFile</code>（在结果中添加 bankInfo，其中包括 SoundBank 内的详细信息如 Event 信息、路径、GUIID 等），<code>pluginInfo</code>（JSON 格式，工程所用到的插件相关信息） 三个选项。<strong>当选中这三个选项时，会在返回信息中增加更具体的信息，自带的 <code>soundbank</code> 中只有对象基础消息，是无法反映出 SoundBank 内具体的构成的。</strong><br><code>generationDone</code> 可订阅 SoundBank 生成结束时的 log 信息，不指定 Options 时，默认会返回 <code>logs</code> 中的 <code>severity</code>（生成完成后的错误程度，从无错误到最严重分别为 Message、Warning、Error、Fatal Error），<code>time</code>（日志时间戳），<code>message</code>（日志消息），<code>messageId</code>（日志消息 ID）</p><h2 id="switchContainer（订阅-Switch-Container-容器内的指派变化）"><a href="#switchContainer（订阅-Switch-Container-容器内的指派变化）" class="headerlink" title="switchContainer（订阅 Switch Container 容器内的指派变化）"></a>switchContainer（订阅 Switch Container 容器内的指派变化）</h2><h3 id="assignmentAdded-assignmentRemoved"><a href="#assignmentAdded-assignmentRemoved" class="headerlink" title="assignmentAdded, assignmentRemoved"></a>assignmentAdded, assignmentRemoved</h3><p><code>assignmentAdded</code> 和 <code>assignmentRemoved</code> 可以订阅 Switch Container 中指派的添加与移除，它们两者可选的 Options 与可发布的信息完全一致，在这里放在一起讨论。<br>在 Options 中如果不指定需返回的 Switch Container 和指派对象的基本信息时，这两个 API 默认都只会返回 <code>stateOrSwitch</code>（子对象指派到了 Switch 还是 State 中，并返回它的信息），<code>switchContainer</code>（容器本身的信息），<code>child</code>（被指派到容器内对象的有关信息）</p><h2 id="transport（订阅走带状态变化）"><a href="#transport（订阅走带状态变化）" class="headerlink" title="transport（订阅走带状态变化）"></a>transport（订阅走带状态变化）</h2><h3 id="stateChanged"><a href="#stateChanged" class="headerlink" title="stateChanged"></a>stateChanged</h3><p><code>stateChanged</code> 可订阅走带对象的状态变化，必须用 Options 提供 <code>transport</code>（走带对象的 GUID）。当状态改变，会发布 <code>transport</code>（正在订阅的走带对象的 GUID），<code>object</code>（被走带对象所控制对象的 GUID），<code>state</code>（走带播放状态）。</p><h2 id="audio（订阅音频导入状态）"><a href="#audio（订阅音频导入状态）" class="headerlink" title="audio（订阅音频导入状态）"></a>audio（订阅音频导入状态）</h2><h3 id="imported"><a href="#imported" class="headerlink" title="imported"></a>imported</h3><p><code>imported</code> 可订阅音频导入操作完成后的消息，可选的 Options 中可设定每个被导入对象所要返回的基本信息。</p><h2 id="log（订阅日志中对象的添加情况）"><a href="#log（订阅日志中对象的添加情况）" class="headerlink" title="log（订阅日志中对象的添加情况）"></a>log（订阅日志中对象的添加情况）</h2><h3 id="itemAdded"><a href="#itemAdded" class="headerlink" title="itemAdded"></a>itemAdded</h3><p><code>itemAdded</code> 可订阅日志中条目的增加，不需要指定 Options，在发布信息中可以返回 <code>channel</code>（可返回 Log 窗口中选项卡的名称），<code>item</code>（选项卡内具体新增的条目，如 time，severity 等）。</p><h2 id="wwise-debug-概览"><a href="#wwise-debug-概览" class="headerlink" title="wwise.debug 概览"></a>wwise.debug 概览</h2><p><img src="/images/%E8%AE%A2%E9%98%85wwise.debug.png" alt="订阅wwise.debug"></p><h2 id="assertFailed（订阅资源失败信息）"><a href="#assertFailed（订阅资源失败信息）" class="headerlink" title="assertFailed（订阅资源失败信息）"></a>assertFailed（订阅资源失败信息）</h2><p><code>assertFailed</code> 只在 Debug 版本下可用，会返回 <code>fileName</code>（原文件名），<code>lineNumber</code>（代码行数），<code>expression</code>（错误注释）。</p><h2 id="wwise-ui-概览"><a href="#wwise-ui-概览" class="headerlink" title="wwise.ui 概览"></a>wwise.ui 概览</h2><p><img src="/images/%E8%AE%A2%E9%98%85wwise%20ui.png" alt="订阅wwise ui"></p><h2 id="commands-executed-selectionChanged（订阅命令执行状态与选择改变）"><a href="#commands-executed-selectionChanged（订阅命令执行状态与选择改变）" class="headerlink" title="commands.executed, selectionChanged（订阅命令执行状态与选择改变）"></a>commands.executed, selectionChanged（订阅命令执行状态与选择改变）</h2><p><code>commands.executed</code> 可订阅有命令被执行，可选的 Options 中除了设定对象的基本信息外，还可设定 platform（平台）和 language（语言）。默认情况下会返回 platform（平台），objects（被执行对象的基本信息），command（被执行命令的 ID）。<strong>这条 API 不只响应通过 <code>ak.wwise.ui.commands.execute</code> 所执行的命令，用户正常执行的操作也会有响应，因此可用作查看当前命令是否在 Wwise Authoring Command Identifiers 受支持的验证工具。</strong><br><code>selectionChanged</code> 可工程中选中对象的变化，只<strong>对 Project Explorer 和 Event Viewer 这种含有条目的有效</strong>，对调整选项无效。可选的 Options 中同样可以指定 <code>platform</code>（平台）和 <code>language</code>（语言），返回值只会返回 <code>object</code>（被选中对象的基本信息）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们曾提到对订阅 Topics 类 API 而言，<strong>所有的调用都是需要回调函数来指定返回值的</strong>。之所以这样设计，是因为订阅执行后程序会阻塞并等待返回值，并不像执行类 API 单独一次远程调用结束就了事。<br>因此我们需要一个回调函数，指明当订阅的信息发生时用谁来接受产生的信息，以便于当信息发生时执行此函数。关于 Topics 类的回调函数传参办法，请参考第一篇中的示例代码（<a href="https://blog.audiokinetic.com/everyone-can-use-waapi-overview/）。" target="_blank" rel="noopener">https://blog.audiokinetic.com/everyone-can-use-waapi-overview/）。</a></p><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 音频编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/11/04/hello-world/"/>
      <url>/2018/11/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Testing </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
