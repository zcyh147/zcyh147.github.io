<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>人人都能用 WAAPI（一）概述</title>
      <link href="/2020/09/01/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/09/01/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>去年下半年我接触到了 WAAPI（Wwise Authoring API），作为头脑不怎么灵光的非专业程序员，看到 WAMP、JSON 等陌生概念直犯晕。毕竟除了官方文档，只有少数的分享视频、文章和项目可参考。因为不太好意思麻烦别人，只好自己在这一年中断断续续的闷头尝试，踩了不少坑。<br>引用 Linus 的一句名言：</p><blockquote><p>In open source, we feel strongly that to really do something well, you have to get a lot of people involved.  — Linus Torvalds</p></blockquote><p><strong>思想只有被传播才能体现价值</strong>，为了体现开源精神，决定分享一系列 WAAPI 指南给大家。《人人都能用 WAAPI》系列文则更贴近对官方文档的补充，会更加友好且详细。<br>对初学者友好不代表从零讲起，人人都能用 WAAPI 只是代表大家都有潜力去掌握这门优秀的技能。老规矩，谈一下前置知识。<strong>因为个人习惯使用 Python，所以前置知识只讨论 Python。你也可以使用支持的其他语言来进行 API 调用（使用 C# 调用 WAAPI 其实也很简单）。</strong></p><blockquote><p>本系列文章阅读需要的前置知识：</p><ul><li>会配置开发环境，掌握 Python、Anaconda、pip、VS Code、PyCharm 等的安装使用。</li><li>掌握简单的 Python 语法。</li><li>对 Wwise 功能有较全面的认知，WAAPI 涉及的功能比较广。</li><li>对现有 Wwise 工作流有优化的构思。</li><li>对思维导图有些许认知。</li></ul></blockquote><h2 id="为什么要用-WAAPI？"><a href="#为什么要用-WAAPI？" class="headerlink" title="为什么要用 WAAPI？"></a>为什么要用 WAAPI？</h2><h3 id="1-1-请问你在用-Wwise-时怀疑过以下人生吗？"><a href="#1-1-请问你在用-Wwise-时怀疑过以下人生吗？" class="headerlink" title="1.1. 请问你在用 Wwise 时怀疑过以下人生吗？"></a>1.1. 请问你在用 Wwise 时怀疑过以下人生吗？</h3><ul><li>能不能少一些点击和拖拽操作？？</li><li>成百上千（3A 项目上万也正常）的资源导入后做播放规则想死怎么办？？</li><li>使用 Game Sync、Event、SoundBank 时能不能智能连接逻辑？？</li><li>不能把 DAW 和 Wwise 联动吗？？</li><li>如何联动 CI 系统优化持续集成管线？？</li><li>etc.</li></ul><h3 id="1-2-WAAPI-的目的：解放繁琐的工作流"><a href="#1-2-WAAPI-的目的：解放繁琐的工作流" class="headerlink" title="1.2. WAAPI 的目的：解放繁琐的工作流"></a>1.2. WAAPI 的目的：解放繁琐的工作流</h3><p>如果你有上面的烦恼，WAAPI 对你无疑是必备利器。<br>作为 Wwise 2017.1 中的重要的功能补充，WAAPI 诞生就被赋予了解决一切繁琐的使命。<br>从简单操作中的获取工程信息、导入音频文件、设定容器层级，到声音引擎级的发送事件、设定 Game Sync 等操作，WAAPI 均可完成。是 Wwise 音频设计师工作流改进中的必备一环，<strong>利用好 WAAPI，能够节省大量时间，让声音设计师有更多精力放在艺术本身。</strong><br>在本文发布的当下，可能仍有公司未对技术音频（Game Audio Programmer / Technical Sound Designer）这个职位进行配备。如果碰巧你是这些公司的雇员，本文会对你很有帮助。<strong>对工作中重复和可优化的步骤进行不断优化，这才是智者的工作模式。与其等待戈多，不如自己动手。</strong></p><h3 id="1-3-官方的资料不够全吗？"><a href="#1-3-官方的资料不够全吗？" class="headerlink" title="1.3. 官方的资料不够全吗？"></a>1.3. 官方的资料不够全吗？</h3><p>Wwise 的官方文档是目前所有音频中间件中内容最完善，且本地化做的最好的一个。但文档中关于 WAAPI 的内容，对阅读对象的要求<strong>更偏向是有一定技术背景的人</strong>，存在些许门槛也是必然的。这系列文章的写作目的正是针对这一点，希望能对官网文档做出有用的补充，<br>官方博客中也有关于 WAAPI 好文，学有余力的朋友可以抽空翻阅。</p><h2 id="妙用思维导图整理-WAAPI"><a href="#妙用思维导图整理-WAAPI" class="headerlink" title="妙用思维导图整理 WAAPI"></a>妙用思维导图整理 WAAPI</h2><h3 id="2-1-通过导图理清-WAAPI-脉络"><a href="#2-1-通过导图理清-WAAPI-脉络" class="headerlink" title="2.1 通过导图理清 WAAPI 脉络"></a>2.1 通过导图理清 WAAPI 脉络</h3><p>思维导图作为一个重要的学习工具，在长达七八年中曾承载过我无数的发散思维。<br>如下图所示，<strong> WAAPI 这种点语法套大饼形式的 API（例如重要的查询 API 为 ak.wwise.core.object.get）在文档中检索时非常不便。</strong><br><img src="/images/%E7%B9%81%E7%90%90%E7%9A%84API.png" alt="繁琐的API"></p><p>那么有什么办法能够优雅的解决这个需求呢?<br>Bingo！思维导图一下出现在我脑中。<br>我通过对 WAAPI 进行逻辑归纳并整理为导图，以 ak.wwise.core.object.get 为例：</p><ol><li>忽略 ak（复用时可把 ak 视为等同为导图中心），分别把其拆为 wwise.core - object - get 形式的节点。</li><li>在此基础上，将 API 按功能重新排布顺序，并使用外框整理同类型的功能。</li></ol><p><img src="/images/%E5%AF%BC%E5%9B%BE1.png" alt="导图1"><br>导图概览</p><p><img src="/images/%E5%AF%BC%E5%9B%BE2.png" alt="导图2"><br>局部样例</p><h3 id="2-2-导入知识库进行知识完备"><a href="#2-2-导入知识库进行知识完备" class="headerlink" title="2.2. 导入知识库进行知识完备"></a>2.2. 导入知识库进行知识完备</h3><p>在此基础上就已完成 WAAPI 逻辑体系的初级构建，随后导入 MarginNote 3，在我的 Wwise 知识库中进行相关完善。<br><img src="/images/%E5%AF%BC%E5%9B%BE3.png" alt="导图3"><br>MN3 中的知识完备版</p><p>至此，WAAPI 的整体脉络清晰的出现在我眼前。对于 API 这种工具性极强的存在，用合理逻辑建立的“武器库”是高效利用的前提。这也是更最符合我自己理解记忆的方法，大家亦可根据自己的思维习惯选择适合自己的整理方法。<br><strong>导图我不会直接分享，</strong>原因很简单：看我的描述相信大家都能做出一样的导图，而知识库版本导图，这系列文章正是基于它的展开（会比导图详细的多），分享并没有什么意义。<br>相信有心的同学也会根据自己的想法重做一次，用什么思路无所谓。幕布和 XMind 这种导图工具或者笔记类软件均可，<strong>重点是亲自上手实现自己的版本，否则毫无意义。</strong></p><h2 id="系列文章架构"><a href="#系列文章架构" class="headerlink" title="系列文章架构"></a>系列文章架构</h2><p>了解我的 WAAPI 分类方法后，我们聊聊这系列文章的编写架构。<br>因 WAAPI 功能分为 Functions（执行）与 Topics（订阅）两种，两者的区别会在下面的章节中讲解。我会以这两者为主干，对下属分支进行拆分编写（注：我仍然省略了开头的“ak.“） 。<br>按照字数来划分，预计架构如下：</p><ol><li>概述</li><li>wwise.core（2-4为 Functions 类）</li><li>wwise.ui, wwise.debug, wwise.waapi</li><li>soundengine</li><li>wwise.core, wwise.debug, wwise.ui（Topics 类）</li><li>完整实例</li></ol><h2 id="WAAPI-基础"><a href="#WAAPI-基础" class="headerlink" title="WAAPI 基础"></a>WAAPI 基础</h2><h3 id="4-1-什么是-WAAPI？"><a href="#4-1-什么是-WAAPI？" class="headerlink" title="4.1. 什么是 WAAPI？"></a>4.1. 什么是 WAAPI？</h3><p>WAAPI（Wwise Authoring API）作为 Wwise 的重要组件，通过调用 API 即可让 Wwise 直接执行大量操作，而不必通过传统方式操作鼠标键盘达成同样目的。<br>它的可控制范围很广，从 Wwise 的界面层级控制（视图、选项、命令）到核心功能控制（例如快速添加音频文件），到声音引擎层级的功能（RTPC Value、Post Event 等）均可完成。<br>文档中关于 WAAPI 的简介：<br><a href="https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi.html" target="_blank" rel="noopener">https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi.html</a></p><h3 id="4-2-WAAPI-支持的语言类型和使用方式"><a href="#4-2-WAAPI-支持的语言类型和使用方式" class="headerlink" title="4.2. WAAPI 支持的语言类型和使用方式"></a>4.2. WAAPI 支持的语言类型和使用方式</h3><h4 id="可用的编程语言"><a href="#可用的编程语言" class="headerlink" title="可用的编程语言"></a>可用的编程语言</h4><p>WAAPI 可通过 C++、C#、JavaScript、Python 等多种语言调用，对于初学者来说后三者都比较简单（其中 Python 需 3.6+，2比较麻烦）。如果没有在插件中调用 WAAPI 的需求，可不考虑使用 C++。</p><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>WAAPI 提供三种调用方式：WAMP、HTTP POST、Wwise 插件中调用。<br>通常情况下我们只会使用 WAMP，因为只有这种方式才能支持执行和订阅两种类型的使用方法。<br>那么什么是 WAMP 呢？<br>这是一种通过 WebSocket 进行通信的方式。如果对网络通信原理没有了解的话，可以把它简单理解成是通过网络传输信息的方法，它需要 IP 地址和端口来满足通讯需求，所以 WAAPI 的使用过程中需要提供这两个参数。<br>当我们的程序通过 WAMP 和 Wwise 建立连接后，才能执行之后所需的操作。<br>官方文档中关于调用方式的介绍：<br><a href="https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi_gettingstarted.html" target="_blank" rel="noopener">https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi_gettingstarted.html</a></p><h3 id="4-3-配置开发环境"><a href="#4-3-配置开发环境" class="headerlink" title="4.3. 配置开发环境"></a>4.3. 配置开发环境</h3><blockquote><p>出于个人的写作习惯，开发环境这种重复造轮子的事情我不会再写一次。但会分享给大家较好的教程连接，请大家根据文内介绍的方法进行开发环境配置，顺便感谢文中作者的无私分享！</p></blockquote><p><strong>因为 Conda 中并没有 WAAPI 所需的 waapi-client 包，所以初学者懒得折腾 Anaconda 的话，建议直接用 pip 安装 waapi-client。</strong><br>如果跟我一样使用 Anaconda 管理开发环境，<strong>我推荐使用官方文档中的方法安装 Conda 中没收录的包。即先在环境中安装 pip ，再通过 Conda 里的 pip 管理 Conda 中没有的包。</strong>此部分文档我在下方有附上链接。<br>（初学者请不要看这句话）至于 <code>conda skeleton pypi package</code> 再 <code>conda build package</code> 这种 Conda 装 pypi 的方法我没试过，就不在这里讨论了。</p><h4 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h4><p><a href="https://segmentfault.com/a/1190000022797661" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022797661</a></p><h4 id="配置-Anaconda-并在本地环境中通过-pip-添加-waapi-client"><a href="#配置-Anaconda-并在本地环境中通过-pip-添加-waapi-client" class="headerlink" title="配置 Anaconda 并在本地环境中通过 pip 添加 waapi-client"></a>配置 Anaconda 并在本地环境中通过 pip 添加 waapi-client</h4><p><a href="https://zhuanlan.zhihu.com/p/25198543" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25198543</a><br><a href="https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-pkgs.html#installing-non-conda-packages" target="_blank" rel="noopener">https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-pkgs.html#installing-non-conda-packages</a><br><strong>注意：使用 pip 的同学可直接在 Python 3 环境下执行 <code>pip install waapi-client</code></strong></p><h4 id="配置-VS-Code-开发环境"><a href="#配置-VS-Code-开发环境" class="headerlink" title="配置 VS Code 开发环境"></a>配置 VS Code 开发环境</h4><p><a href="https://zhuanlan.zhihu.com/p/30324113" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30324113</a></p><h4 id="在-Wwise-中开启-WAAPI-支持"><a href="#在-Wwise-中开启-WAAPI-支持" class="headerlink" title="在 Wwise 中开启 WAAPI 支持"></a>在 Wwise 中开启 WAAPI 支持</h4><p><a href="https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi_prepare.html" target="_blank" rel="noopener">https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi_prepare.html</a></p><h3 id="4-4-Functions（执行类）与-Topics（订阅类）的区别"><a href="#4-4-Functions（执行类）与-Topics（订阅类）的区别" class="headerlink" title="4.4. Functions（执行类）与 Topics（订阅类）的区别"></a>4.4. Functions（执行类）与 Topics（订阅类）的区别</h3><blockquote><p>这里“执行类”和“订阅类”属于个人的称呼习惯，“执行类”代表功能为执行某些操作的 API，“订阅类”为执行后等待某些结果返回的 API。在 Wwise 官方文档中的对应术语为“远程调用”和“发布&amp;订阅”。</p></blockquote><p>Functions（执行类）：<br>与名字相同，其中所有的 API 均为执行具体的操作。<br>通过代码调用某个 API 后，会执行一次对应的操作。WAAPI 的三种使用方式中都可完成对“执行类”接口的调用，但 HTTP POST 方式下不具有最佳性能。<br>Topics（订阅类）：<br>当调用“订阅类”接口后，程序会等待 Wwise 中对应的动作发生。如果订阅了一个对象创建的动作，那只有动作被执行后才会收到发回的信息。这种调用方法只有 WAMP 能够做到，其余两种使用方法无法完成。</p><h3 id="4-5-来一杯-Hello-Wwise！"><a href="#4-5-来一杯-Hello-Wwise！" class="headerlink" title="4.5. 来一杯 Hello Wwise！"></a>4.5. 来一杯 Hello Wwise！</h3><p>说了这么多理论，现在“麻烦给我的爱人来一杯 Hello Wwise 吧！”</p><h4 id="确定使用哪个-API"><a href="#确定使用哪个-API" class="headerlink" title="确定使用哪个 API"></a>确定使用哪个 API</h4><p>很明显，对于 Hello World 这种需求应该使用 Functions（执行类）完成。<br>通过寻找，我们发现一条美妙的 <code>ak.soundengine.postMsgMonitor</code> 可以完成需求。</p><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><p>为了方便理解，我直接在代码里写上详细的注释，请大家对照每行的代码来阅读。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 的异常处理 try…except… 语句，为 WAAPI 连接不上的情况增加了错误输出。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 通过默认的地址连接 Wwise，如果想连接本地不同的 Wwise 可在这里修改对应的端口</span></span><br><span class="line">    <span class="keyword">with</span> WaapiClient() <span class="keyword">as</span> client:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># WAAPI 传入和传回的参数都使用 JSON 格式，我们使用字典定义一段要打印出的信息为 "Hello Wwise!"</span></span><br><span class="line">        print_args = &#123;</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"Hello Wwise!"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 远程调用 ak.soundengine.postMsgMonitor，并传入刚才设定好的参数</span></span><br><span class="line">        client.call(<span class="string">"ak.soundengine.postMsgMonitor"</span>, print_args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">    print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br></pre></td></tr></table></figure></p><h4 id="执行效果"><a href="#执行效果" class="headerlink" title="执行效果"></a>执行效果</h4><p>运行脚本之前记住点击 Start Capture，从而让 Profiler 开始采集信息。当脚本运行后，我们可获得以下信息：<br><img src="/images/%E7%BB%93%E6%9E%9C1.png" alt="结果1"><br>在 Logs 的 WAAPI 选项卡中，可看到产生了 WAMP 类型连接。</p><p><img src="/images/%E7%BB%93%E6%9E%9C2.png" alt="结果2"><br>在 Profiler 中可看到打印出的信息 “Hello Wwise!”</p><h2 id="WAAPI-两种应用（注释写到每一行）"><a href="#WAAPI-两种应用（注释写到每一行）" class="headerlink" title="WAAPI 两种应用（注释写到每一行）"></a>WAAPI 两种应用（注释写到每一行）</h2><h3 id="5-1-Functions（执行类）示例"><a href="#5-1-Functions（执行类）示例" class="headerlink" title="5.1. Functions（执行类）示例"></a>5.1. Functions（执行类）示例</h3><h4 id="不带参数"><a href="#不带参数" class="headerlink" title="不带参数"></a>不带参数</h4><p>通过 getInfo 功能获得当前工程的信息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 略</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 通过默认的地址连接 Wwise</span></span><br><span class="line">    <span class="keyword">with</span> WaapiClient() <span class="keyword">as</span> client:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 调用 ak.wwise.core.getInfo 来获取 Wwise 的全局信息并存到 result 中</span></span><br><span class="line">        result = client.call(<span class="string">"ak.wwise.core.getInfo"</span>)</span><br><span class="line">        <span class="comment"># 为了避免 print 单行打印，需通过 pprint 来打印刚得到 JSON 结果</span></span><br><span class="line">        pprint(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">    print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br></pre></td></tr></table></figure></p><p>代码执行后结果如下，如所希望的返回了工程信息<br><img src="/images/%E7%BB%93%E6%9E%9C3-1.png" alt="结果3"></p><h4 id="带参数"><a href="#带参数" class="headerlink" title="带参数"></a>带参数</h4><p>请参考“来一杯 Hello Wwise！”的例子</p><h3 id="5-2-Topics（订阅类）"><a href="#5-2-Topics（订阅类）" class="headerlink" title="5.2. Topics（订阅类）"></a>5.2. Topics（订阅类）</h3><p>通过 ak.wwise.core.object.nameChanged 功能订阅工程中对象名称被修改时的信息，当有对象被修改时返回新、旧名字及设定的返回值类型（本例中为 type）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 的异常处理 try…except…else… 语句</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    client = WaapiClient()</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">    print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 建立 on_name_changed() 准备在订阅中作为回调函数，用来接收字典形式的返回参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_name_changed</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 获取对象类型</span></span><br><span class="line">        obj_type = kwargs.get(<span class="string">"object"</span>, &#123;&#125;).get(<span class="string">"type"</span>)</span><br><span class="line">        <span class="comment"># 获取之前的名字</span></span><br><span class="line">        old_name = kwargs.get(<span class="string">"oldName"</span>)</span><br><span class="line">        <span class="comment"># 获取新名字</span></span><br><span class="line">        new_name = kwargs.get(<span class="string">"newName"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打印信息，告知用户XXX类型的对象从 A 改名到了 B</span></span><br><span class="line">        print(<span class="string">"Object '&#123;&#125;' (of type '&#123;&#125;') was renamed to '&#123;&#125;'\n"</span>.format(old_name, obj_type, new_name))</span><br><span class="line">        <span class="comment"># 检测完成后断开 WAMP 连接，当然，要是想一直监控信息也可以不断开</span></span><br><span class="line">        client.disconnect()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 订阅所需主题，传入回调函数，使用选项 type 以让名称修改时传回被修改的对象类型</span></span><br><span class="line">    handler = client.subscribe(<span class="string">"ak.wwise.core.object.nameChanged"</span>, on_name_changed, &#123;<span class="string">"return"</span>: [<span class="string">"type"</span>]&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印信息，提醒用户已经订阅了 ak.wwise.core.object.nameChanged 并建议用户执行重命名操作以验证脚本功能</span></span><br><span class="line">    print(<span class="string">"Subscribed 'ak.wwise.core.object.nameChanged', rename an object in Wwise"</span>)</span><br></pre></td></tr></table></figure></p><p>代码执行后结果如下，如所希望的告知了对象的名称变化及类型<br><img src="/images/%E7%BB%93%E6%9E%9C4.png" alt="结果4"></p><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2><p>在第二期中，会就执行类里比较重要的 wwise.core 分支进行分享。官网对于执行类的 API 大多提供了例子，但我可能会通过结合起来的小实例来进行演示，这样有便于大家更快掌握。如喜欢本文，请持续关注。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>人人都能用 WAAPI（二）wwise.core 分支</title>
      <link href="/2020/09/01/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/09/01/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>浅谈阅读路线，以及阅读和做笔记的方法</title>
      <link href="/2020/08/30/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B9%A6%E4%BB%A5%E5%8F%8A%E6%80%8E%E4%B9%88%E8%AF%BB/"/>
      <url>/2020/08/30/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B9%A6%E4%BB%A5%E5%8F%8A%E6%80%8E%E4%B9%88%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>今天分享一下之前所列书单的推荐阅读路线。虽然我认为这份书单，尤其是经过我重构后的第二版，本身就已经具有良好的可阅读及可选择性。但是后台收到了一些朋友的询问，想咨询下简单的学习路线推荐。<br>为此，写一篇小文聊聊这个问题，顺便简单谈谈读书之道。因为这种文章实在没什么技术含量，故在第二版书单推送时放在头条下方，以免有水文章之嫌。</p><blockquote><p>核心原则：</p><ul><li>对英文不好的同学来说，<strong>切记 i + 1 原则</strong>。不要一口吃个胖子上来就对着原版书和英文文档开啃，评估好自己的英文水平再决定材料选择。</li><li>母语学习永远快于外语学习，除非你英文做到 Native Speaker，不然<strong>请尽量优先选择材料的中文版本</strong>。学有余力后，再对照英文原版或英文新版查漏补缺。</li><li>所有的领域都有入门或导论类书籍，找一本好的看完，其余的同类书通过跳读，查漏补缺即可，<strong>对任何书都一个字不差的阅读是最低效的阅读</strong>。</li><li>学习有方法，读书有方法，记笔记也有方法。方法无好坏，捕鼠无坏猫，选择适合自己的才最重要。</li></ul></blockquote><h2 id="浅谈阅读路线的选择"><a href="#浅谈阅读路线的选择" class="headerlink" title="浅谈阅读路线的选择"></a>浅谈阅读路线的选择</h2><h3 id="1-1-游戏音频入门"><a href="#1-1-游戏音频入门" class="headerlink" title="1.1 游戏音频入门"></a>1.1 游戏音频入门</h3><h3 id="1-2-精进声音设计"><a href="#1-2-精进声音设计" class="headerlink" title="1.2 精进声音设计"></a>1.2 精进声音设计</h3><h3 id="1-3-技术音频入门"><a href="#1-3-技术音频入门" class="headerlink" title="1.3 技术音频入门"></a>1.3 技术音频入门</h3><h2 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h2><h2 id="如何做笔记"><a href="#如何做笔记" class="headerlink" title="如何做笔记"></a>如何做笔记</h2>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>写给声音设计师的敏捷 GUI 开发大法（二）进阶篇</title>
      <link href="/2020/08/30/PySimpleGUI%20%E7%AC%AC%E4%BA%8C%E7%AF%87/"/>
      <url>/2020/08/30/PySimpleGUI%20%E7%AC%AC%E4%BA%8C%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>在《写给声音设计师的敏捷 GUI 开发大法（一）》中，我们简单的讨论了 PySimpleGUI 作为一个快速且优雅的 GUI 开发库的优点和基础的代码规则，并且一起完成了一个实用的小程序。<br>在进阶篇中，就要深入讨论一些细节的内容了。比如第一篇文章中的布局代码到底是怎么产生作用的？和 Tkinter 等框架的区别具体是哪些？<br>这篇文会比较枯燥，我们会从原理上了解一些细节内容，其中用到很多术语，如果看到不太熟悉的词请翻阅文档或查询 Google。或许有些朋友已经去 PySimpleGUI 的官网“散文”文档中学习了一番，进阶篇的存在主要是为了照顾到没时间去看的朋友。<br>当然，如我之前所述，<strong>这系列文章也并非是文档“翻译官”</strong>。希望我写的东西作为引子，能让大家了解到这个简单且方便的框架。</p><p><em>本文目录：</em></p><ol><li>PySimpleGUI 原理</li><li>一些较为复杂的布局实现</li><li>使用 QT Designer 快速构建布局</li><li>如何阅读 PySimpleGUI 官方文档</li><li>一个完整的程序例子（与 WAAPI 联动）</li><li>接下来讲什么？</li></ol><h2 id="PySimpleGUI-原理"><a href="#PySimpleGUI-原理" class="headerlink" title="PySimpleGUI 原理"></a>PySimpleGUI 原理</h2><h2 id="一些较为复杂的布局实现"><a href="#一些较为复杂的布局实现" class="headerlink" title="一些较为复杂的布局实现"></a>一些较为复杂的布局实现</h2><h2 id="使用-QT-Designer-快速构建布局"><a href="#使用-QT-Designer-快速构建布局" class="headerlink" title="使用 QT Designer 快速构建布局"></a>使用 QT Designer 快速构建布局</h2><h2 id="如何阅读-PySimpleGUI-官方文档"><a href="#如何阅读-PySimpleGUI-官方文档" class="headerlink" title="如何阅读 PySimpleGUI 官方文档"></a>如何阅读 PySimpleGUI 官方文档</h2><h2 id="一个完整的程序例子（与-WAAPI-联动）"><a href="#一个完整的程序例子（与-WAAPI-联动）" class="headerlink" title="一个完整的程序例子（与 WAAPI 联动）"></a>一个完整的程序例子（与 WAAPI 联动）</h2><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>如何在20天内彻底搞定声音设计英文 Keyword？</title>
      <link href="/2020/08/28/%E4%B8%80%E7%AF%87%E6%96%87%E7%AA%81%E7%A0%B4%E9%9F%B3%E6%95%88%E5%8D%95%E8%AF%8D%E9%9A%9C%E7%A2%8D/"/>
      <url>/2020/08/28/%E4%B8%80%E7%AF%87%E6%96%87%E7%AA%81%E7%A0%B4%E9%9F%B3%E6%95%88%E5%8D%95%E8%AF%8D%E9%9A%9C%E7%A2%8D/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>游戏音频与声音设计书单一文发出后，有几个朋友专门找我探讨如何提升英文水平以阅读原版书或英文资料。这是一个值得讨论的话题，写一篇技术性“不那么重”的小文与大家分享一下我的心得。为了覆盖到更多朋友，故把标题定为《如何用20天搞定声音设计 Keyword》。<br>虽然标题如此，但还是会用一点篇幅谈谈英文学习的基础路线供诸君参考。在第二部分，会提供一种针对性的方法解决声音设计术语掌握不全这个难题。</p><p><em>本文目录：</em></p><ol><li>怎么学英文？<br> 1.1. 为什么要学英文？<br> 1.2. 英文学习的基本概念<br> 1.3. 学习路线推荐</li><li>20天搞定声音设计 Keyword<br> 2.1. 通过 AntConc 对商业音效库进行语料库提取<br> 2.2. 使用欧陆词典进行背诵<br> 2.3. 更重要的还是使用</li></ol><h2 id="怎么学英文？"><a href="#怎么学英文？" class="headerlink" title="怎么学英文？"></a>怎么学英文？</h2><p>这部分简单探讨了如何学好英文，直奔文章主题的朋友可直接翻到第二部分。</p><h3 id="1-1-为什么要学英文？"><a href="#1-1-为什么要学英文？" class="headerlink" title="1.1. 为什么要学英文？"></a>1.1. 为什么要学英文？</h3><p>不论是否在互联网行业，只要工作中需要与国外的技术进行接触，英文就是一个必不可缺的能力。<strong>对一个智慧的人来说，英文、快速学习、解决问题、复盘等都是要终身锻炼的能力</strong>。李笑来老师对于英文的重要性，以及元认知、心智等对概念在他的著作中都有所提及。大家有兴趣可以去读一下，可更深的体会到英文给人带来的影响。<br>传统音频行业就有着大型调音台进入国内无人会用，结果负责翻译说明书的人成为了业内好手的佳话。毕竟原汁原味的文档才是最准确的信息来源。别人嚼过后再输出的文章倒不一定是垃圾，但熵增后的知识一定不如直接读文档来的直接和准确。<br>英文不好的后果很多，遇到问题不敢用 Google 搜索，怕看不懂。开口讲点单词，全是错误的发音。恶性循环，职场生涯必然不顺。与其如此，倒不如将英文学习变成一种习惯。</p><h3 id="1-2-英文学习的基本概念"><a href="#1-2-英文学习的基本概念" class="headerlink" title="1.2. 英文学习的基本概念"></a>1.2. 英文学习的基本概念</h3><p>我跟晓光兄（微博：<em>恶魔奶爸</em>）认识七年，如果有早期知乎用的比较多的朋友，或许对这位传播英语学习方法论的“恶魔的奶爸”有所耳闻。他的一套英文学习方法论对大学后期的我产生了深刻的影响，也让我从一个“主谓宾”都不知是啥的渣渣，变成了还算“有点”英文能力的人。最起码能看懂些原版书，看英文说明书也毫无压力了。</p><blockquote><p>赖世雄老师说过：There’s no shortcut to good English, but we do have a right way.</p></blockquote><p>受晓光兄影响，我对 SLA（二语习得）有些许了解。其中 Stephen Krashen 博士有几条关于学习英语非常重要的假说：</p><ol><li>Input 假说：听力和阅读大量的输入才决定英文的水平，而不是漫无目的的跟老外瞎聊。</li><li>i + 1（可理解性输入假说）：学习新材料的时候，要比当前的水平 i 稍微高一点，即 i + 1，这样才是有效的可理解性输入。如果 i + 5或10，这种非可理解性的输入毫无意义。比如你单词量稀烂，看本 MIT 出版的书绝对头晕脑胀还学不到东西。</li><li>Narrow Input 假说：输入的材料要相对狭窄，不要什么领域都抓。既学音频行业术语，又刷 VOA 和经济学人，再背着本语法书，结果一事无成。</li><li>情绪机制：学习的材料一定是让人产生兴趣的，轻松自如的，这样才能激发学习热情。</li></ol><p>为了避免做战略上的矮子，需要认清英文学习的基本概念，在英语学习的路上有很大帮助。<br>但我想说，<strong>不少国人都有速成的神功大力丸思想，想要背点单词就突破阅读，口语角混半年就搞定口语，这种是绝对不可取的。</strong>虽然我用《如何用20天搞定声音设计 Keyword》作为标题，但还是希望大家明白英语学习是要长期投入的一件事。<br>有些人可能觉得来不及了，大学时算来不及吗？工作两年算来不及吗？种一棵树最好的时间是十年前，其次是现在。希望有心突破语言障碍的朋友坚持下去，经过此场全球大劫，活下来的人应该更认识到生命的潜力，而不是自暴自弃。</p><h3 id="1-3-学习路线推荐"><a href="#1-3-学习路线推荐" class="headerlink" title="1.3. 学习路线推荐"></a>1.3. 学习路线推荐</h3><p>晓光兄之前有视频录制的英语学习方法论课、发音课等，但我翻了一下发现现在全都不卖了，英语公众号更是荒废状态。周一问了一下，果然他现在已经不做这块，只在微博专做职场相关内容。<br><img src="/images/%E5%A5%B6%E7%88%B8.png" alt="奶爸"></p><p>如上所述，推荐有心系统学习英文的同学阅读晓光兄的著作《把你的英语用起来》，其中伍君仪老师关于透析法的部分可以不看。本书可能只有淘宝有货，大家也可选择去各大平台购买电子版。<br>书中方法论简单总结的话就是，音标和正确的发音是必须学的，其次是赖世雄或 ESLPod 这类播讲材料，以及后期辅佐阅读或美剧输入等。具体的部分大家可参照书中的介绍进行学习，如有精力查找奶爸微信公众号历史文章的朋友也可翻翻他后期的新文章，核心的学习路线区别不大。<br>至于书籍推荐，针对音频类英语的学习书籍国内只有《录音专业英语》一本，而《音乐英语》等书籍更偏向于音专所需的词汇。这部分只好靠大家自己积累了，对音频类书籍测词频意义也不是很大。</p><h2 id="20天搞定声音设计-Keyword"><a href="#20天搞定声音设计-Keyword" class="headerlink" title="20天搞定声音设计 Keyword"></a>20天搞定声音设计 Keyword</h2><p>不管是用商业音效库或 Freesound 这类音效网站找资源，亦或去 YouTube 找想要的声音实现过程。新手都容易遇到一个问题，不知道该用什么词去搜。<br>对于这个针对性极强的需求，我提供给大家一个训练方法。</p><h3 id="2-1-通过-AntConc-对商业音效库进行语料库提取"><a href="#2-1-通过-AntConc-对商业音效库进行语料库提取" class="headerlink" title="2.1. 通过 AntConc 对商业音效库进行语料库提取"></a>2.1. 通过 AntConc 对商业音效库进行语料库提取</h3><p>在语言学、英语教学等领域经常会通过语料库来进行专项研究。作为一种针对性极强的存在，语料库往往对某个领域的词汇研究有更精准的帮助，这里要感谢早稻田大学 Laurence Anthony 博士的作品 AntConc。<br>我使用 AntConc 把比较好找的常见的商业音效库的 PDF 元数据文档中的近40万个单词全部进行了处理<strong>（我的元数据文档不太全，如果哪位有收集完整的可以后台私信我，我处理之后把更具体的语料库分享给大家）</strong>。对得到的语料库文件根据词频（即在这份样本中单词出现的次数）进行排布，得到了一份近4000词的音效库词汇表。鉴于这个词汇量实在不算大，就不使用 BNC 进行反向剔除了，不然有可能把一些基础但重要的关键词刷掉。<br><img src="/images/%E9%9F%B3%E9%A2%91%E5%BA%93.png" alt="音频库"></p><p>其中词频1000次以上有68个，100次以上有446个，10次以上有1608个。<br>基于词频的分布，我把生成的词汇表做成完整、词频100+和词频10+三种，分别对应单词量为全部3915词、446词、1608词。<br><img src="/images/%E8%AF%8D%E9%A2%91%E8%A1%A8%E6%96%87%E4%BB%B6.png" alt="词频表文件"></p><p>大家可根据需求进行选用，如希望快速改善单词量，建议使用词频10+的版本（1608词）。词频在10次以下的虽然也有一些可用之处，但比较冷僻，若学有余力可考虑过一遍完整版长长见识。</p><p>下载地址：<br>链接：<a href="https://share.weiyun.com/zCSaXDtP" target="_blank" rel="noopener">https://share.weiyun.com/zCSaXDtP</a> 密码：pea4y5</p><h3 id="2-2-使用欧陆词典进行背诵"><a href="#2-2-使用欧陆词典进行背诵" class="headerlink" title="2.2. 使用欧陆词典进行背诵"></a>2.2. 使用欧陆词典进行背诵</h3><p>欧陆词典可以导入我整理好的词频文件进行背诵，建议大家付费，这样单词背诵记录等可云端同步。在背诵过程中，亦可添加到新的生词本，以方便添加笔记和二次整理。<br>首先打开欧陆笔记网页版（<a href="http://my.eudic.net/），登录自己的账户。" target="_blank" rel="noopener">http://my.eudic.net/），登录自己的账户。</a><br>在左边点击“导入其他软件的生词”<br><img src="/images/%E6%AC%A7%E9%99%861.png" alt="欧陆1"></p><p>使用默认的“导入其他软件生词本”，点击上传，选择所需的语料库文件。并选择合适的生词本，这里我新建了一个新的生词本。<br><img src="/images/%E6%AC%A7%E9%99%862.png" alt="欧陆2"></p><p>随后点击左侧“我的生词本”，即可看到新导入的生词本。<br><img src="/images/%E6%AC%A7%E9%99%863.png" alt="欧陆3"></p><p>在手机端同步完成后，即可看到“生词笔记”中出现了刚创建的生词本。切换到“学习”选项卡，找到刚创建的生词本，选择计划的天数即可开始学习。<br><strong>此处扣题，若选择每天背150个单词（包括新词与复习），大约正好20天左右刷一遍。</strong>因为其中有一些大家熟悉的词汇，所以每天的任务实际要比150个单词轻松，1小时左右差不多能完成。<br>欧陆词典具体的使用我就不赘述了，背单词的回忆方式多种多样。与扇贝、百词斩等无太大差异，支持多种背诵和回忆模式，请自行研究。<br><img src="/images/%E6%AC%A7%E9%99%864.jpeg" alt="欧陆4"></p><p>因为没做 BNC 剔除高频词，所以可能会有少数极简单的单词出现，在学习过程中划掉即可。<br>但请注意，<strong>快速记忆单词课本不是最终目的，这个过程主要是快速熟悉的声音设计术语。</strong>有心的同学可以在生词本中增加笔记，或使用笔记软件和思维导图等进行符合自己思维习惯的整理。</p><h3 id="2-3-最重要的还是多用"><a href="#2-3-最重要的还是多用" class="headerlink" title="2.3. 最重要的还是多用"></a>2.3. 最重要的还是多用</h3><p>背完单词表就万事大吉了吗？<br>不，一定要多用。无论是工作中还是搜索相关信息时，都要主动的联想并使用起曾经背过的单词。短期背诵带给你的是对声音设计相关术语的熟悉，让你容易出现描述失能。反复使用让其变成头脑的“肌肉记忆”才是目的。<br><strong>背单词这件事是英文学习中最不值得鼓励的一种方法，但对于词汇量极度匮乏或急需快速掌握某一领域词汇的人来说也算勉强还可以。</strong>希望大家明白什么是英语学习的正道，一时急于求成勉强可以，一直抄近路只会自讨苦吃。<br>愿本文对诸君在英语及声音设计术语的学习上有所帮助。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>写给声音设计师的敏捷 GUI 开发大法（一）</title>
      <link href="/2020/08/27/PySimpleGUI%20%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>/2020/08/27/PySimpleGUI%20%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>当作为声音设计师或技术音频的你完成了 Python 脚本时，除了感叹这门语言的便利性和丰富的第三方库，可能也会思考，<strong>为什么现有的 Python GUI 库都这么麻烦？</strong>毕竟要为团队中非程序背景的同事开发工具，看得见的界面无疑比命令行的用户体验更加友好。<br><strong>这一系列分享的目的，就是为了打通脚本和 GUI 程序之间的障碍，把开发图形界面这个浪费时间的过程彻底简单化，让技术音频工作中的小工具开发变的门槛更低一些。</strong>其实使用 Tkinter、PyQt、wxPython 等来开发 GUI 也没什么难度，参考实例几分钟就能上手，一下午就能熟悉。但它们使用起来语法繁琐，不太直观，非常浪费时间。<br>作为生产力解放狂魔，我认为<strong>应该把宝贵的精力应该放在更重要的事上，而不是费劲吧啦的在控件和语法间挣扎。</strong>这也是我个人的<strong>学习理念，其一为多向自己提问并解答之，其二是遇到重复、繁琐、有潜力被自动化的东西就喜欢思考去优化。</strong><br>希望此文能给大家提供一套高效的工作流，人人都能轻松定制自己想要的工具。</p><blockquote><p>本系列文章阅读需要的前置知识：</p><ul><li>会配置开发环境，掌握 Python、Anaconda、VS Code、PyCharm 的安装配置。</li><li>掌握简单的 Python 语法和 WAAPI 知识。作为一门写工具时要求技术水平不是很高的脚本语言，没接触过的同学可以敲几天《Python编程：从入门到实践》，或看看廖雪峰老师的课程。对于 WAAPI，照着例子调用几个 API 即可轻松上手。</li><li>掌握 GUI 基础概念。了解窗体、面板、构件等即可，有志向深入研究的朋友可翻翻 UI、UX 相关书籍。</li></ul></blockquote><p><em>文章目录：</em></p><ol><li>基本概念与示例</li><li>配置开发环境与 PySimpleGUI</li><li>一个完整的程序例子</li><li>接下来讲什么？</li></ol><h2 id="基本概念与示例"><a href="#基本概念与示例" class="headerlink" title="基本概念与示例"></a>基本概念与示例</h2><p>对于 GUI 而言，只需了解它是一个具有图形界面的应用程序外壳即可。至于事件循环、布局构建、回调函数等概念，大可先把它们当成黑箱。只管使用，不必探究深层原理。</p><h3 id="1-1-UI-和程序之间需要“钩上”才能产生互动"><a href="#1-1-UI-和程序之间需要“钩上”才能产生互动" class="headerlink" title="1.1. UI 和程序之间需要“钩上”才能产生互动"></a>1.1. UI 和程序之间需要“钩上”才能产生互动</h3><p>图形界面之所以能够让程序发挥功能，是因为其组件被用户触发后，与程序的功能代码产生了互动。<br>例如可以用一个按钮点击代表一个函数的执行，用一个弹出式窗口显示 Print() 函数的打印信息，每一个行为与背后的代码关联在一起。我们实际要做的就是设计好壳子，再用钩子把它们连接起来。</p><h3 id="1-2-举个最简单的例子（另类的-Hello-World）"><a href="#1-2-举个最简单的例子（另类的-Hello-World）" class="headerlink" title="1.2. 举个最简单的例子（另类的 Hello World）"></a>1.2. 举个最简单的例子（另类的 Hello World）</h3><p>现在讨论一个最简单的程序。用户输入内容，点击按钮后，程序会把用户输入值通过窗口打印出来。<br>我们为它设计一个 GUI 原型：<br><img src="/images/UI%20%E5%8E%9F%E5%9E%8B%E4%B8%80.png" alt="UI 原型一"><br>上图上部分是程序打开时的界面，当用户输入完内容点击 Print 后，下部分会出现弹出式窗口告知用户刚输入的值。</p><h4 id="这个例子说明了什么？"><a href="#这个例子说明了什么？" class="headerlink" title="这个例子说明了什么？"></a>这个例子说明了什么？</h4><p>看三个重要的功能组件：</p><ul><li>Input 文本框：用于暂存用户输入的数据</li><li>Print 按钮：用于把 Input 文本框中的数据传进程序内（把用户输入的值存到变量中）</li><li>Input is XXXXXXXXX：通过弹出式窗口输出用户输入值</li></ul><h4 id="通过这个例子类比到工具的真实需求上"><a href="#通过这个例子类比到工具的真实需求上" class="headerlink" title="通过这个例子类比到工具的真实需求上"></a>通过这个例子类比到工具的真实需求上</h4><p>图形界面下 Input() 和 Print() 等函数组成的程序就会是我们的功能脚本，而图形界面上的控件就是本文的讨论方向，我们要用一种高效优雅的方法将两者连接。</p><h3 id="1-3-代码实现："><a href="#1-3-代码实现：" class="headerlink" title="1.3. 代码实现："></a>1.3. 代码实现：</h3><p>下面我写两段简单的代码，分别把这个程序用 Tkinter 和 PySimpleGUI 实现，并附上效果截图。</p><h4 id="使用-Tkinter"><a href="#使用-Tkinter" class="headerlink" title="使用 Tkinter"></a>使用 Tkinter</h4><p><img src="/images/Tkinter.png" alt="Tkinter"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> messagebox</span><br><span class="line"></span><br><span class="line">window = Tk() </span><br><span class="line">window.title(<span class="string">'小刘鸭之窗'</span>) </span><br><span class="line">window.geometry(<span class="string">'200x60'</span>) </span><br><span class="line"></span><br><span class="line">user_input = StringVar()</span><br><span class="line">user = Entry(window, textvariable=user_input)</span><br><span class="line">user_input.set(<span class="string">' '</span>)</span><br><span class="line">user.pack()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">click</span><span class="params">()</span>:</span></span><br><span class="line">    duckyo = user_input.get()</span><br><span class="line">    string = str(<span class="string">'Imput is%s'</span> %(duckyo))</span><br><span class="line">    print(<span class="string">'Imput is%s'</span> %(duckyo))</span><br><span class="line">    messagebox.showinfo(title=<span class="string">'鼻孔猫输出'</span>, message=string)</span><br><span class="line"></span><br><span class="line">Button(window, text=<span class="string">'Print'</span>, command=click).pack()</span><br><span class="line"></span><br><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure><h4 id="使用-PySimpleGUI"><a href="#使用-PySimpleGUI" class="headerlink" title="使用 PySimpleGUI"></a>使用 PySimpleGUI</h4><p><img src="/images/PySimpleGUI.png" alt="PySimpleGUI"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line">sg.theme(<span class="string">'Light Brown 11'</span>)   </span><br><span class="line"></span><br><span class="line">layout = [[sg.InputText(size=(<span class="number">30</span>, <span class="keyword">None</span>)), sg.Button(button_text=<span class="string">'Ok'</span>, size=(<span class="number">10</span>, <span class="number">1</span>))]]</span><br><span class="line">window = sg.Window(<span class="string">'小刘鸭之窗'</span>, layout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    event, values = window.read()</span><br><span class="line">    <span class="keyword">if</span> event == sg.WIN_CLOSED <span class="keyword">or</span> event == <span class="string">'Cancel'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    sg.popup(<span class="string">'Input is '</span> + values[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure><h4 id="大家认为谁更简单一些？"><a href="#大家认为谁更简单一些？" class="headerlink" title="大家认为谁更简单一些？"></a>大家认为谁更简单一些？</h4><p>相信诸君无论熟悉 Python 与否，都能看出 PySimpleGUI 的代码具有高度可读性，更符合自然语义。不需要过多的设置即可做到优雅的主题、窗口排布。<br>这段代码给一个从未接触过 PySimpleGUI 的人看，一般也可轻松看出上半部分是布局实现，下半部分的循环是 Event Loop。<br>回过头来再看 Tkinter 的实现，对初学者来说很容易不知所云。<br>关于 QtDesigner，其实它的操作和语法也没有 PySimpleGUI 简单直观。不过下一篇中我会提到通过 QtDesigner 快速创建 Layout 代码，也算一种另类的物尽其用。</p><h2 id="配置开发环境与-PySimpleGUI"><a href="#配置开发环境与-PySimpleGUI" class="headerlink" title="配置开发环境与 PySimpleGUI"></a>配置开发环境与 PySimpleGUI</h2><p>这部分我不会说废话重复造轮子，那样有凑字数之嫌，直接放出比较好的文章供大家参考（感谢下文中作者们的贡献）。希望读者诸君自我实现一遍，加深印象。<br>因为个人习惯用 VS Code + Anaconda 配置开发环境，使用 pip、PyCharm 等的朋友可自行配置所需组件。关于 Anaconda、VS Code 和 PyCharm 的使用疑问请自行参考下述文档解决，其中的内容比较具体。关于各种开发环境的优劣性对比，请自行用搜索引擎解答疑问。</p><h3 id="2-1-Windows-下配置"><a href="#2-1-Windows-下配置" class="headerlink" title="2.1. Windows 下配置"></a>2.1. Windows 下配置</h3><h4 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h4><p><a href="https://segmentfault.com/a/1190000022797661" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022797661</a></p><h4 id="配置-Anaconda-并在本地环境中添加-PySimpleGUI"><a href="#配置-Anaconda-并在本地环境中添加-PySimpleGUI" class="headerlink" title="配置 Anaconda 并在本地环境中添加 PySimpleGUI"></a>配置 Anaconda 并在本地环境中添加 PySimpleGUI</h4><p><a href="https://zhuanlan.zhihu.com/p/25198543" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25198543</a></p><h4 id="配置-VS-Code-开发环境"><a href="#配置-VS-Code-开发环境" class="headerlink" title="配置 VS Code 开发环境"></a>配置 VS Code 开发环境</h4><p><a href="https://zhuanlan.zhihu.com/p/30324113" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30324113</a></p><h3 id="2-2-macOS-下配置"><a href="#2-2-macOS-下配置" class="headerlink" title="2.2. macOS 下配置"></a>2.2. macOS 下配置</h3><h4 id="安装-Anaconda-1"><a href="#安装-Anaconda-1" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h4><p><a href="https://blog.csdn.net/lq_547762983/article/details/81003528" target="_blank" rel="noopener">https://blog.csdn.net/lq_547762983/article/details/81003528</a></p><h4 id="配置-Anaconda-并在本地环境中添加-PySimpleGUI-1"><a href="#配置-Anaconda-并在本地环境中添加-PySimpleGUI-1" class="headerlink" title="配置 Anaconda 并在本地环境中添加 PySimpleGUI"></a>配置 Anaconda 并在本地环境中添加 PySimpleGUI</h4><h4 id="配置-VS-Code开发环境"><a href="#配置-VS-Code开发环境" class="headerlink" title="配置 VS Code开发环境"></a>配置 VS Code开发环境</h4><p>此两步可参考上面的链接，操作类似。</p><h2 id="绘制-GUI-原型"><a href="#绘制-GUI-原型" class="headerlink" title="绘制 GUI 原型"></a>绘制 GUI 原型</h2><p>对于绘制原型，有些人立刻会想到 Sketch 或 Axure 这样的重型武器，但它们学起来时间成本过高。还有一些 Web 端收费的原型制作工具，但那些在做 APP 原型设计才比较常用，做桌面端小工具开发也没必要。<br>在寻求解决方案的时候我发现了一个很棒的工具，对于简单的绘制 UI 原型的需求，推荐大家使用 Pencil，这是一款<strong>免费、开源、轻量、跨平台（Windows、macOS、Linux、火狐拓展）的原型设计工具</strong>。<br><img src="/images/Pencil%201.png" alt="Pencil 1"><br>附上样图一张</p><p>下载地址：<a href="https://pencil.evolus.vn/" target="_blank" rel="noopener">https://pencil.evolus.vn/</a><br>在“举个最简单的例子（另类的 Hello World）”处的黑白稿 UI 原型图，即使用 Pencil 所绘。相对于糟糕的手绘稿或请公司的 UI 设计师帮忙，不如花点时间学会 Pencil 后自己画。<br>如何学习 Pencil 呢？在官网文档中有比较简单的入门介绍。或者我建议大家可直接拖拽控件试一试，很容易上手。</p><h2 id="一个完整的例子"><a href="#一个完整的例子" class="headerlink" title="一个完整的例子"></a>一个完整的例子</h2><p>文档“翻译官“是种非常无聊的行为。下面我就直接通过一个具有实际应用意义的小工具模型，来讲述脚本代码通过 PySimpleGUI 如何优雅且快速的变成图形界面小工具。</p><h3 id="4-1-程序目的"><a href="#4-1-程序目的" class="headerlink" title="4.1. 程序目的"></a>4.1. 程序目的</h3><p>把一个文件夹内的 wav 文件根据声道数，对文件自动进行重命名加到后缀上。非常简单的需求，下面我先写出功能代码。</p><h3 id="4-2-编写功能代码"><a href="#4-2-编写功能代码" class="headerlink" title="4.2. 编写功能代码"></a>4.2. 编写功能代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nchannels_rename</span><span class="params">(input_path)</span>:</span> <span class="comment"># 重命名功能模块</span></span><br><span class="line">    f = wave.open(input_path, <span class="string">'rb'</span>)</span><br><span class="line">    params = f.getnchannels()</span><br><span class="line">    oldname=input_path</span><br><span class="line">    <span class="keyword">if</span> params == <span class="number">1</span>:</span><br><span class="line">        newname = input_path.rstrip(<span class="string">'.wav'</span>) + <span class="string">'_mono'</span> + <span class="string">'.wav'</span></span><br><span class="line">        os.rename(oldname, newname)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        newname = input_path.rstrip(<span class="string">'.wav'</span>) + <span class="string">'_stereo'</span> + <span class="string">'.wav'</span></span><br><span class="line">        os.rename(oldname, newname)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wav_rename</span><span class="params">(input_path)</span>:</span> <span class="comment"># 对目录进行判断并重命名</span></span><br><span class="line">    fileend = []</span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(input_path):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(input_path):</span><br><span class="line">            fileend.append(os.path.splitext(file)[<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">'.wav'</span>):</span><br><span class="line">                nchannels_rename(input_path + os.sep + file)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'.wav'</span> <span class="keyword">in</span> fileend:</span><br><span class="line">            print(<span class="string">'Processing Complete.'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'No wave file be found!'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Check your input!'</span>)</span><br></pre></td></tr></table></figure><h3 id="4-3-PySimpleGUI-基础"><a href="#4-3-PySimpleGUI-基础" class="headerlink" title="4.3. PySimpleGUI 基础"></a>4.3. PySimpleGUI 基础</h3><p>那么接下来就要使用 PySimpleGUI 添加图形界面了，在这之前需要知道一些基础的概念。</p><h4 id="PySimpleGUI-基于什么构建？"><a href="#PySimpleGUI-基于什么构建？" class="headerlink" title="PySimpleGUI 基于什么构建？"></a>PySimpleGUI 基于什么构建？</h4><p>虽然 PySimpleGUI 默认基于 Tkinter，但实际上还具有 WxPython、QT 和 Remi 等版本。具体的区别可参考官方的“散文“文档。其中对于 Remi 的支持是十分方便的。这代表着当代码进行以下简单的引用库修改后，程序可直接生成 Web 端在浏览器中运行。对于某些轻需求下的开发，省去了大量的时间和精力。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="comment"># tkinter version</span></span><br><span class="line"><span class="keyword">import</span> PySimpleGUIWeb <span class="comment"># Web(Remi) version</span></span><br><span class="line"><span class="comment"># and PySimpleGUI27, PySimpleGUIWx, PySimpleGUIQt</span></span><br></pre></td></tr></table></figure></p><h4 id="如何实现一个基础的-GUI-结构"><a href="#如何实现一个基础的-GUI-结构" class="headerlink" title="如何实现一个基础的 GUI 结构"></a>如何实现一个基础的 GUI 结构</h4><p>这里我直接引用官方的示例代码并加上注释，一个简单的窗口布局结构代码其实很清晰：</p><ol><li>sg.theme 行代表使用哪个主题，这也是 PySimpleGUI 一开始就很注重的一点。程序的美观性很重要，而且要轻松的被实现。</li><li>layout 使用列表来定义布局，其中的每个子列表代表当前行的元素（即 Widgets，PySimpleGUI 中称控件为 Elements，本系列教程也会统一使用此术语），每个控件的属性中亦可设置各种所需的参数。</li><li>window 行创建了窗体，默认情况下自动适应控件所需的尺寸。</li><li>Event Loop 用于支撑软件功能运行到窗体关闭或点击 Cancel 退出。<br><img src="/images/PySimpleGUI%202.png" alt="PySimpleGUI 2"></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line">sg.theme(<span class="string">'DarkAmber'</span>)   <span class="comment"># 设定主题为 DarkAmber</span></span><br><span class="line"><span class="comment"># 窗口内的共含三行元素，在列表中清晰可见</span></span><br><span class="line">layout = [  [sg.Text(<span class="string">'Some text on Row 1'</span>)],</span><br><span class="line">            [sg.Text(<span class="string">'Enter something on Row 2'</span>), sg.InputText()],</span><br><span class="line">            [sg.Button(<span class="string">'Ok'</span>), sg.Button(<span class="string">'Cancel'</span>)] ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建窗体，名称为 Window Title</span></span><br><span class="line">window = sg.Window(<span class="string">'Window Title'</span>, layout)</span><br><span class="line"><span class="comment"># Event Loop，不断的从窗体中读取事件与返回值，并检测窗口是否被关闭</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    event, values = window.read()</span><br><span class="line">    <span class="keyword">if</span> event == sg.WIN_CLOSED <span class="keyword">or</span> event == <span class="string">'Cancel'</span>: </span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">'You entered '</span>, values[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure><h4 id="PySimpleGUI-能做出什么样的程序？"><a href="#PySimpleGUI-能做出什么样的程序？" class="headerlink" title="PySimpleGUI 能做出什么样的程序？"></a>PySimpleGUI 能做出什么样的程序？</h4><p>在这里我放几张官方的图片供大家观看，相信诸位能看出它内置丰富控件元素及优雅设计。<br><img src="/images/pytheme.jpg" alt="pytheme"><br>所有内置的主题</p><p><img src="/images/pyml.jpg" alt="pyml"><br>引入机器学习模块判断车辆的存在</p><p><img src="/images/pywidget.jpg" alt="pywidget"><br>用到了13种元素的示例程序（实际上还有更多）</p><p><img src="/images/pywindow.png" alt="pywindow"><br>多窗口示例程序</p><h3 id="4-4-构建-GUI-代码"><a href="#4-4-构建-GUI-代码" class="headerlink" title="4.4. 构建 GUI 代码"></a>4.4. 构建 GUI 代码</h3><p>回到我们的程序设计上。对于这个简单的程序，我们需要程序中包含路径输入框、处理按钮、处理提示文本框等。为此，我简单绘制一个原型。<br><img src="/images/pyui.png" alt="pyui"></p><p>有了原型，下面我写一段简单的 GUI 实现并附上注释：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设计布局为四行元素，分别用到文字、输入框、文件夹浏览器、输出、按钮等元素。</span></span><br><span class="line">layout = [  [sg.Text(<span class="string">'Browse Folders'</span>)],</span><br><span class="line">            [sg.Input(), sg.FolderBrowse(<span class="string">'Browse'</span>, key=<span class="string">'folder'</span>)],</span><br><span class="line">            [sg.Output(size=(<span class="number">70</span>, <span class="number">20</span>), font=(<span class="string">"宋体"</span>, <span class="number">10</span>))],</span><br><span class="line">            [sg.Button(<span class="string">'Cock it'</span>), sg.Button(<span class="string">'Cancel'</span>)] ]</span><br><span class="line"><span class="comment"># 构建窗体 GUI Enemy No. 1</span></span><br><span class="line">window = sg.Window(<span class="string">'GUI Enemy No. 1'</span>, layout)</span><br><span class="line"><span class="comment"># 创建 Event Loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    event, values = window.read()</span><br><span class="line">    <span class="keyword">if</span> event <span class="keyword">in</span> (<span class="keyword">None</span>, <span class="string">'Cancel'</span>): <span class="comment"># 如果用户点击“Cancel”按钮，就退出循环并关闭窗口</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'Cock it'</span>: <span class="comment"># 如果用户点击“Cock it”按钮，就执行判断体判断是否为文件夹输入，是的话输出文字并调用 wav_rename() 函数进行操作</span></span><br><span class="line">        <span class="keyword">if</span> values[<span class="string">'folder'</span>]:</span><br><span class="line">            print(<span class="string">'&#123;0&#125;Renaming&#123;0&#125;'</span>.format(<span class="string">'*'</span>*<span class="number">10</span>))</span><br><span class="line">            wav_rename(values[<span class="string">'folder'</span>])</span><br><span class="line">            print(<span class="string">'&#123;0&#125;Done&#123;0&#125;'</span>.format(<span class="string">'*'</span>*<span class="number">10</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'Choose some folder first!'</span>)</span><br><span class="line"></span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure></p><h4 id="4-5-组装代码"><a href="#4-5-组装代码" class="headerlink" title="4.5. 组装代码"></a>4.5. 组装代码</h4><p>写完功能代码和 GUI 代码，肯定需要把它们组装到一起。根据项目的复杂程度，你也可以决定是否按模块整理代码。<br>注：为了避免浪费篇幅，其中函数体直接省略。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nchannels_rename</span><span class="params">(input_path)</span>:</span></span><br><span class="line">    Function body</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wav_rename</span><span class="params">(input_path)</span>:</span></span><br><span class="line">    Function body</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gui</span><span class="params">()</span>:</span></span><br><span class="line">    Function body</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>    </span><br><span class="line">    gui()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><h4 id="4-6-执行效果"><a href="#4-6-执行效果" class="headerlink" title="4.6. 执行效果"></a>4.6. 执行效果</h4><p>我稍微修改了一下代码，让被修改后的文件名输出到文本框中。从输出结果可见，程序如预先构思执行，我们仅用不到20行代码就优雅的完成了这个工具。<br><img src="/images/pyresult-1.png" alt="pyresult"></p><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2><p>聪明的读者一定很好奇这些部分：</p><ul><li>如何添加菜单栏？</li><li>窗体内元素能否实现双栏或不对称布局？</li><li>之前你提到过用 QtDesigner 能快速生成布局？不用自己写布局代码了吗？</li><li>有没有对声音设计师来说更实用或更复杂的程序案例详解（例如跟 WAAPI 或 ReaScript 联动）？</li></ul><p>在之后的文章中我会就这些部分继续展开介绍，欢迎诸位持续关注。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>游戏音频与声音设计相关书籍推荐</title>
      <link href="/2020/08/15/%E6%B8%B8%E6%88%8F%E9%9F%B3%E9%A2%91%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
      <url>/2020/08/15/%E6%B8%B8%E6%88%8F%E9%9F%B3%E9%A2%91%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>在游戏音频与声音设计领域的探索过程中，我发现国内的相关书籍比较匮乏。对于游戏行业中一个有潜力的行业分支，我很惊讶居然没有一个像样的书单或学习路线。作为喜好钻研和分享的人，深感应该把最近一年多的挖掘与发现做成书单来分享。<strong>希望这份书单能够提高行业下限，而不是让行业持续信息闭塞。</strong><br>文中为我认为值得推荐的书籍（包括我已读和准备读的），少部分书籍之所以不推荐，是因为其中内容过于古老，或内容空洞没参考价值。<strong>中文书籍我认为大多数朋友应该已经读过或翻过，此部分书籍尽量省略介绍。</strong>书单这种东西，希望它不仅仅是躺在你的收藏夹里，而是对你的知识体系建设有帮助。<br>与著名的“保姆级” Unity 教程作者 Jasper Flick 相同，我对<strong>知识应该成体系的去分享这种思维表示极度的赞同。</strong>所以与直接的列书单不同，我会增加参考性的评价，供诸君选书之用。<br>诚然，作为实践中才能获取更多经验的工作类型。对于 Sound Designer 或 Audio Programmer 来说，绝大多数的经验都是难以从书籍中获取的。除非某一日出版《Wwise Implementation FAQ 要你命3000》、《游戏音效声音设计实例 For Dummies》、《21天成为 ReaScript 自动化大师》等“史诗级”书籍……<br>此书单会根据本人学习情况不定时更新，请关注公众号以获得最新版本推送。<br>希望这个书单对你有帮助，有任何疑问欢迎留言到本文下。</p><p>[TOC]</p><p>第二版更新内容：</p><ol><li>改正错别字及增改推荐介绍文字内容</li><li>聊聊如何选择适合你的阅读顺序以及怎么读（次日推送，包含 TOC）</li><li>增加“游戏音频导论”下关于求职和项目规划的书目</li><li>增加“声音设计”下关于效果器使用、电影声音和空间音频（中文）的书目</li><li>增加“技术音频”下关于 Unity 音频整合及 Unity、Unreal Engine 使用相关书目</li></ol><p>todo:<br>视听<br>电影之声：电影音效师访谈录<br>放低话筒杆<br>Sound FX 声音制作效果器等一系列效果器使用书籍<br>声频信号的仪表测量<br>声音 米歇尔·希翁<br>空间声原理<br>空间线索在3D音频中的应用研究<br>Audio Programming for Interactive Games<br>Game Audio Development with Unity 5.X<br>The Oxford Handbook of Interactive Audio<br>Unity from Zero to Proficiency<br>Unity Game Development Cookbook<br>Unreal Engine Game Development Cookbook<br>The Bible of Getting a Job in Game Audio, 2020 Edition<br>The Beep Book: Documenting the History of Game Sound<br>Audio for Games: Planning, Process, and Production<br>Producing Great Sound for Film and Video<br>Post Sound Design: The Art and Craft of Audio Post Production for the Moving Image(nice)<br>Hollywood Sound Design and Moviesound Newsletter: A Case Study of the End of the Analog Age<br>Sound Design and Science Fiction<br>Unity 3D游戏开发（第2版）</p><blockquote><p>约定：</p><ul><li>本文的中英文符号与书名标记，根据《夹用英文的中文文本的标点符号用法（草案）》进行标准化，如英文书名一律使用斜体英文表示。</li><li>绝大部分英文书籍可在 Amazon 购买实体书或 Kindle 版，亦可购买 Focal Press 或 CRC Press 等数字压制的 PDF 版本。中文书籍可轻松的在各大图书网站寻得购买途径，此处便不赘述。</li><li>本文不提供任何盗版获取方式，如有能力请支持正版。作为知识的载体，图书的价格已是低到不可想象。如暂时看了盗版，请记住日后有钱补票，这才是知识流动的正循环。</li><li>文中图书封面严谨的进行过横向900像素的统一，以获得公众号上最完美的阅读体验，请大家欣赏标准化带来的美感。</li></ul></blockquote><h2 id="1-游戏音频导论"><a href="#1-游戏音频导论" class="headerlink" title="1. 游戏音频导论"></a>1. 游戏音频导论</h2><p>导论部分多为适合入门者的读物，内容偏向综合介绍游戏音频行业的工作内容与常见技巧。</p><h4 id="《游戏音频完全指南（第2版）》"><a href="#《游戏音频完全指南（第2版）》" class="headerlink" title="《游戏音频完全指南（第2版）》"></a>《游戏音频完全指南（第2版）》</h4><p><img src="/images/%E6%B8%B8%E6%88%8F%E9%9F%B3%E9%A2%91%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97_900.jpg" alt="游戏音频完全指南_900"><br>Aaron Marks，人民邮电出版社，2014</p><p>这本应该是想入行的绝大大多数人搜到的前几本书之一。从功利阅读角度出发，4-6章关于如何接私活的内容大可不看，只读其他部分的内容足矣。<br>作为音频技术与录音艺术译丛中不太被重视的一本，第3版被夏老师重译的几率看来很低，这也让这本书的内容略显陈旧（例如关于中间件和录音的内容几乎没有）。建议有条件的朋友翻阅原版第3版，其中新增大量诱人的内容，包括游戏音频必备技能、音效设计技巧、田野录音（Field Recording）、对白录音，以及最重要的部分——对 Wwise 等几大中间件的介绍并引入引擎整合时脚本的概念，如此升级后的内容才能让初学者对游戏音频有一套比较好的认知，而不是单纯停留在简单的资源制作层面。</p><h4 id="Game-Sound-An-Introduction-to-the-History-Theory-and-Practice-of-Video-Game-Music-and-Sound-Design"><a href="#Game-Sound-An-Introduction-to-the-History-Theory-and-Practice-of-Video-Game-Music-and-Sound-Design" class="headerlink" title="Game Sound: An Introduction to the History, Theory, and Practice of Video Game Music and Sound Design"></a><em>Game Sound: An Introduction to the History, Theory, and Practice of Video Game Music and Sound Design</em></h4><p><img src="/images/Game%20Sound%20-%20An%20Introduction%20to%20the%20History,%20Theory,%20and%20Practice%20of%20Video%20Game%20Music%20and%20Sound%20Design_900.jpg" alt="Game Sound - An Introduction to the History, Theory, and Practice of Video Game Music and Sound Design_900"><br>Karen Collins, The MIT Press, 2008<br>滑铁卢大学游戏学院副教授 Karen Collins N 部作品之一，简单梳理了游戏和音频的发展史。其中对音频团队构成和音频处理阶段有比较清晰的探讨。限制于篇幅，比较泛泛而谈，新手入门时跳着翻翻查漏补缺会有些启发。</p><h4 id="Principles-of-Game-Audio-and-Sound-Design"><a href="#Principles-of-Game-Audio-and-Sound-Design" class="headerlink" title="Principles of Game Audio and Sound Design"></a><em>Principles of Game Audio and Sound Design</em></h4><p><img src="/images/Principles%20of%20Game%20Audio%20and%20Sound%20Design*.jpg" alt="Principles of Game Audio and Sound Design*"><br>Jean-Luc Sinclair, Focal Press, 2020<br>一本详实的入门书籍，内容包括游戏引擎、声音引擎、编程、整合、过程式音频等对初学者很友好的概念。作者除了声音设计外还作曲，与九寸钉 Trent 叔和 RATM 乐队均有合作。</p><h4 id="Playing-with-Sound-A-Theory-of-Interacting-with-Sound-and-Music-in-Video-Games"><a href="#Playing-with-Sound-A-Theory-of-Interacting-with-Sound-and-Music-in-Video-Games" class="headerlink" title="Playing with Sound: A Theory of Interacting with Sound and Music in Video Games"></a><em>Playing with Sound: A Theory of Interacting with Sound and Music in Video Games</em></h4><p><img src="/images/Playing%20with%20Sound%20-%20A%20Theory%20of%20Interacting%20with%20Sound%20and%20Music%20in%20Video%20Games_900.jpg" alt="Playing with Sound - A Theory of Interacting with Sound and Music in Video Games_900"><br>Karen Collins, The MIT Press, 2013<br>同为 Karen Collins 的作品，这本偏向理论，探讨了各种交互式声音在游戏中的使用。从电影研究、哲学、心理学到计算机科学，综合探讨了一个交互式声音体验理论。</p><h4 id="The-Essential-Guide-to-Game-Audio-The-Theory-and-Practice-of-Sound-for-Games"><a href="#The-Essential-Guide-to-Game-Audio-The-Theory-and-Practice-of-Sound-for-Games" class="headerlink" title="The Essential Guide to Game Audio: The Theory and Practice of Sound for Games"></a><em>The Essential Guide to Game Audio: The Theory and Practice of Sound for Games</em></h4><p><img src="/images/The%20Essential%20Guide%20to%20Game%20Audio%20-%20The%20Theory%20and%20Practice%20of%20Sound%20for%20Games_900.jpg" alt="The Essential Guide to Game Audio - The Theory and Practice of Sound for Games_900"><br>Steve Horowitz, Scott Looney, Routledge, 2014<br>同样是近乎完美的一本入门读物，只可惜停留在14年的版本再无更新。从游戏历史、交互式声音、Middleman 中间件，一直讲到使用 Unity 自己的音频功能进行整合声音。非常基础。适合初学者花一天时间好好读一遍，拓宽视野（虽然本书的范围并不够）。</p><h4 id="Creating-Music-and-Sound-for-Games"><a href="#Creating-Music-and-Sound-for-Games" class="headerlink" title="Creating Music and Sound for Games"></a><em>Creating Music and Sound for Games</em></h4><p><img src="/images/Creating%20Music%20and%20Sound%20for%20Games_900.jpg" alt="Creating Music and Sound for Games_900"><br>G. W. Childs IV, Course Technology PTR, 2006<br>给星战游戏做声音设计的老前辈的老著作，因为他写过 Reason 的书，所以其中会夹带不少用 Reason 做声音设计的私货。不过看年份就知道书里不少东西已经过时，入门随便翻翻看看前辈的思路还是可以的，记住别傻乎乎的去下 GigaStudio。</p><h4 id="The-Game-Audio-Strategy-Guide-A-Practical-Course"><a href="#The-Game-Audio-Strategy-Guide-A-Practical-Course" class="headerlink" title="The Game Audio Strategy Guide: A Practical Course"></a><em>The Game Audio Strategy Guide: A Practical Course</em></h4><p><img src="/images/The%20Game%20Audio%20Strategy%20Guide_900.jpg" alt="The Game Audio Strategy Guide_900"><br>Gina Zdanowicz, Spencer Bambrick, Focal Press, 2019<br>从去年开始就颇为感兴趣的一本书，推上关注 Gina 的话能看出她是想把这本书做成非常系统的入门书籍。举些例子，在声音设计部分就分别讲了从音效库、合成、拟音和田野录音等方法获取素材加以合成，在整合部分少有的把音频和音乐整合分开讲，入门直接看这本应该也很棒。</p><h2 id="2-声音设计"><a href="#2-声音设计" class="headerlink" title="2. 声音设计"></a>2. 声音设计</h2><p>在这部分，本清单着重于考虑声音设计理论和后期制作，亦包括合成器内容。此处假设读者诸君已对录音艺术有足够的了解，故《现代录音技术》这类书目不在本清单考虑范围之内。有需要的同学请自行检索“音频技术与录音艺术译丛”、“录音技术与艺术系列丛书 ”、“录音艺术专业‘十二五’规划教材”等经典丛书。</p><h3 id="2-1-声音设计理论与实践"><a href="#2-1-声音设计理论与实践" class="headerlink" title="2.1 声音设计理论与实践"></a>2.1 声音设计理论与实践</h3><p>影视声音设计多为线性声音，但众所周知，其中大量的技巧都可运用到游戏交互式声音设计中来，故此部分含影视相关书籍。</p><h4 id="《音效圣经-好莱坞音效创作及录制技巧》"><a href="#《音效圣经-好莱坞音效创作及录制技巧》" class="headerlink" title="《音效圣经: 好莱坞音效创作及录制技巧》"></a>《音效圣经: 好莱坞音效创作及录制技巧》</h4><p><img src="/images/%E9%9F%B3%E6%95%88%E5%9C%A3%E7%BB%8F%20%20%E5%A5%BD%E8%8E%B1%E5%9D%9E%E9%9F%B3%E6%95%88%E5%88%9B%E4%BD%9C%E5%8F%8A%E5%BD%95%E5%88%B6%E6%8A%80%E5%B7%A7%20%20%E6%8F%92%E5%9B%BE%E7%89%88_900.jpg" alt="音效圣经  好莱坞音效创作及录制技巧  插图版_900"><br>Ric Viers，北京联合出版公司·后浪出版公司，2016<br>两个十诫值得学习，第17章稍微值得稍微一看。对有录音基础的人来说，其余部分很乏味。</p><h4 id="《电影电视声音（第3版）》"><a href="#《电影电视声音（第3版）》" class="headerlink" title="《电影电视声音（第3版）》"></a>《电影电视声音（第3版）》</h4><p><img src="/images/%E7%94%B5%E5%BD%B1%E7%94%B5%E8%A7%86%E5%A3%B0%E9%9F%B3%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89_900.jpg" alt="电影电视声音（第3版）_900"><br>Tomlinson Holman，人民邮电出版社，2015<br>对声音设计师来说，目光可集中在第10章附近。前面的心理声学、音频基础、扬声器技术等过于老生常谈。</p><h4 id="《电影声音实用艺术（第3版）》"><a href="#《电影声音实用艺术（第3版）》" class="headerlink" title="《电影声音实用艺术（第3版）》"></a>《电影声音实用艺术（第3版）》</h4><p><img src="/images/%E7%94%B5%E5%BD%B1%E5%A3%B0%E9%9F%B3%E5%AE%9E%E7%94%A8%E8%89%BA%E6%9C%AF_900-1.jpg" alt="电影声音实用艺术_900"><br>Davis Lewis Yewdall, 人民邮电出版社，2011<br>相对《电影电视声音》来说，对声音设计师的启发就大的多了。毕竟做声音设计的时候本质也是在反复拉片，故本书有一半以上的内容值得深入学习。看着35mm胶片上的光学声迹，你会感叹用 DAW 做 Sound Design 是多么幸福。</p><h4 id="《动画声音设计》"><a href="#《动画声音设计》" class="headerlink" title="《动画声音设计》"></a>《动画声音设计》</h4><p><img src="/images/%E5%8A%A8%E7%94%BB%E5%A3%B0%E9%9F%B3%E8%AE%BE%E8%AE%A1_900.jpg" alt="动画声音设计_900"><br>Robin Beauchamp，人民邮电出版社，2011<br>国内的第1版排版是横向的，读起来很不舒服是一大缺点。书本身的内容极好，完整的从基础带着读者过了一遍影视动画声音设计，关于画外音、节奏、知觉引导等部分很棒。随书光盘有3GB+的内容，后面两个例子非常详细。<br>对有条件阅读原版的读者，仍推荐加读第2版，新版除了内容增减外，后面的例子数量变的非常多，可仔细把作者的理论套上去研究一番。</p><h4 id="《审美空间延伸与拓展-电影声音艺术理论》"><a href="#《审美空间延伸与拓展-电影声音艺术理论》" class="headerlink" title="《审美空间延伸与拓展: 电影声音艺术理论》"></a>《审美空间延伸与拓展: 电影声音艺术理论》</h4><p><img src="/images/%E5%AE%A1%E7%BE%8E%E7%A9%BA%E9%97%B4%E5%BB%B6%E4%BC%B8%E4%B8%8E%E6%8B%93%E5%B1%95_900.jpg" alt="审美空间延伸与拓展_900"><br>姚国强、孙欣，中国电影出版社，2002<br>北电的新世纪电影学论丛中一本著名书籍，尚未读完，不敢妄加评论。但就随便翻翻带来的观感而言，令人醍醐灌顶。电影声音艺术的研究对游戏声音设计的帮助是巨大的，要多多学习。</p><h4 id="《声音设计-电影中语言，音乐和音响的表现（第2版）》"><a href="#《声音设计-电影中语言，音乐和音响的表现（第2版）》" class="headerlink" title="《声音设计: 电影中语言，音乐和音响的表现（第2版）》"></a>《声音设计: 电影中语言，音乐和音响的表现（第2版）》</h4><p><img src="/images/%E5%A3%B0%E9%9F%B3%E8%AE%BE%E8%AE%A1_900.jpg" alt="声音设计_900"><br>David Sonnenschein，浙江大学出版社，2009<br>声音和画面、声音和叙事二章非常棒，可了解电影声音设计的方法论。与《审美空间延伸与拓展: 电影声音艺术理论》类比阅读，都是影视声音设计逆向输出的经典文献，值得深入学习。</p><h4 id="Studying-Sound-A-Theory-and-Practice-of-Sound-Design"><a href="#Studying-Sound-A-Theory-and-Practice-of-Sound-Design" class="headerlink" title="Studying Sound: A Theory and Practice of Sound Design"></a><em>Studying Sound: A Theory and Practice of Sound Design</em></h4><p><img src="/images/Studying%20Sound_900.jpg" alt="Studying Sound_900"><br>Karen Collins, The MIT Press, 2020<br>Karen Collins 的一本偏向实践的书，<em>Studying Sound</em> 我还没读到，但介绍中提到有多达175个练习，是颇为偏向练手的一本。其中的练习从练耳开始，看起来相当注重基础。</p><h4 id="Foundations-in-Sound-Design-for-Interactive-Media-A-Multidisciplinary-Approach"><a href="#Foundations-in-Sound-Design-for-Interactive-Media-A-Multidisciplinary-Approach" class="headerlink" title="Foundations in Sound Design for Interactive Media: A Multidisciplinary Approach"></a><em>Foundations in Sound Design for Interactive Media: A Multidisciplinary Approach</em></h4><p><img src="/images/Foundations%20in%20Sound%20Design%20for%20Interactive%20Media_900.jpg" alt="Foundations in Sound Design for Interactive Media_900"><br>Michael Filimowicz, Routledge, 2019<br>一本交互式媒体声音设计论文集，从游戏声音设计到装置艺术声音设计和网页交互声音设计均有涉猎。</p><h4 id="Foundations-in-Sound-Design-for-Linear-Media-A-Multidisciplinary-Approach"><a href="#Foundations-in-Sound-Design-for-Linear-Media-A-Multidisciplinary-Approach" class="headerlink" title="Foundations in Sound Design for Linear Media: A Multidisciplinary Approach"></a><em>Foundations in Sound Design for Linear Media: A Multidisciplinary Approach</em></h4><p><img src="/images/Foundations%20in%20Sound%20Design%20for%20Linear%20Media%20-%20A%20Multidisciplinary%20Approach_900.jpg" alt="Foundations in Sound Design for Linear Media - A Multidisciplinary Approach_900"><br>Michael Filimowicz, Routledge, 2019<br>同上，一本线性媒体声音设计论文集（其实还有本嵌入式媒体声音设计），这本偏影视的多。</p><h4 id="Sound-Design-Theory-and-Practice-Working-with-Sound"><a href="#Sound-Design-Theory-and-Practice-Working-with-Sound" class="headerlink" title="Sound Design Theory and Practice: Working with Sound"></a><em>Sound Design Theory and Practice: Working with Sound</em></h4><p><img src="/images/Sound%20Design%20Theory%20and%20Practice_900.jpg" alt="Sound Design Theory and Practice_900"><br>Leo Murray, Routledge, 2019<br>一本简单的小书，从电影、电视、游戏分析了声音设计的理论基础，闲暇可翻（电影分析的是1933年版金刚，很有历史感）。</p><h4 id="Sound-Works-A-Cultural-Theory-of-Sound-Design"><a href="#Sound-Works-A-Cultural-Theory-of-Sound-Design" class="headerlink" title="Sound Works: A Cultural Theory of Sound Design"></a><em>Sound Works: A Cultural Theory of Sound Design</em></h4><p><img src="/images/Sound%20Works_900.jpg" alt="Sound Works_900"><br>Holger Schulze, Bloomsbury Academic, 2020<br>什么是声音设计？它在21世纪早期的功能是什么？这本书从文化理论角度出发讨论了这些问题。听起来非常理论化，其实第二部分 Sonic Labor 的插图对声音设计师的视觉化描述非常有趣。</p><h4 id="The-Fundamentals-of-Sonic-Art-and-Sound-Design"><a href="#The-Fundamentals-of-Sonic-Art-and-Sound-Design" class="headerlink" title="The Fundamentals of Sonic Art and Sound Design"></a><em>The Fundamentals of Sonic Art and Sound Design</em></h4><p><img src="/images/The%20Fundamentals%20of%20Sonic%20Art%20and%20Sound%20Design_900.jpg" alt="The Fundamentals of Sonic Art and Sound Design_900">Tony Gibbs, Fairchild Books, 2007<br>一句话：声音装置艺术爱好者的福音。想把声音设计掺和到声音艺术领域的人大可从本书中汲取营养，看看大家是怎么玩的。</p><h4 id="The-Plagrave-Handbook-of-Sound-Design-and-Music-in-Screen-Media"><a href="#The-Plagrave-Handbook-of-Sound-Design-and-Music-in-Screen-Media" class="headerlink" title="The Plagrave Handbook of Sound Design and Music in Screen Media"></a><em>The Plagrave Handbook of Sound Design and Music in Screen Media</em></h4><p><img src="/images/The%20Plagrave%20Handbook%20of%20Sound%20Design%20and%20Music%20in%20Screen%20Medi_900.jpg" alt="The Plagrave Handbook of Sound Design and Music in Screen Medi_900">Liz Greene, Danijela Kulezic-Wilson, Palgrave Macmillan, 2016<br>影视配乐与声音设计之间的关系越来越模，这本文集就集合了相关的一些文章。仅少量声音设计相关的论述值得一看。</p><h3 id="2-2-拟音（Foley）"><a href="#2-2-拟音（Foley）" class="headerlink" title="2.2 拟音（Foley）"></a>2.2 拟音（Foley）</h3><h4 id="《拟音圣经-电影、游戏和动画片中的声音表演艺术》"><a href="#《拟音圣经-电影、游戏和动画片中的声音表演艺术》" class="headerlink" title="《拟音圣经: 电影、游戏和动画片中的声音表演艺术》"></a>《拟音圣经: 电影、游戏和动画片中的声音表演艺术》</h4><p><img src="/images/%E6%8B%9F%E9%9F%B3%E5%9C%A3%E7%BB%8F_900.jpg" alt="拟音圣经_900">Vanessa Theme Ament，人民邮电出版社，2010<br>必读书籍，无需赘述，掰芹菜和砸湿抹布都是拿手好戏。</p><h4 id="《影视拟音技巧》"><a href="#《影视拟音技巧》" class="headerlink" title="《影视拟音技巧》"></a>《影视拟音技巧》</h4><p><img src="/images/%E5%BD%B1%E8%A7%86%E6%8B%9F%E9%9F%B3%E6%8A%80%E5%B7%A7_900.jpg" alt="影视拟音技巧_900"><br>魏俊华，高超，高士义，中国广播电视出版社，2012<br>虽然权威，但废话极多，且图片编辑极其不专业（直接拍照），建议跳读+一张导图完事。</p><h3 id="2-3-Pure-Data"><a href="#2-3-Pure-Data" class="headerlink" title="2.3 Pure Data"></a>2.3 Pure Data</h3><p>之所以这部分只放 Pure Data 而没有 Max、Csound、SuperCollider、ChucK 等。是因为在下着实精力有限，以后学到了再更相关资料。不过这些东西其实读文档和看 YouTube 足矣，纸质出版物远没有 Pd 多。</p><h4 id="《设计声音》"><a href="#《设计声音》" class="headerlink" title="《设计声音》"></a>《设计声音》</h4><p><img src="/images/%E8%AE%BE%E8%AE%A1%E5%A3%B0%E9%9F%B3_900.jpg" alt="设计声音_900"><br>Andy Farnell，中国邮电出版社，2017<br>过程式音频设计原理 + Pure Data 入门，很有趣的书（前面理论部分若已知悉一些跳读起来更爽快）。</p><h4 id="《电子音乐技术》"><a href="#《电子音乐技术》" class="headerlink" title="《电子音乐技术》"></a>《电子音乐技术》</h4><p><img src="/images/%E7%94%B5%E5%AD%90%E9%9F%B3%E4%B9%90%E6%8A%80%E6%9C%AF_900.jpg" alt="电子音乐技术_900"><br>Miller Puckette，人民邮电出版社，2011<br>Pure Data 作者本人写的书，从头带你玩声音合成。英语基础不好看不懂文档的同学可以先看这个。</p><h4 id="《交互式音频程序开发》"><a href="#《交互式音频程序开发》" class="headerlink" title="《交互式音频程序开发》"></a>《交互式音频程序开发》</h4><p><img src="/images/%E4%BA%A4%E4%BA%92%E5%BC%8F%E9%9F%B3%E9%A2%91%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91_900.jpg" alt="交互式音频程序开发_900"><br>童雷，韩柯，人民邮电出版社，2018<br>一本简单的 Pure Data 介绍类书籍，把基础的合成方法过了一遍，最后配置了 OSC 来应了书的主题。</p><h4 id="《Pure-Data-图形化音乐编程技术与应用》"><a href="#《Pure-Data-图形化音乐编程技术与应用》" class="headerlink" title="《Pure Data 图形化音乐编程技术与应用》"></a>《Pure Data 图形化音乐编程技术与应用》</h4><p><img src="/images/Pure%20Data%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E9%9F%B3%E4%B9%90%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8_900.jpg" alt="Pure Data 图形化音乐编程技术与应用_900">杨万钧，西南师范大学出版社，2017<br>川音电子音乐理论与技术丛书中讲 Pure Data 的一本，算是本土化不错的一本详细的 Pd 介绍。本套丛书还涉及了 Kyma、Max、Csound、VVVV 等令人兴奋的内容，值得一看。</p><h4 id="Multimedia-Programming-with-Pure-Data"><a href="#Multimedia-Programming-with-Pure-Data" class="headerlink" title="Multimedia Programming with Pure Data"></a><em>Multimedia Programming with Pure Data</em></h4><p><img src="/images/Multimedia%20Programming%20with%20Pure%20Data_900.jpg" alt="Multimedia Programming with Pure Data_900">Bryan WC Chung, Packt Publishing, 2013<br>这本更着重讲 Pure Data 里视频组件做多媒体艺术的部分。</p><h4 id="Programming-Sound-with-Pure-Data-Make-Your-Apps-Come-Alive-with-Dynamic-Audio"><a href="#Programming-Sound-with-Pure-Data-Make-Your-Apps-Come-Alive-with-Dynamic-Audio" class="headerlink" title="Programming Sound with Pure Data: Make Your Apps Come Alive with Dynamic Audio"></a><em>Programming Sound with Pure Data: Make Your Apps Come Alive with Dynamic Audio</em></h4><p><img src="/images/Programming%20Sound%20with%20Pure%20Data_%20Make%20Your%20Apps%20Come%20Alive%20with%20Dynamic%20Audio_900.jpg" alt="Programming Sound with Pure Data_ Make Your Apps Come Alive with Dynamic Audio_900"><br>Tony Hillerson, Pragmatic Bookshelf, 2014<br>除了前面的基础部分，让 App 使用动态音频实际指的是对一个 Web 游戏添加 Pd Patch 来产生交互。</p><h3 id="2-4-VCV-Rack"><a href="#2-4-VCV-Rack" class="headerlink" title="2.4 VCV Rack"></a>2.4 VCV Rack</h3><p>VCV Rack 文档配合 YouTube 视频实际已经可以满足学习需求，但鉴于我一开始找到了相关资料，就一并放出供初学者参考。</p><h4 id="How-to-Rack"><a href="#How-to-Rack" class="headerlink" title="How to Rack"></a><em>How to Rack</em></h4><p><img src="/images/How%20to%20Rack_900.jpg" alt="How to Rack_900">Jim Aikin, Self-Publishing</p><h4 id="VCV-Rack-How-it-Works"><a href="#VCV-Rack-How-it-Works" class="headerlink" title="VCV Rack: How it Works"></a><em>VCV Rack: How it Works</em></h4><p><img src="/images/VCV%20Rack%20-%20How%20it%20Works_900.jpg" alt="VCV Rack - How it Works_900"><br>Edgar Rothermich, Self-Publishing, 2018<br>作者是中国女婿，册子也是非常友好的图文交互册子。</p><h4 id="Developing-Virtual-Synthesizers-with-VCV-Rack"><a href="#Developing-Virtual-Synthesizers-with-VCV-Rack" class="headerlink" title="Developing Virtual Synthesizers with VCV Rack"></a><em>Developing Virtual Synthesizers with VCV Rack</em></h4><p><img src="/images/Developing%20Virtual%20Synthesizers%20with%20VCV%20Rack_900.jpg" alt="Developing Virtual Synthesizers with VCV Rack_900"><br>Leonardo Gabrielli, Focal Press, 2020<br>开发自己的模块，对官网文档做了一个很好的整理。</p><h3 id="2-4-Reaktor"><a href="#2-4-Reaktor" class="headerlink" title="2.4 Reaktor"></a>2.4 Reaktor</h3><h4 id="《声音合成平台-Reaktor-操作指南》"><a href="#《声音合成平台-Reaktor-操作指南》" class="headerlink" title="《声音合成平台 Reaktor 操作指南》"></a>《声音合成平台 Reaktor 操作指南》</h4><p><img src="/images/%E5%A3%B0%E9%9F%B3%E5%90%88%E6%88%90%E5%B9%B3%E5%8F%B0REAKTOR%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97_900.jpg" alt="声音合成平台REAKTOR操作指南_900">夏田，人民邮电出版社，2016<br>夏老师经典之作，看不懂 Youtube 和 Kadenze 的朋友可以先看这本。虽然用的是 Reaktor 5，但对学习影响不大。</p><h3 id="2-5-合成器"><a href="#2-5-合成器" class="headerlink" title="2.5 合成器"></a>2.5 合成器</h3><h4 id="《自己动手做声音-声音合成与制作基础》"><a href="#《自己动手做声音-声音合成与制作基础》" class="headerlink" title="《自己动手做声音: 声音合成与制作基础》"></a>《自己动手做声音: 声音合成与制作基础》</h4><p><img src="/images/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%81%9A%E5%A3%B0%E9%9F%B3_900.jpg" alt="自己动手做声音_900"><br>程伊兵，中央音乐学院出版社，2009<br>程老师声音合成经典著作，唯一的缺点是例子基于 Nord Modular G2，但单纯的学思路是没有任何影响的。</p><h4 id="《声音合成与采样技术（第3版）》"><a href="#《声音合成与采样技术（第3版）》" class="headerlink" title="《声音合成与采样技术（第3版）》"></a>《声音合成与采样技术（第3版）》</h4><p><img src="/images/%E5%A3%B0%E9%9F%B3%E5%90%88%E6%88%90%E4%B8%8E%E9%87%87%E6%A0%B7%E6%8A%80%E6%9C%AF%20%20%E7%AC%AC3%E7%89%88_OCR_900.jpg" alt="声音合成与采样技术  第3版_OCR_900">Martin Russ，人民邮电出庵社，2011<br>夏老师翻译的一本对声音合成解释非常详细的制作，非常底层的从 VCA、VCO、VCF 这种初上模块容易令人困惑的概念讲起，值得深入学习的一本好书。</p><h4 id="《软件合成器技术实战手册-音色制作与模块编程》"><a href="#《软件合成器技术实战手册-音色制作与模块编程》" class="headerlink" title="《软件合成器技术实战手册: 音色制作与模块编程》"></a>《软件合成器技术实战手册: 音色制作与模块编程》</h4><p><img src="/images/%E8%BD%AF%E4%BB%B6%E5%90%88%E6%88%90%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98%E6%89%8B%E5%86%8C_900.jpg" alt="软件合成器技术实战手册_900"><br>飞来音，清华大学出版社，2008<br>看不懂英文说明书和教程的同学可翻翻这本老书。</p><h4 id="Creating-Sounds-from-Scratch-A-Practical-Guide-to-Music-Synthesis-for-Producers-and-Composers"><a href="#Creating-Sounds-from-Scratch-A-Practical-Guide-to-Music-Synthesis-for-Producers-and-Composers" class="headerlink" title="Creating Sounds from Scratch: A Practical Guide to Music Synthesis for Producers and Composers"></a><em>Creating Sounds from Scratch: A Practical Guide to Music Synthesis for Producers and Composers</em></h4><p><img src="/images/Creating%20Sounds%20from%20Scratch_900.jpg" alt="Creating Sounds from Scratch_900"><br>Andrea Pejrolo, Scott B. Metcalfe, Oxford University Press, 2017<br>基本可以看做是《声音合成与采样技术》更符合阅读学习体验的版本，贴心的从历史到基础术语讲起。每种合成方式独占一章，且配合详细的聆听指南让读者记忆音色中所用的模块，非常人性化。</p><h4 id="The-Synthesizer-A-Comprehensive-Guide-to-Understanding-Programming-Playing-and-Recording-the-Ultimate-Electronic-Music-Instrument"><a href="#The-Synthesizer-A-Comprehensive-Guide-to-Understanding-Programming-Playing-and-Recording-the-Ultimate-Electronic-Music-Instrument" class="headerlink" title="The Synthesizer: A Comprehensive Guide to Understanding, Programming, Playing, and Recording the Ultimate Electronic Music Instrument"></a><em>The Synthesizer: A Comprehensive Guide to Understanding, Programming, Playing, and Recording the Ultimate Electronic Music Instrument</em></h4><p><img src="/images/The%20Synthesizer_900.jpg" alt="The Synthesizer_900"><br>Mark Vail, Oxford University Press, 2014<br>相比 <em>Creating Sounds from Scratch</em>，这本小书更强调介绍合成器历史，并拉人入坑到模块世界去。</p><h4 id="Computer-Sound-Design-Synthesis-Techniques-and-Programming-2nd-edition"><a href="#Computer-Sound-Design-Synthesis-Techniques-and-Programming-2nd-edition" class="headerlink" title="Computer Sound Design: Synthesis Techniques and Programming 2nd edition"></a><em>Computer Sound Design: Synthesis Techniques and Programming 2nd edition</em></h4><p><img src="/images/Computer%20Sound%20Design_900.jpg" alt="Computer Sound Design_900">Eduardo Reck Miranda, Focal Press, 2002<br>作为一本老书，前面的声音合成理论自然不会过时。但有趣的部分是，可一览当年的声音合成程序，如命令行的 pcmusic、Som-A，史前 Reaktor 等。</p><h4 id="Becoming-a-Synthesizer-Wizard-From-Presets-to-Power-User"><a href="#Becoming-a-Synthesizer-Wizard-From-Presets-to-Power-User" class="headerlink" title="Becoming a Synthesizer Wizard: From Presets to Power User"></a><em>Becoming a Synthesizer Wizard: From Presets to Power User</em></h4><p><img src="/images/Becoming%20a%20Synthesizer%20Wizard%20From%20Presets%20to%20Power%20User_900.jpg" alt="Becoming a Synthesizer Wizard From Presets to Power User_900"><br>Simon Cann, Cengage Learning PTR, 2009<br>也算一本不错的合成器教程，缺点是示例软件过老，建议用模块复刻其中的 Patch。</p><h4 id="Welsh’s-Synthesizer-Cookbook-Synthesizer-Programming-Sound-Analysis-and-Universal-Patch-Book-1、2"><a href="#Welsh’s-Synthesizer-Cookbook-Synthesizer-Programming-Sound-Analysis-and-Universal-Patch-Book-1、2" class="headerlink" title="Welsh’s Synthesizer Cookbook: Synthesizer Programming, Sound Analysis, and Universal Patch Book 1、2"></a><em>Welsh’s Synthesizer Cookbook: Synthesizer Programming, Sound Analysis, and Universal Patch Book 1、2</em></h4><p><img src="/images/Welsh&#39;s%20Synthesizer%20Cookbook_900.jpg" alt="Welsh&#39;s Synthesizer Cookbook_900"><br>Fred Welsh, 2006<br>没有废话，讲完点前置知识后直接上各种 Patch 的配置表，都是通用的参数，可直接在自己的合成器里复刻研究，十分实用。</p><h4 id="Refining-Sound-A-Practical-Guide-to-Synthesis-and-Synthesizers"><a href="#Refining-Sound-A-Practical-Guide-to-Synthesis-and-Synthesizers" class="headerlink" title="Refining Sound: A Practical Guide to Synthesis and Synthesizers"></a><em>Refining Sound: A Practical Guide to Synthesis and Synthesizers</em></h4><p><img src="/images/Refining%20Sound_900.jpg" alt="Refining Sound_900"><br>Brian K. Shepard, Oxford University Press, 2013<br>一本合成器快速入门的小册子，讲的不够详细，快速翻翻入门还不错。</p><h4 id="Analog-Synthesizers-Understanding-Performing-Buying-2nd-edition"><a href="#Analog-Synthesizers-Understanding-Performing-Buying-2nd-edition" class="headerlink" title="Analog Synthesizers: Understanding, Performing, Buying 2nd edition"></a><em>Analog Synthesizers: Understanding, Performing, Buying 2nd edition</em></h4><p><img src="/images/Analog%20Synthesizers_900.jpg" alt="Analog Synthesizers_900"><br>Mark Jenkins, Routledge, 2020<br>伴随模拟和数字合成器的历史更迭，讲述合成器的使用。</p><h4 id="Microsound"><a href="#Microsound" class="headerlink" title="Microsound"></a><em>Microsound</em></h4><p><img src="/images/Microsound_900.jpg" alt="Microsound_900"><br>Curtis Roads, The MIT Press, 2001<br>伟大的 <em>The Computer Music Tutorial</em> 的作者，这本主讲微分音与声音合成。</p><h3 id="2-6-空间音频"><a href="#2-6-空间音频" class="headerlink" title="2.6 空间音频"></a>2.6 空间音频</h3><p>这部分其实还有些别的书，但鉴于本人尚未翻过，咱不敢乱说话，日后再更。</p><h4 id="Ambisonics"><a href="#Ambisonics" class="headerlink" title="Ambisonics"></a><em>Ambisonics</em></h4><p><img src="/images/Ambisonics_900.jpg" alt="Ambisonics_900"><br>Franz Zotter, Matthias Frank, Springer, 2019<br>关于 Ambisonics 的概念和应用，一站式解决。</p><h4 id="Immersive-Sound"><a href="#Immersive-Sound" class="headerlink" title="Immersive Sound"></a><em>Immersive Sound</em></h4><p><img src="/images/Immersive%20Sound_900.jpg" alt="Immersive Sound_900"><br>Agnieszka Roginska, Paul Geluso, Routledge, 2018<br>沉浸式声音有关概念和应用。</p><h2 id="3-技术音频"><a href="#3-技术音频" class="headerlink" title="3. 技术音频"></a>3. 技术音频</h2><h3 id="3-1-导论及杂集"><a href="#3-1-导论及杂集" class="headerlink" title="3.1 导论及杂集"></a>3.1 导论及杂集</h3><h4 id="《游戏引擎架构》"><a href="#《游戏引擎架构》" class="headerlink" title="《游戏引擎架构》"></a>《游戏引擎架构》</h4><p><img src="/images/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%20_900.jpg" alt="游戏引擎架构 _900"><br>Jason Gregory, 电子工业出版社, 2014<br>叶大知名译作，虽然刚出了第2版但鉴于还没买……就先推荐第1版吧。原作在 Amazon 上也是评价颇高，对不熟悉引擎的人来说快速摸一遍结构，再读说明书也会明朗不少。</p><h4 id="《游戏编程算法与技巧》"><a href="#《游戏编程算法与技巧》" class="headerlink" title="《游戏编程算法与技巧》"></a>《游戏编程算法与技巧》</h4><p><img src="/images/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7_900.jpg" alt="游戏编程算法与技巧_900"><br>Sanjay Madhav，电子工业出版社，2016<br>侯老师推荐给我的一本，来自腾讯的瀚阳老师精心译作。作为南加州大学的本科教材，系统讲解了游戏开发中基础的各方面，4-11章中充满亮点。关于物理、声音和脚本语言的部分很不错，初学者跟着实现一遍附带的项目会很有帮助。</p><h4 id="The-Audio-Programming-Book"><a href="#The-Audio-Programming-Book" class="headerlink" title="The Audio Programming Book"></a><em>The Audio Programming Book</em></h4><p><img src="/images/The%20Audio%20Programming%20Book_900.jpg" alt="The Audio Programming Book_900"><br>Richard Boulanger, eVictor Lazzarini, The MIT Press, 2011<br>一本关于音频编程的文集，不仅探讨了 C, C++, Csound，对 DFT、FFT、卷积等经典概念也有专门的文章进行讨论。是非常好的音频编程益智类读物，适合休闲娱乐时补充营养之用。</p><h4 id="Game-Audio-Programming-Principles-and-Practices-1、2、3"><a href="#Game-Audio-Programming-Principles-and-Practices-1、2、3" class="headerlink" title="Game Audio Programming: Principles and Practices 1、2、3"></a><em>Game Audio Programming: Principles and Practices 1、2、3</em></h4><p><img src="/images/GAP%20all_900.jpg" alt="GAP all_900"><br>Guy Somberg, CRC Press, 2016 2018 2020<br>Guy 老哥作为这系列游戏音频编程文集的编者，估计技术音频们没有不知道的。之前简单翻了翻前言，说说刚出版的第三册的内容：音频资源管理、DSP 编程、语音管线、抽象游戏音频层级为 Patch Cable、声部管理等迷人的部分。<br>文中具体的作者均是行业先锋，有兴趣考据可翻翻作者介绍。</p><h4 id="Beep-To-Boom-The-Development-Of-Advanced-Runtime-Sound-Systems-For-Games-And-Extended-Reality"><a href="#Beep-To-Boom-The-Development-Of-Advanced-Runtime-Sound-Systems-For-Games-And-Extended-Reality" class="headerlink" title="Beep To Boom: The Development Of Advanced Runtime Sound Systems For Games And Extended Reality"></a><em>Beep To Boom: The Development Of Advanced Runtime Sound Systems For Games And Extended Reality</em></h4><p><img src="/images/Beep%20To%20Boom_900.jpg" alt="Beep To Boom_900"><br>Simon N Goodwin, Focal Press, 2019<br>主要内容是关于交互式音频系统的设计，内容详实。</p><h4 id="Game-Audio-Tales-of-a-Technical-Sound-Designer-1、2"><a href="#Game-Audio-Tales-of-a-Technical-Sound-Designer-1、2" class="headerlink" title="Game Audio: Tales of a Technical Sound Designer 1、2"></a><em>Game Audio: Tales of a Technical Sound Designer 1、2</em></h4><p><img src="/images/Game%20Audio%20Tales_900.jpg" alt="Game Audio Tales_900"><br>Damian Kastbauer, 2017<br>Audiokinetic 产品经理胡子哥，WAG 的前身 Wwise 工程大冒险的奠基人。他的两本书收集了他关于技术音频或技术声音设计师（Technical Sound Designer）的诸多博文与采访，其中关于整合工具的部分令人大开眼界。</p><h3 id="3-2-游戏引擎音频整合"><a href="#3-2-游戏引擎音频整合" class="headerlink" title="3.2 游戏引擎音频整合"></a>3.2 游戏引擎音频整合</h3><h4 id="Game-Audio-Implementation-A-Practical-Guide-Using-the-Unreal-Engine"><a href="#Game-Audio-Implementation-A-Practical-Guide-Using-the-Unreal-Engine" class="headerlink" title="Game Audio Implementation: A Practical Guide Using the Unreal Engine"></a><em>Game Audio Implementation: A Practical Guide Using the Unreal Engine</em></h4><p><img src="/images/Game%20audio%20implementation_900.jpg" alt="Game audio implementation_900"><br>Richard Stevens, Dave Raybould, Focal Press, 2016<br>使用 UE4 自带的音频功能进行声音整合。</p><h4 id="Game-Audio-with-FMOD-and-Unity"><a href="#Game-Audio-with-FMOD-and-Unity" class="headerlink" title="Game Audio with FMOD and Unity"></a><em>Game Audio with FMOD and Unity</em></h4><p><img src="/images/Game%20Audio%20with%20FMOD%20and%20Unity_900.jpg" alt="Game Audio with FMOD and Unity_900"><br>Ciarán Robinson, Routledge, 2019<br>使用 FMOD 给 Unity 进行音频整合，不过聪明的同学应该想得出，从本书学会怎么改脚本，一样能套到 Wwise Unity 整合上。（奸笑</p><h4 id="The-Handbook-of-Game-Audio-Using-Wwise"><a href="#The-Handbook-of-Game-Audio-Using-Wwise" class="headerlink" title="The Handbook of Game Audio Using Wwise"></a><em>The Handbook of Game Audio Using Wwise</em></h4><p>Gordon Durity, Aleksandar Zecevic, A K Peters, 2021<br>跳票已久的 Wwise 书，作者是 EA 的两位老哥，封面欠缺。</p><h3 id="3-3-插件开发"><a href="#3-3-插件开发" class="headerlink" title="3.3 插件开发"></a>3.3 插件开发</h3><p>鉴于在下的插件开发了解着实较少，就只列基本常见书籍，以后再更。</p><h4 id="Getting-Started-with-JUCE"><a href="#Getting-Started-with-JUCE" class="headerlink" title="Getting Started with JUCE"></a><em>Getting Started with JUCE</em></h4><p><img src="/images/Getting%20Started%20with%20JUCE_900.jpg" alt="Getting Started with JUCE_900"><br>Martin Robinson, Packt Publishing, 2013<br>关于 JUCE 的一本小书，其实看文档和 Kadenze 会更好些。</p><h4 id="Audio-Effects-Theory-Implementation-and-Application"><a href="#Audio-Effects-Theory-Implementation-and-Application" class="headerlink" title="Audio Effects: Theory, Implementation and Application"></a><em>Audio Effects: Theory, Implementation and Application</em></h4><p><img src="/images/Audio%20Effects_900.jpg" alt="Audio Effects_900"><br>Joshua D. Reiss, Andrew McPherson, CRC Press, 2014<br>跟接下来三本比，算是插件设计里比较轻松的一本读物。比较适合对新手理解效果器原理学习，每章更是友好的提供习题，最后例子的实现仍基于 JUCE。</p><h4 id="DAFX-Digital-Audio-Effects"><a href="#DAFX-Digital-Audio-Effects" class="headerlink" title="DAFX Digital Audio Effects"></a><em>DAFX Digital Audio Effects</em></h4><p><img src="/images/DAFX%20Digital%20Audio%20Effects_900.jpg" alt="DAFX Digital Audio Effects_900"><br>Udo Zölzer, Wiley, 2011<br>著名的 DAFX，目前还找不出需求读这本，不过对做音频算法的朋友来说应该是都知道的了。</p><h4 id="Designing-Audio-Effect-Plug-Ins-in-C-With-Digital-Audio-Signal-Processing-Theory"><a href="#Designing-Audio-Effect-Plug-Ins-in-C-With-Digital-Audio-Signal-Processing-Theory" class="headerlink" title="Designing Audio Effect Plug-Ins in C++ With Digital Audio Signal Processing Theory"></a><em>Designing Audio Effect Plug-Ins in C++ With Digital Audio Signal Processing Theory</em></h4><p><img src="/images/Designing%20Audio%20Effect%20Plug-Ins%20in%20C++%20With%20Digital%20Audio%20Signal%20Processing%20Theory_900.jpg" alt="Designing Audio Effect Plug-Ins in C++ With Digital Audio Signal Processing Theory_900"><br>Will C. Pirkle, Focal Press, 2012<br>DSP 开发宝典之一。</p><h4 id="Designing-Software-Synthesizer-Plug-Ins-in-C-For-RackAFX-VST3-and-Audio-Units"><a href="#Designing-Software-Synthesizer-Plug-Ins-in-C-For-RackAFX-VST3-and-Audio-Units" class="headerlink" title="Designing Software Synthesizer Plug-Ins in C++ For RackAFX, VST3, and Audio Units"></a><em>Designing Software Synthesizer Plug-Ins in C++ For RackAFX, VST3, and Audio Units</em><img src="/images/Designing%20Software%20Synthesizer%20Plug-Ins%20in%20C++%20For%20RackAFX,%20VST3,%20and%20Audio%20Units_900.jpg" alt="Designing Software Synthesizer Plug-Ins in C++ For RackAFX, VST3, and Audio Units_900"></h4><p>Will C. Pirkle, Focal Press, 2014<br>开发宝典之二。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/11/04/hello-world/"/>
      <url>/2018/11/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Testing </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
