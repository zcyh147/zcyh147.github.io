<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>人人都能用 WAAPI（二）wwise.core 分支</title>
      <link href="/2020/09/05/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/09/05/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>在《人人都能用 WAAPI（一）概述》中，我们用思维导图对 WAAPI 进行了重新归纳，在配置好开发环境后，还一起用 Python 写了几个简单的小程序，体验了 WAAPI 强大功能的冰山一角。如前文目录所述，从第二篇开始，我们的内容会遍历讲解 WAAPI 的所有功能。<br>为了不当一个讨厌的<strong>“文档翻译官”</strong>，我会努力用简单化的语言来描述 WAAPI 的功能，再想方法把相关的 API 组成示例程序供大家参考。</p><blockquote><p>约定：</p><ul><li><strong>把 API 逐条列出讲解是为了阐述其功能帮助大家快速对 WAAPI 建立印象</strong>，并非给大家作为新的参考文档。建议看完本文后按照第一篇文中所提的方法，用自己喜欢的整理方式重新整理一次。</li><li>本文并不会把每个参数全都翻译并复述一遍功能，这里<strong>均假设读者在学习完概述中的 JSON 阅读方法后，都能够自行根据我的介绍理解 WAAPI 参数与返回值等信息。</strong></li><li>为了行文简洁，这里<strong>均假设大家在阅读本系列文章时能轻松的定位到在线文档中对应的位置</strong>，所以不会再文中再放所需的网页地址。</li><li>RTFM，因为接下来的文章比较严肃。<strong>如果发现某个概念找不到、看不懂，请善用 Wwise 文档的搜索功能或用 Google 查找所需答案。</strong>跟 Wwise 关系不大的概念我会提前注明，可选看。</li></ul></blockquote><h2 id="wwise-core-概览"><a href="#wwise-core-概览" class="headerlink" title="wwise.core 概览"></a>wwise.core 概览</h2><p><img src="/images/wwisecore.png" alt="wwisecore"><br>作为 WAAPI 中最大的模块（以我在上一篇提出的分类逻辑），<code>wwise.core</code> 承载着最多的功能。除了它与 <code>soundengine</code> 模块外，执行类剩余的几个 API 模块功能相对简单，所以 <code>wwise.core</code> 会成为我们投入精力比较多的一个部分。<br>简单的看一下上面的思维导图，不难看出本模块的功能主要针对 Wwise 音频设计部分，而不是对声音引擎层级。这也代表<strong>如果你有一些操作级的优化想法，这可能是对你最重要的章节。</strong><br>注意：图中划线的部分代表是 WAAPI 已中被新 API 替代的功能。</p><h2 id="audio（导入音频并创建对象）"><a href="#audio（导入音频并创建对象）" class="headerlink" title="audio（导入音频并创建对象）"></a>audio（导入音频并创建对象）</h2><p><a href="https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi_import.html" target="_blank" rel="noopener">https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi_import.html</a><br><a href="https://www.audiokinetic.com/zh/library/edge/?source=Help&amp;id=importing_media_files_from_tab_delimited_text_file" target="_blank" rel="noopener">https://www.audiokinetic.com/zh/library/edge/?source=Help&amp;id=importing_media_files_from_tab_delimited_text_file</a></p><h3 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h3><p><code>audio</code> 分支下有 <code>import</code> 和 <code>importTabDelimited</code>，根据名字容易看出这是负责导入音频资源的功能。这两者的区别是<strong>前者负责直接导入音频并创建对象</strong>，<strong>后者为根据“制表符分割文件”中所定制的规则导入音频并创建对象</strong>。<br>所谓“制表符分割文件导入音频“，简单来说就是<strong>在音频文件导入时使用一个制表符分割的文本文件读取提前规定的被导入相关属性（例如音频文件在本机的储存位置、Wwise 中它要所产生对象在各个层级〔各种容器、Event、Output Bus〕的位置、设定属性值和引用、Switch 指派子元素等）。</strong></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>不难看出，<code>audio</code> 分支是最重要的资源导入分支，也是大部分第一个实用性 WAAPI 程序的起点。<br>（这段看不懂可以只直接看段尾结论）众所周知，各大操作系统对于文件名和路径的长度都有所限制，例如 Windows 下因 Win32 API 的 MAX_PATH 为260，所以 Wwise 中的文件名长度要受此最大值和路径本身的共同约束，理论上支持最大256字符长度文件名的资源导入，但加上系统路径后往往给不到用户那么多可用字符，所以<strong>通过音频文件名来定义其在工程中的各种位置和属性是远远不够的，除非建立一个密码表一样的词典对应文件名中的代号。</strong><br>这也是制表符分割文件导入存在的意义，因为这种方法是在 Excel 中定义好一切信息后，才交给 Wwise 让其按需导入文件的。</p><ul><li>聪明的读者已经想到，或许可通过 VBA 给声音设计师创建一个在 Excel 中快速对制表符分割文件结构构建的程序，但这样会让音频集成管线中出现一些不必要的工具切换。</li><li>更聪明的读者会想到通过 Python 的诸如 openpyxl 或 xlutils 等 Excel 读写模块创建一个更完备的 GUI 程序以完成制表符分割文件的快速创建，并与 WAAPI 和音频资源数据库联动。把一系列工具整合在一起，更好的完善管线效率，这也是我认为比较好的方法。<strong>我不太喜欢充满零碎的工作流，更欣赏集中、完善、美观、可模块化扩展的整合化工具。</strong></li></ul><h2 id="audioSourcePeaks（音频源峰值获取）"><a href="#audioSourcePeaks（音频源峰值获取）" class="headerlink" title="audioSourcePeaks（音频源峰值获取）"></a>audioSourcePeaks（音频源峰值获取）</h2><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>此分支下有 <code>getMinMaxPeaksInRegion</code> 和 <code>getMinMaxPeaksInTrimmedRegion</code>，其功能为获取音频峰值并返回相关信息。两者的区别是前者返回的是所选区域的峰值，后者是对修剪过后的音频取峰值。<strong>注意这个峰值不是唯一的 Max Peak，而是根据 numPeaks 指定数量的 Min/Max Peak。</strong><br>在 <code>getMinMaxPeaksInRegion</code> 的参数中，可看到 <code>timeFrom</code> 和 <code>timeFrom</code>，这是用来确定要求值的区域开始和结束时间的。<br>在 <code>getMinMaxPeaksInTrimmedRegion</code> 则无需指定开始结束时间，会直接对 SFX 对象裁剪后的部分进行求值。<br>（可以不看）返回值是使用 Base 64 编码的16位有符号 int 数组，所以要经过 Base 64 解码、按照给定的格式(fmt)解析字节流、再换算成 dB。</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>我对 Wwise 插件开发了解还不够，但能对一段音频取这么多最大/最小峰值点的操作很明显并不是普通的工作时的操作，这两个功能提供的最多点位可多达百亿级的 14294967295。<br>倒是让我想到了这可以用在插件中重现音频波形图上，或许需要波形图时可通过其来进行辅助取得音频数据，待以后对 Wwise 插件开发有所研究后再修补此处内容。</p><h2 id="object（对象操作）"><a href="#object（对象操作）" class="headerlink" title="object（对象操作）"></a>object（对象操作）</h2><h3 id="功能介绍-1"><a href="#功能介绍-1" class="headerlink" title="功能介绍"></a>功能介绍</h3><h4 id="create-copy-delete-move（对象基本操作）"><a href="#create-copy-delete-move（对象基本操作）" class="headerlink" title="create, copy, delete, move（对象基本操作）"></a>create, copy, delete, move（对象基本操作）</h4><p>这四个功能最基本的对象操作，分别对应对象的创建、拷贝、删除、移动。所需参数比较简单，多为对象名、类型、它现在的位置、之后的位置等。<br>有些同学可能会产生疑问，<code>audio</code> 功能导入的音频时不是已经能够同时创建对象了吗？<br><strong>其实是两者分工不同，<code>create</code> 能够创建 Wwise Objects Reference 中列出的大量对象，包括效果器和声源插件，<code>audio</code> 在导入音频的时候可创建不了这些。</strong><code>create</code> 从简单创建的 Sound SFX 对象或 Work Unit，到把音频添加到 Event、创建各种容器并指定元素，这些功能它均可完成。</p><h4 id="setReference-setRandomizer-setAttenuationCurve-setName-setNotes-setProperty（设置对象的各种属性）"><a href="#setReference-setRandomizer-setAttenuationCurve-setName-setNotes-setProperty（设置对象的各种属性）" class="headerlink" title="setReference, setRandomizer, setAttenuationCurve, setName, setNotes, setProperty（设置对象的各种属性）"></a>setReference, setRandomizer, setAttenuationCurve, setName, setNotes, setProperty（设置对象的各种属性）</h4><p><code>create</code> 类创建对象时是无法设置全部属性的（比如上面列出的 API 中只有 Notes 能随着对象一起创建），所以我们需要通过上面的这些功能进一步设置对象属性。<br>其中 <code>setReference</code> 为设置引用，如想要为一个 SFX 对象设置输出 Bus，就需要为这个对象添加对某个 Bus 的引用。<br><code>setRandomizer, setAttenuationCurve, setName, setNotes</code> 这些功能即为语义本身之功能。<br><code>setProperty</code> 是真正用来设置属性的命令。有的同学可能会想到，在 <code>setReference</code> 设置好引用后怎么继续下一步，此时正是需要用 <code>setProperty</code> 来进行属性修改。</p><h4 id="get-getTypes-getPropertyInfo-getAttenuationCurve-getPropertyAndReferenceNames（获取对象的各种属性）"><a href="#get-getTypes-getPropertyInfo-getAttenuationCurve-getPropertyAndReferenceNames（获取对象的各种属性）" class="headerlink" title="get, getTypes, getPropertyInfo, getAttenuationCurve, getPropertyAndReferenceNames（获取对象的各种属性）"></a>get, getTypes, getPropertyInfo, getAttenuationCurve, getPropertyAndReferenceNames（获取对象的各种属性）</h4><p>如果不是从零开始一个新工程，想要修改现有工程的属性。或者一个很重要的用法，获取现有工程的诸多数据。此时就需要用 <code>get</code> 这一系列功能。<br><strong><code>get</code> 是基于 query（查询）的功能，它能够获取能想到的几乎所有信息，例如 ID、名字、大小、路径、音频源长度等，设定好合适的查询参数即可完成查询。</strong><br>那么为什么还要有 <code>getTypes, getPropertyInfo, getAttenuationCurve, getPropertyAndReferenceNames, getPropertyNames</code> 呢？<br>其实是功能分工不同，不像 <code>get</code> 是针对具体对象的各种属性进行查询。这四个查询更偏向对象的元属性，<code>getTypes</code> 返回当前所有注册的对象类型，<code>getPropertyInfo</code> 返回对象属性的具体信息（例如取值范围等），<code>getAttenuationCurve</code> 返回特定对象的衰减曲线设置，<code>getPropertyAndReferenceNames</code> 返回对象拥有的属性和当前引用名称。</p><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>对象操作的可应用之处非常多，举例来说在使用 <code>audio</code> 分支下的功能建立好音频框架后，通过 <code>create</code> 系列功能来构建除了 Actor-Mixer 之外的部分（例如各种容器、Event）。再通过 <code>set</code> 系列功能来设置参数，亦可通过 <code>get</code> 系列参数获取最终完成的工程的空间占用情况，形成一套比较自动的工作流。</p><h2 id="getInfo-和-log-get（工程信息和日志获取）"><a href="#getInfo-和-log-get（工程信息和日志获取）" class="headerlink" title="getInfo 和 log.get（工程信息和日志获取）"></a>getInfo 和 log.get（工程信息和日志获取）</h2><h3 id="功能介绍-2"><a href="#功能介绍-2" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>两个非常简单的功能，<code>getInfo</code> 用于获取当前工程全局信息，例如 Wwise 版本、平台、API 版本等。<code>log.get</code> 用于获取最新的日志，Logs 窗口中的那几个选项卡就对应本 API 参数中的 channel，此功能用于获取完整的日志，如果想实现在自己的程序里动态更新日志情况，还是需要用订阅类的 <code>ak.wwise.core.log.itemAdded</code>。</p><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p>在对工程全局信息和日志有需求时，可根据设想使用这两个功能。其中 <code>log.get</code> 既然能获取最新的日志，完全可以在 WAAPI 程序中某些关键步骤后加入这项功能，从而把每次的日志保存到数据库或进行想要的分析，以获得更为个性化的反馈报告。</p><h2 id="profiler（分析器功能）"><a href="#profiler（分析器功能）" class="headerlink" title="profiler（分析器功能）"></a>profiler（分析器功能）</h2><h3 id="功能介绍-3"><a href="#功能介绍-3" class="headerlink" title="功能介绍"></a>功能介绍</h3><h4 id="startCapture-stopCapture（Capture-开关）"><a href="#startCapture-stopCapture（Capture-开关）" class="headerlink" title="startCapture, stopCapture（Capture 开关）"></a>startCapture, stopCapture（Capture 开关）</h4><p>单纯的控制 Capture 的开始或停止，无需参数，可直接调用。</p><h4 id="getBusses-getCursorTime-getRTPCs-getVoiceContributions-getVoices（获取-Profiler-中特定时间点的信息）"><a href="#getBusses-getCursorTime-getRTPCs-getVoiceContributions-getVoices（获取-Profiler-中特定时间点的信息）" class="headerlink" title="getBusses, getCursorTime, getRTPCs, getVoiceContributions, getVoices（获取 Profiler 中特定时间点的信息）"></a>getBusses, getCursorTime, getRTPCs, getVoiceContributions, getVoices（获取 Profiler 中特定时间点的信息）</h4><p>其中 <code>getBusses</code>、<code>getRTPCs</code>、<code>getVoices</code> 为同一类功能，参数为给定一个特定的时间，即可查询 Profiler 此刻的存在的 Bus、RTPC ID、RTPC 值、相关声部信息等。<br><code>getCursorTime</code> 可获取当前 Profiler 光标的位置，并返回时间。<br><code>getVoiceContributions</code> 是这里面稍微复杂的一个，需要通过管线 ID 和 Profiler 的时间位置，可查询影响干声路径音量和高低通的所有参数。</p><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p>不难看出，<code>startCapture, stopCapture</code> 可集成到工具上进行手动或自动控制，方便进行比较复杂的捕捉需求。例如使用 Unity WAAPI 客户端，把一些分析的功能和 Trigger 做到一起，实现 Unity 中的自动化采集。<br><code>get</code> 类功能就可根据需求获取分析数据，再根据需求进行分析之用。</p><h2 id="project-save（保存工程）"><a href="#project-save（保存工程）" class="headerlink" title="project.save（保存工程）"></a>project.save（保存工程）</h2><h3 id="功能介绍-4"><a href="#功能介绍-4" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>保存当前工程。</p><h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><p>单纯代替 Ctrl + S 肯定没什么意思。比较有用的场景可以是在追求稳定的某些场景中根据触发条件自动保存。比如在批量导入上万文件时，为了工程安全，可在每导入100个甚至10个文件时就调用此功能保存一次，以避免任何潜在的不安全。</p><h2 id="remote（远程连接到游戏）"><a href="#remote（远程连接到游戏）" class="headerlink" title="remote（远程连接到游戏）"></a>remote（远程连接到游戏）</h2><h3 id="功能介绍-5"><a href="#功能介绍-5" class="headerlink" title="功能介绍"></a>功能介绍</h3><h4 id="connect-disconnect（连接，断开连接）"><a href="#connect-disconnect（连接，断开连接）" class="headerlink" title="connect, disconnect（连接，断开连接）"></a>connect, disconnect（连接，断开连接）</h4><p>对于看过 Wwise 一分钟的小伙伴，应该看过侯老师亲自配音的“如何使用WAAPI将Wwise连接到您的游戏”（<a href="https://www.bilibili.com/video/BV11E411P7GW），那里就是通过" target="_blank" rel="noopener">https://www.bilibili.com/video/BV11E411P7GW），那里就是通过</a> <code>connect</code> 完成了连接操作。注意，调用 <code>connect</code> 时需要提供主机 IP 并可选提供端口号，这也是为什么下面的 <code>getAvailableConsoles</code> 要存在，如果有连接到不同的游戏引擎中的需求，就可通过此功能先获取可连接的客户端列表再进行操作。</p><h4 id="getAvailableConsoles-getConnectionStatus（查看当前可用的控制台和获得当前连接状态）"><a href="#getAvailableConsoles-getConnectionStatus（查看当前可用的控制台和获得当前连接状态）" class="headerlink" title="getAvailableConsoles, getConnectionStatus（查看当前可用的控制台和获得当前连接状态）"></a>getAvailableConsoles, getConnectionStatus（查看当前可用的控制台和获得当前连接状态）</h4><p>这两个功能非常简单，<code>getAvailableConsoles</code> 用来获取当前可用的所有声音引擎控制台，换句话说就是查看当前有哪些跟 Wwise 可连接的游戏工程，并返回编辑器名字、IP、端口、平台等信息。<br><code>getConnectionStatus</code> 则是获取当前连接状态，只有已经跟引擎连接上后才会返回控制台信息和连接状态。</p><h3 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h3><p><code>remote</code> 系的连接和断开连接功能如官方所述，一种很棒的应用场景是设置到游戏中的菜单上，或者通过 StreamDeck 和 Metagrid 这样的工具快速触发，能够提升工作流效率。<br>至于 <code>getAvailableConsoles</code> 和 <code>getConnectionStatus</code>，如果大家记得 <code>profiler</code> 部分，相信能想到把这两个紧密相关的功能结合，可以把 Wwise 的分析器搬到自己的程序中。比如自动化提取想要的信息，或者简单的在自己的程序里告知用户当前连接状态如何，以实现比较完善的 Wwise 外工作流。</p><h2 id="soundbank（SoundBank-生成与内容相关）"><a href="#soundbank（SoundBank-生成与内容相关）" class="headerlink" title="soundbank（SoundBank 生成与内容相关）"></a>soundbank（SoundBank 生成与内容相关）</h2><h3 id="功能介绍-6"><a href="#功能介绍-6" class="headerlink" title="功能介绍"></a>功能介绍</h3><p><code>generate</code> 意如其名，负责生成 SoundBank。我们知道，日常生成 SoundBank 时除了全部生成外，还可勾选特定的 SoundBank、平台、语言来生成，同理，使用 <code>generate</code> 时也需要设置这些参数。<br><code>getInclusions</code> 可以返回 SoundBank 内包含所有 Event 的列表，其中包括 GUID 和 Event 所含的层级结构。<br><code>setInclusions</code> 负责设置 SoundBank 内包含的对象，可以添加、删除、替换。</p><h3 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h3><p>在 <code>object</code> 类中大家是否还记得 <code>create, copy, delete, move</code> 这些对象的基本操作？<code>soundbank</code> 类中既然如果想要对不存在的 SoundBank 进行操作，就需先通过 <code>create</code> 进行创建 SoundBank 对象和层级，之后才能继续操作。<br><strong>至此，一套完整的创建工作流就产生了，<code>audio</code> 类负责导入音频并创建音频层级结构，<code>create</code> 类可以创建并构建各种其他层级和 Event 等，最后由 <code>soundbank</code> 类负责收尾创建 SoundBank。</strong>这套工作流可用于根据外部设定的结构文件自动化创建，或在 Wwise 外的控制程序上通过 <code>soundbank</code> 检视工程内部结构。</p><h2 id="switchContainer（Switch-容器内操作）"><a href="#switchContainer（Switch-容器内操作）" class="headerlink" title="switchContainer（Switch 容器内操作）"></a>switchContainer（Switch 容器内操作）</h2><h3 id="功能介绍-7"><a href="#功能介绍-7" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>在讨论 <code>create</code> 类时我们谈到它可以创建各种容器，其中就包括 Switch Container。<strong>那为什么这里又出现了 <code>switchContainer</code> 呢</strong>？<br>众所周知，Switch Container 指派了控制当前容器的 Switch/State Group 后，需要对每一个引入的 Switch/State 指派容器中的对象，这样才有实际意义。WAAPI 中把对 Switch Container 中进行指派的这类操作独立出来，使用 <code>switchContainer</code> 来进行相关操作。<br><code>addAssignment</code> 和 <code>removeAssignment</code> 分别为添加与去除 Switch 指派的功能，只需要提供 Switch Container 中对象的 GUID 和目标 Switch/State Group 中的 Switch/State 的 GUID 即可轻松完成删减。<br><code>getAssignments</code>是一个非常简单的功能，给定 Switch Container 的 GUID，会返回当前容器下所有子对象的 GUID 和指定的 Switch/State 的 GUID。</p><h3 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h3><p><code>switchContainer</code> 的应用场景很容易想到，可以作为自动化导入工具流的补充。参考制表符分割文件导入音频的方法，我们亦可用制表符分割文件快速建立音频架构，补充以之前讲过的其他 API，实现全部自动化。</p><h2 id="transport（走带条控制）"><a href="#transport（走带条控制）" class="headerlink" title="transport（走带条控制）"></a>transport（走带条控制）</h2><h3 id="功能介绍-8"><a href="#功能介绍-8" class="headerlink" title="功能介绍"></a>功能介绍</h3><h4 id="create-destroy-executeAction"><a href="#create-destroy-executeAction" class="headerlink" title="create, destroy, executeAction"></a>create, destroy, executeAction</h4><p><code>create, destroy</code> 为一对功能，前者是在当前工程中创建一个走带条对象（Transport Object），后者是销毁这个走带条对象。因为是针对对象的操作，所以创建时需要对象的 GUID，销毁时需要走带条对象的 ID。<br><strong>什么叫走带条对象？</strong>其实在 Wwise 日常的工作中我们无时无刻不在重复这两个动作。选中了 Event A，走带处的控制焦点会变成控制它的状态，这就是为其创建了一个走带条对象。此时选中其他对象，这个走带条对象销毁，创建下一个。如果点击了走带条上的 Pin，这个走带条对象就会持续存在。<br>或者我们看看 Soundcaster，每个 Session 其实就是一堆走带条对象的集合。<br><code>executeAction</code> 功能很直接，负责为对象创建了走带条对象，当然是为了控制它的播放行为。这个功能提供五种 Action 可满足需求。</p><h4 id="getList-getState"><a href="#getList-getState" class="headerlink" title="getList, getState"></a>getList, getState</h4><p><code>getList</code> 为获取当前工程内所有走带条对象，在 WAAPI 中走带条对象创建后需要手工销毁，否则可通过 <code>getList</code> 查看当前还存在的。<br><code>getState</code> 为获取走带条对象的状态，在 <code>executeAction</code> 为走带条对象指定播放状态后可通过此命令进行查询。</p><h3 id="应用场景-9"><a href="#应用场景-9" class="headerlink" title="应用场景"></a>应用场景</h3><p><code>transport</code> 类的功能应用场景比较简单，如果想在 Wwise 外的程序里创建简单的播放行为控制功能，即可通过其实现。或者在 Wwise 外可复刻更符合自己想象的 Soundcaster，同时创建、控制或销毁一组走带条对象。</p><h2 id="undo（撤销）"><a href="#undo（撤销）" class="headerlink" title="undo（撤销）"></a>undo（撤销）</h2><h3 id="功能介绍-9"><a href="#功能介绍-9" class="headerlink" title="功能介绍"></a>功能介绍</h3><p><code>beginGroup</code> 和 <code>endGroup</code> 的概念对于接触过 ReaScript 的人可能更容易理解一些，即 Undo_BeginBlock() 和 Undo_EndBlock()。执行完 <code>beginGroup</code> 后到执行 <code>endGroup</code> 之前所有的操作都会被保存为一个 Undo Group。其中 <code>beginGroup</code> 可以被堆叠使用。<br><code>cancelGroup</code> 为撤销最后一个 Undo Group 内的所有操作。</p><h3 id="应用场景-10"><a href="#应用场景-10" class="headerlink" title="应用场景"></a>应用场景</h3><p>Undo Group 是一种把一堆行为一次性撤销的工具，当然，Undo Group 也可以作为 Redo 来使用，不过 WAAPI 中目前只有撤销功能。从应用场景来说，<code>undo</code> 类功能可为 Wwise 外工具增添撤销功能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>如果按照顺序读下来感到有点晕，那是正常的。</strong>这也是为什么在开头我建议大家看完这篇文章后自己做一次总结的原因。<br>要把 WAAPI 做成自己的武器库，应该按照如下步骤进行：</p><ol><li>整理出你自己的 WAAPI 框架，详细的笔记还是简略的思维导图都行</li><li>发散思维，思考自己要解决 Wwise 工作中的哪些难点</li><li>抽象出头脑中原型的逻辑为文字，并寻找到可使用的 API</li><li>完成功能代码</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>单纯的介绍是枯燥的，下面通过实例体验一下 WAAPI 的应用。<br><strong>因示例只考虑演示作用，故不会像真实项目中一样复杂设计或者加入 GUI。</strong>我会尽量覆盖到 <code>wwise.core</code> 分支下的 API，少量没用上的功能大家可自行研究，使用原理上区别不大。</p><blockquote><p>以下代码的重点是参数调用方法，当遇到奇怪的 Bug 时仔细看看你写的和示例的区别，可能就会在其中找到答案。</p></blockquote><h3 id="1-按表格中设定好的规则导入-Sound-SFX-进-Wwise-并建立层级结构，再设置一些属性。随后为其创建-Event，再创建-SoundBank，再添加之前创建的-Event，并生成-SoundBank"><a href="#1-按表格中设定好的规则导入-Sound-SFX-进-Wwise-并建立层级结构，再设置一些属性。随后为其创建-Event，再创建-SoundBank，再添加之前创建的-Event，并生成-SoundBank" class="headerlink" title="1. 按表格中设定好的规则导入 Sound SFX 进 Wwise 并建立层级结构，再设置一些属性。随后为其创建 Event，再创建 SoundBank，再添加之前创建的 Event，并生成 SoundBank"></a>1. 按表格中设定好的规则导入 Sound SFX 进 Wwise 并建立层级结构，再设置一些属性。随后为其创建 Event，再创建 SoundBank，再添加之前创建的 Event，并生成 SoundBank</h3><p>这是最常用的一类工具，能够快速导入外部文件到 Wwise 中。在示例中我们是干巴巴的人工填写各种信息，但实际工作中就可以发挥想象力，把工具中这部分繁琐的工序也解决掉。例如可以通过规范的文件名、与数据库联动、正则表达式等来快速完成导入所需的数据。</p><h4 id="选定-API"><a href="#选定-API" class="headerlink" title="选定 API"></a>选定 API</h4><ul><li>制表符导入文件：<code>importTabDelimited</code></li><li>设置属性：<code>set</code> 类</li><li>创建 Event 并添加声音、创建 SoundBank：<code>create</code></li><li>组装并生成 SoundBank：<code>setInclusions</code>、<code>generate</code></li></ul><h4 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h4><h5 id="文件导入模块"><a href="#文件导入模块" class="headerlink" title="文件导入模块"></a>文件导入模块</h5><p>因为 <code>importTabDelimited</code> 需要一个制表符分割文件作为导入索引，我们通过 Excel 创建一个符合标准的文件。<br>首先在第一行中填入以下关键词：</p><ol><li>Audio File：本机音频文件地址，因为我用 Mac 所以盘符为 Y 开头（macOS 下的 Wwise 跑在 Wine 中）</li><li>Object Path：对象路径，决定导入后的对象位置和类型</li><li>@PropertyName 或 Property[PropertyName]：属性名，可设置导入对象的各种属性。</li><li>@ReferenceName 或 Reference[ReferenceName]：引用名称，决定了导入对象的引用设置（就是设置输出 Bus、Aux Send、效果器等）</li><li>Event：把导入对象直接创建 Event 的相关设置，这个仅供演示，实际中对 Sound SFX 直接引入 Event 的的比较少</li><li>Switch Assignation：决定 Switch Container 与哪个 Switch Group 或 State Group 关联，以及 Switch Container 中的哪一个子项将要分配给关联 Group 中的 Switch 或 State。</li></ol><p>为了演示目的我们尽量把所有容器都用上，通过表格定义在 Actor-Mixer 的 Default Work Unit 中 Random Container、Sequence Container、Switch Container、Blend Container 各创建一个。<br>按以上需求完成表格，填写对应的信息来建立音频结构、设置播放规则、设置属性和引用、创建 Event 等，建立好的 Excel 文件如下图所示。</p><blockquote><p>注意：<strong>大家可能发现 <code>importTabDelimited</code> 的功能中是不包括对 Switch Group、State Group、Output Bus 等结构进行创建的</strong>，我们想让 Switch Assignation 或设置引用等功能正常工作的话得怎么办呢？<br><strong>虽然 WAAPI 没法在导入音频时通过 <code>importTabDelimited</code> 创建有些对象，但我们可以引用其他 API 来实现这个目的。</strong>（在制表符分割文件中加入自定义列来定义本身不支持的 Switch Group 或 State Group 名字、类型、路径等，对 Output Bus、效果器等也是同理）。在 <code>importTabDelimited</code> 工作前可先在 Python 中使用 Excel 库读取文件中自定义列中的内容，再调用 <code>create</code> 先行创建 Switch Group 或 State Group。这样就完善了导入音频时的工作流，这部分和 Wwise 关系不大，本例中就不实现了。</p></blockquote><h3 id="2-获取当前工程全局信息、对象信息、SoundBank-大小"><a href="#2-获取当前工程全局信息、对象信息、SoundBank-大小" class="headerlink" title="2. 获取当前工程全局信息、对象信息、SoundBank 大小"></a>2. 获取当前工程全局信息、对象信息、SoundBank 大小</h3><p>在对 Wwise 内一些信息有需求的时候，可以用 WAAPI 快速提取。</p><h4 id="选定-API-1"><a href="#选定-API-1" class="headerlink" title="选定 API"></a>选定 API</h4><ul><li>获取全局信息：<code>getInfo</code></li><li>获取 Sound SFX 和 Event 信息：<code>get</code></li><li>获取生成的 SoundBank 大小：<code>get</code></li></ul><h4 id="编写代码-1"><a href="#编写代码-1" class="headerlink" title="编写代码"></a>编写代码</h4><h3 id="3-制作一个简易-Soundcaster"><a href="#3-制作一个简易-Soundcaster" class="headerlink" title="3. 制作一个简易 Soundcaster"></a>3. 制作一个简易 Soundcaster</h3><h4 id="选定-API-2"><a href="#选定-API-2" class="headerlink" title="选定 API"></a>选定 API</h4><ul><li>创建走带条对象：<code>transport</code></li></ul><h4 id="编写代码-2"><a href="#编写代码-2" class="headerlink" title="编写代码"></a>编写代码</h4><h3 id="4-抓取-Profiler-数据生成报告"><a href="#4-抓取-Profiler-数据生成报告" class="headerlink" title="4. 抓取 Profiler 数据生成报告"></a>4. 抓取 Profiler 数据生成报告</h3><h4 id="选定-API-3"><a href="#选定-API-3" class="headerlink" title="选定 API"></a>选定 API</h4><ul><li>开始连接：<code>startCapture, stopCapture</code></li><li>抓取信息：<code>getBusses, getCursorTime, getRTPCs, getVoiceContributions, getVoices</code></li></ul><h4 id="编写代码-3"><a href="#编写代码-3" class="headerlink" title="编写代码"></a>编写代码</h4><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2><p>下一篇文章中，我们会讨论执行类中剩下的所有模块，包括声音引擎 <code>soundengine</code>、UI 操作模块 <code>wwise.ui</code>、WAAPI 模块 <code>wwise.waapi</code>、Debug 模块 <code>wwise.debug</code>。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>必看须知</title>
      <link href="/2020/09/03/%E6%9C%AC%E5%8F%B7%E9%A1%BB%E7%9F%A5/"/>
      <url>/2020/09/03/%E6%9C%AC%E5%8F%B7%E9%A1%BB%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>下面是在观看本号内容前的一些须知，还请您花费两分钟时间观看一下。</p><h2 id="关于文章更新频次"><a href="#关于文章更新频次" class="headerlink" title="关于文章更新频次"></a>关于文章更新频次</h2><blockquote><p>我认为只有更新过的技术文章，才会体现出作者对这篇作品的重视态度和诚意。</p></blockquote><p>基于这个概念，<strong>本公众号内所有文章都会不定时更新，取决于文章内容是否会改变、是否抓到了文章中的 Bug 等。</strong>对我来说只有下方各位真挚的留言有收藏意义，而点击、在看、赞这类都如过眼云烟，能给各位提供有价值的分享才是我的初心。<br>所以当诸位发现某些老文突然冠以“第 N 版”诈尸出现时请勿奇怪，可打开文章看看开头我的更新之处在哪里。</p><h2 id="关于本号文章的组织结构"><a href="#关于本号文章的组织结构" class="headerlink" title="关于本号文章的组织结构"></a>关于本号文章的组织结构</h2><p><strong>有结构的知识分享无比重要。</strong><br>目前来说，建议诸位通过公众号主菜单的历史文章进行文章查找。<br>本公众号内所有文章均以使用“话题”功能进行整理，等过一阵我会用一篇专门的整理文章来取代历史文章，通过“话题”功能把整理好的文章结构呈现给大家。</p><h2 id="更优的阅读方案"><a href="#更优的阅读方案" class="headerlink" title="更优的阅读方案"></a>更优的阅读方案</h2><p>以后涉及代码类的文章我会可能在 GitHub 上也建立一份，以提供更优秀的阅读和传播方案。<br>本人的个人博客比较混乱，待完善完毕后也会向诸位开放。</p><h2 id="关于转载"><a href="#关于转载" class="headerlink" title="关于转载"></a>关于转载</h2><p>如需转载，请对公众号直接发消息，我看到后会给与回复。</p><h2 id="关于打赏"><a href="#关于打赏" class="headerlink" title="关于打赏"></a>关于打赏</h2><p>人生苦短，世事无常，能通过技术分享的文字与诸君相识是一种缘分。我把打赏金额默认高于50的额度全部去掉了，技术分享遵循开源精神，不求赚取大额钱财。<br>若是诸位看到对自己有帮助的文章，愿意请我喝杯咖啡，那从瓶装咖啡到星巴克我都没问题。：）<br>不请亦无妨，千万不要在意这些细节，能够分享对大家有用的研究我很开心，您的阅读和收获才是对我最大的鼓励​。<br><strong>感谢诸位。</strong></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>浅谈阅读路线，以及阅读和做笔记的方法</title>
      <link href="/2020/09/02/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B9%A6%E4%BB%A5%E5%8F%8A%E6%80%8E%E4%B9%88%E8%AF%BB/"/>
      <url>/2020/09/02/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B9%A6%E4%BB%A5%E5%8F%8A%E6%80%8E%E4%B9%88%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>今天分享一下之前所列书单的推荐阅读路线。其实对这份书单来说，尤其是经过我重构后的第二版，本身就已经具有良好的可阅读及可选择性。但因为后台收到了一些朋友的询问，想咨询下学习路线推荐。为此，写一篇小文聊聊这个问题，顺便简单谈谈读书之道。因为这种文章技术含量不高，故在第二版书单推送时放在头条下方，以免有水文章之嫌。<br>但是互联网行业的技术日新月异，书籍的时效性是否能跟得上谁也说不准。文档和实践远比书籍重要，但书籍被整理后的知识密度也不可小视，这部分怎么取舍就还靠大家自己权衡了。</p><blockquote><p>核心原则：</p><ul><li>对英文不好的同学来说，<strong>谨遵 i + 1 原则</strong>。不要一口吃个胖子上来就对着原版书和英文文档开啃，评估好自己的英文水平再决定材料选择。</li><li>母语学习效率永远高于外语学习，除非对英文水平有信心，不然<strong>请尽量优先选择材料的中文版本</strong>。学有余力后，再对照英文原版或英文新版查漏补缺。</li><li>所有的领域都有入门或导论类书籍，找一本好的看完，其余的同类书通过跳读，查漏补缺即可，<strong>对任何书都一个字不差的阅读是最低效的阅读</strong>。</li><li>学习有方法，读书有方法，记笔记也有方法。方法无好坏，捕鼠无孬猫，选择适合自己的才最重要。</li></ul></blockquote><h2 id="浅谈阅读路线的选择"><a href="#浅谈阅读路线的选择" class="headerlink" title="浅谈阅读路线的选择"></a>浅谈阅读路线的选择</h2><p>对于图书推荐，主要基于书籍内容、阅读难易度、资料时效性的综合考量。</p><h3 id="1-1-游戏音频入门"><a href="#1-1-游戏音频入门" class="headerlink" title="1.1 游戏音频入门"></a>1.1 游戏音频入门</h3><p>如果对游戏音频所知甚少，想要入行，在“游戏音频导论”栏目中找几本适合自己的看一下。我个人建议优先阅读这些：</p><ul><li>《游戏音频完全指南（第2版）》</li><li><em>The Game Audio Strategy Guide: A Practical Course</em></li><li><em>Principles of Game Audio and Sound Design</em></li><li><em>The Bible of Getting a Job in Game Audio, 2020 Edition</em></li></ul><p><strong>最后这本关于找工作的“书”，本质上说是一份整理过后的文档，但它的详细和时效性非常好，是不可多得的入行好资料。</strong><br>成为能够独当一面的游戏音频设计师要学的远远不止这些，建议在书中快速汲取信息后画出自己想要发展的技能树，按照技能树进行下一步的阅读或回溯补充。</p><h3 id="1-2-精进声音设计"><a href="#1-2-精进声音设计" class="headerlink" title="1.2 精进声音设计"></a>1.2 精进声音设计</h3><p>鉴于不是所有公司都有完全从0开始的声音资源制作条件（如大量的引入实录、Foley、合成器），从阅读角度来说可以分成两部分。</p><h4 id="如果是为了精进音效库声音设计的审美水平的话："><a href="#如果是为了精进音效库声音设计的审美水平的话：" class="headerlink" title="如果是为了精进音效库声音设计的审美水平的话："></a>如果是为了精进音效库声音设计的审美水平的话：</h4><ul><li>《审美空间延伸与拓展: 电影声音艺术理论》</li><li>《声音设计: 电影中语言，音乐和音响的表现（第2版）》</li><li>《视听：幻觉的构建》</li><li>《动画声音设计》</li><li><em>Sound Design and Science Fiction</em></li><li>我的文章</li></ul><h4 id="如果是为了精进合成器实用技术的话："><a href="#如果是为了精进合成器实用技术的话：" class="headerlink" title="如果是为了精进合成器实用技术的话："></a>如果是为了精进合成器实用技术的话：</h4><ul><li>《声音合成与采样技术（第3版）》</li><li>《自己动手做声音: 声音合成与制作基础》</li><li><em>Creating Sounds from Scratch: A Practical Guide to Music Synthesis for Producers and Composers</em></li><li><em>Welsh’s Synthesizer Cookbook: Synthesizer Programming, Sound Analysis, and Universal Patch Book 1、2</em><h3 id="1-3-技术音频入门"><a href="#1-3-技术音频入门" class="headerlink" title="1.3 技术音频入门"></a>1.3 技术音频入门</h3>技术音频需要学的东西太多了，我自己也在努力学习中。感觉除了导论类书籍之外，引擎、编程等大量东西需要学，这里只粗浅的列出我书单中我认为值得推荐的给大家。</li><li>《游戏引擎架构》</li><li><em>Game Audio Programming: Principles and Practices 1、2、3</em></li><li><em>Game Audio: Tales of a Technical Sound Designer 1、2</em></li><li><em>Game Audio Development with Unity 5.X</em></li><li><em>Game Audio Implementation: A Practical Guide Using the Unreal Engine</em></li><li><em>Game Audio with FMOD and Unity</em></li></ul><h2 id="如何阅读"><a href="#如何阅读" class="headerlink" title="如何阅读"></a>如何阅读</h2><p>阅读方法论可以说是遍地开花了，但还是推荐最经典的那本《如何阅读一本书》，在多年前的大学时期这本书对我有指导性意义。除此之外，别的阅读类书籍我并不是特别推荐，大多都是二次加工或融合几种不同方法的读物，非常无趣。<br>其实对于阅读，还是要想清楚你的目的。技术类书籍的目的无疑就是一点，获取信息整合到头脑当中，所以如何做笔记和提炼书籍内容才是最重要的。</p><h2 id="如何做笔记"><a href="#如何做笔记" class="headerlink" title="如何做笔记"></a>如何做笔记</h2><p>关于如何做笔记，其实研究明白思维导图和一些衍生类软件就足矣了，建议多看看不同专业的阅读笔记整理方法，跨行业的经验往往有着碾压性的效果。<br>如果要简单谈一下的话，那就是阅读的同时粗摘录，阅读结束后精细整理，再整理再整理，把知识变成主题阅读一样的一张网。这样无论是复习还是当做自己的知识库，这本书才是真正的为你所用了。对文档、视频教程来说亦是如此，看完就扔，扔了就忘，倒不如不看。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>人人都能用 WAAPI（一）概述</title>
      <link href="/2020/09/01/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/09/01/WAAPI%20%E4%B8%80%E6%96%87%E9%80%9A%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>去年下半年我接触到了 WAAPI（Wwise Authoring API），作为头脑不怎么灵光的非专业程序员，看到 WAMP、JSON 等陌生概念直犯晕。毕竟除了官方文档，只有少数的分享视频、文章和项目可参考。因为不太好意思麻烦别人，只好自己在这一年中断断续续的闷头尝试，踩了不少坑。<br>引用 Linus 的一句名言：</p><blockquote><p>In open source, we feel strongly that to really do something well, you have to get a lot of people involved.  — Linus Torvalds</p></blockquote><p><strong>思想只有被传播才能体现价值</strong>，为了体现开源精神，决定分享一系列 WAAPI 指南给大家。《人人都能用 WAAPI》系列文则更贴近对官方文档的补充，会更加友好且详细。<br>对初学者友好不代表从零讲起，人人都能用 WAAPI 只是代表大家都有潜力去掌握这门优秀的技能。老规矩，谈一下前置知识。<strong>因为个人习惯使用 Python，所以前置知识只讨论 Python。你也可以使用支持的其他语言来进行 API 调用（使用 C# 调用 WAAPI 其实也很简单）。</strong></p><blockquote><p>本系列文章阅读需要的前置知识：</p><ul><li>会配置开发环境，掌握 Python、Anaconda、pip、VS Code、PyCharm 等的安装使用。</li><li>掌握简单的 Python 语法。</li><li>对 Wwise 功能有较全面的认知，WAAPI 涉及的功能比较广。</li><li>对现有 Wwise 工作流有优化的构思。</li><li>对思维导图有些许认知。</li></ul></blockquote><p>todo:<br>JSON含义及怎么看<br>WAAPI 概览</p><h2 id="为什么要用-WAAPI？"><a href="#为什么要用-WAAPI？" class="headerlink" title="为什么要用 WAAPI？"></a>为什么要用 WAAPI？</h2><h3 id="1-1-请问你在用-Wwise-时怀疑过以下人生吗？"><a href="#1-1-请问你在用-Wwise-时怀疑过以下人生吗？" class="headerlink" title="1.1. 请问你在用 Wwise 时怀疑过以下人生吗？"></a>1.1. 请问你在用 Wwise 时怀疑过以下人生吗？</h3><ul><li>能不能少一些点击和拖拽操作？？</li><li>成百上千（3A 项目上万也正常）的资源导入后做播放规则想死怎么办？？</li><li>使用 Game Sync、Event、SoundBank 时能不能智能连接逻辑？？</li><li>不能把 DAW 和 Wwise 联动吗？？</li><li>如何联动 CI 系统优化持续集成管线？？</li><li>etc.</li></ul><h3 id="1-2-WAAPI-的目的：解放繁琐的工作流"><a href="#1-2-WAAPI-的目的：解放繁琐的工作流" class="headerlink" title="1.2. WAAPI 的目的：解放繁琐的工作流"></a>1.2. WAAPI 的目的：解放繁琐的工作流</h3><p>如果你有上面的烦恼，WAAPI 对你无疑是必备利器。<br>作为 Wwise 2017.1 中的重要的功能补充，WAAPI 诞生就被赋予了解决一切繁琐的使命。<br>从简单操作中的获取工程信息、导入音频文件、设定容器层级，到声音引擎级的发送事件、设定 Game Sync 等操作，WAAPI 均可完成。是 Wwise 音频设计师工作流改进中的必备一环，<strong>利用好 WAAPI，能够节省大量时间，让声音设计师有更多精力放在艺术本身。</strong><br>在本文发布的当下，可能仍有公司未对技术音频（Game Audio Programmer / Technical Sound Designer）这个职位进行配备。如果碰巧你是这些公司的雇员，本文会对你很有帮助。<strong>对工作中重复和可优化的步骤进行不断优化，这才是智者的工作模式。与其等待戈多，不如自己动手。</strong></p><h3 id="1-3-官方的资料不够全吗？"><a href="#1-3-官方的资料不够全吗？" class="headerlink" title="1.3. 官方的资料不够全吗？"></a>1.3. 官方的资料不够全吗？</h3><p>Wwise 的官方文档是目前所有音频中间件中内容最完善，且本地化做的最好的一个。但文档中关于 WAAPI 的内容，对阅读对象的要求<strong>更偏向是有一定技术背景的人</strong>，存在些许门槛也是必然的。这系列文章的写作目的正是针对这一点，希望能对官网文档做出有用的补充，<br>官方博客中也有关于 WAAPI 好文，学有余力的朋友可以抽空翻阅。</p><h2 id="妙用思维导图整理-WAAPI"><a href="#妙用思维导图整理-WAAPI" class="headerlink" title="妙用思维导图整理 WAAPI"></a>妙用思维导图整理 WAAPI</h2><h3 id="2-1-通过导图理清-WAAPI-脉络"><a href="#2-1-通过导图理清-WAAPI-脉络" class="headerlink" title="2.1 通过导图理清 WAAPI 脉络"></a>2.1 通过导图理清 WAAPI 脉络</h3><p>思维导图作为一个重要的学习工具，在长达七八年中曾承载过我无数的发散思维。<br>如下图所示，<strong> WAAPI 这种点语法套大饼形式的 API（例如重要的查询 API 为 ak.wwise.core.object.get）在文档中检索时非常不便。</strong><br><img src="/images/%E7%B9%81%E7%90%90%E7%9A%84API.png" alt="繁琐的API"></p><p>那么有什么办法能够优雅的解决这个需求呢?<br>Bingo！思维导图一下出现在我脑中。<br>我通过对 WAAPI 进行逻辑归纳并整理为导图，以 ak.wwise.core.object.get 为例：</p><ol><li>忽略 ak（复用时可把 ak 视为等同为导图中心），分别把其拆为 wwise.core - object - get 形式的节点。</li><li>在此基础上，将 API 按功能重新排布顺序，并使用外框整理同类型的功能。</li></ol><p><img src="/images/%E5%AF%BC%E5%9B%BE1.png" alt="导图1"><br>导图概览</p><p><img src="/images/%E5%AF%BC%E5%9B%BE2.png" alt="导图2"><br>局部样例</p><h3 id="2-2-导入知识库进行知识完备"><a href="#2-2-导入知识库进行知识完备" class="headerlink" title="2.2. 导入知识库进行知识完备"></a>2.2. 导入知识库进行知识完备</h3><p>在此基础上就已完成 WAAPI 逻辑体系的初级构建，随后导入 MarginNote 3，在我的 Wwise 知识库中进行相关完善。<br><img src="/images/%E5%AF%BC%E5%9B%BE3.png" alt="导图3"><br>MN3 中的知识完备版</p><p>至此，WAAPI 的整体脉络清晰的出现在我眼前。对于 API 这种工具性极强的存在，用合理逻辑建立的“武器库”是高效利用的前提。这也是更最符合我自己理解记忆的方法，大家亦可根据自己的思维习惯选择适合自己的整理方法。<br><strong>导图我不会直接分享，</strong>原因很简单：看我的描述相信大家都能做出一样的导图，而知识库版本导图，这系列文章正是基于它的展开（会比导图详细的多），分享并没有什么意义。<br>相信有心的同学也会根据自己的想法重做一次，用什么思路无所谓。幕布和 XMind 这种导图工具或者笔记类软件均可，<strong>重点是亲自上手实现自己的版本，否则毫无意义。</strong></p><h2 id="系列文章架构"><a href="#系列文章架构" class="headerlink" title="系列文章架构"></a>系列文章架构</h2><p>了解我的 WAAPI 分类方法后，我们聊聊这系列文章的编写架构。<br>因 WAAPI 功能分为 Functions（执行）与 Topics（订阅）两种，两者的区别会在下面的章节中讲解。我会以这两者为主干，对下属分支进行拆分编写（注：我仍然省略了开头的“ak.“） 。<br>按照字数来划分，预计架构如下：</p><ol><li>概述</li><li>wwise.core（2-4为 Functions 类）</li><li>wwise.ui, wwise.debug, wwise.waapi</li><li>soundengine</li><li>wwise.core, wwise.debug, wwise.ui（Topics 类）</li><li>完整实例</li></ol><h2 id="WAAPI-基础"><a href="#WAAPI-基础" class="headerlink" title="WAAPI 基础"></a>WAAPI 基础</h2><h3 id="4-1-什么是-WAAPI？"><a href="#4-1-什么是-WAAPI？" class="headerlink" title="4.1. 什么是 WAAPI？"></a>4.1. 什么是 WAAPI？</h3><p>WAAPI（Wwise Authoring API）作为 Wwise 的重要组件，通过调用 API 即可让 Wwise 直接执行大量操作，而不必通过传统方式操作鼠标键盘达成同样目的。<br>它的可控制范围很广，从 Wwise 的界面层级控制（视图、选项、命令）到核心功能控制（例如快速添加音频文件），到声音引擎层级的功能（RTPC Value、Post Event 等）均可完成。<br>文档中关于 WAAPI 的简介：<br><a href="https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi.html" target="_blank" rel="noopener">https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi.html</a></p><h3 id="4-2-WAAPI-支持的语言类型和使用方式"><a href="#4-2-WAAPI-支持的语言类型和使用方式" class="headerlink" title="4.2. WAAPI 支持的语言类型和使用方式"></a>4.2. WAAPI 支持的语言类型和使用方式</h3><h4 id="可用的编程语言"><a href="#可用的编程语言" class="headerlink" title="可用的编程语言"></a>可用的编程语言</h4><p>WAAPI 可通过 C++、C#、JavaScript、Python 等多种语言调用，对于初学者来说后三者都比较简单（其中 Python 需 3.6+，2比较麻烦）。如果没有在插件中调用 WAAPI 的需求，可不考虑使用 C++。</p><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>WAAPI 提供三种调用方式：WAMP、HTTP POST、Wwise 插件中调用。<br>通常情况下我们只会使用 WAMP，因为只有这种方式才能支持执行和订阅两种类型的使用方法。<br>那么什么是 WAMP 呢？<br>这是一种通过 WebSocket 进行通信的方式。如果对网络通信原理没有了解的话，可以把它简单理解成是通过网络传输信息的方法，它需要 IP 地址和端口来满足通讯需求，所以 WAAPI 的使用过程中需要提供这两个参数。<br>当我们的程序通过 WAMP 和 Wwise 建立连接后，才能执行之后所需的操作。<br>官方文档中关于调用方式的介绍：<br><a href="https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi_gettingstarted.html" target="_blank" rel="noopener">https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi_gettingstarted.html</a></p><h3 id="4-3-配置开发环境"><a href="#4-3-配置开发环境" class="headerlink" title="4.3. 配置开发环境"></a>4.3. 配置开发环境</h3><blockquote><p>出于个人的写作习惯，开发环境这种重复造轮子的事情我不会再写一次。但会分享给大家较好的教程连接，请大家根据文内介绍的方法进行开发环境配置，顺便感谢文中作者的无私分享！</p></blockquote><p><strong>因为 Conda 中并没有 WAAPI 所需的 waapi-client 包，所以初学者懒得折腾 Anaconda 的话，建议直接用 pip 安装 waapi-client。</strong><br>如果跟我一样使用 Anaconda 管理开发环境，<strong>我推荐使用官方文档中的方法安装 Conda 中没收录的包。即先在环境中安装 pip ，再通过 Conda 里的 pip 管理 Conda 中没有的包。</strong>此部分文档我在下方有附上链接。<br>（初学者请不要看这句话）至于 <code>conda skeleton pypi package</code> 再 <code>conda build package</code> 这种 Conda 装 pypi 的方法我没试过，就不在这里讨论了。</p><h4 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h4><p><a href="https://segmentfault.com/a/1190000022797661" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022797661</a></p><h4 id="配置-Anaconda-并在本地环境中通过-pip-添加-waapi-client"><a href="#配置-Anaconda-并在本地环境中通过-pip-添加-waapi-client" class="headerlink" title="配置 Anaconda 并在本地环境中通过 pip 添加 waapi-client"></a>配置 Anaconda 并在本地环境中通过 pip 添加 waapi-client</h4><p><a href="https://zhuanlan.zhihu.com/p/25198543" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25198543</a><br><a href="https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-pkgs.html#installing-non-conda-packages" target="_blank" rel="noopener">https://conda.io/projects/conda/en/latest/user-guide/tasks/manage-pkgs.html#installing-non-conda-packages</a><br><strong>注意：使用 pip 的同学可直接在 Python 3 环境下执行 <code>pip install waapi-client</code></strong></p><h4 id="配置-VS-Code-开发环境"><a href="#配置-VS-Code-开发环境" class="headerlink" title="配置 VS Code 开发环境"></a>配置 VS Code 开发环境</h4><p><a href="https://zhuanlan.zhihu.com/p/30324113" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30324113</a></p><h4 id="在-Wwise-中开启-WAAPI-支持"><a href="#在-Wwise-中开启-WAAPI-支持" class="headerlink" title="在 Wwise 中开启 WAAPI 支持"></a>在 Wwise 中开启 WAAPI 支持</h4><p><a href="https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi_prepare.html" target="_blank" rel="noopener">https://www.audiokinetic.com/zh/library/edge/?source=SDK&amp;id=waapi_prepare.html</a></p><h3 id="4-4-Functions（执行类）与-Topics（订阅类）的区别"><a href="#4-4-Functions（执行类）与-Topics（订阅类）的区别" class="headerlink" title="4.4. Functions（执行类）与 Topics（订阅类）的区别"></a>4.4. Functions（执行类）与 Topics（订阅类）的区别</h3><blockquote><p>这里“执行类”和“订阅类”属于个人的称呼习惯，“执行类”代表功能为执行某些操作的 API，“订阅类”为执行后等待某些结果返回的 API。在 Wwise 官方文档中的对应术语为“远程调用”和“发布&amp;订阅”。</p></blockquote><p>Functions（执行类）：<br>与名字相同，其中所有的 API 均为执行具体的操作。<br>通过代码调用某个 API 后，会执行一次对应的操作。WAAPI 的三种使用方式中都可完成对“执行类”接口的调用，但 HTTP POST 方式下不具有最佳性能。<br>Topics（订阅类）：<br>当调用“订阅类”接口后，程序会等待 Wwise 中对应的动作发生。如果订阅了一个对象创建的动作，那只有动作被执行后才会收到发回的信息。这种调用方法只有 WAMP 能够做到，其余两种使用方法无法完成。</p><h3 id="4-5-什么是-JSON-及怎么读-WAAPI-文档？"><a href="#4-5-什么是-JSON-及怎么读-WAAPI-文档？" class="headerlink" title="4.5. 什么是 JSON 及怎么读 WAAPI 文档？"></a>4.5. 什么是 JSON 及怎么读 WAAPI 文档？</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>非专业程序员出身的人（例如我）第一次看到 WAAPI 的参数时都会奇怪，JSON 到底是什么东西？<br><strong>JSON（JavaScript Object Notation）是一种轻量的数据交换格式，用独立的文本格式在编程语言外存储和表示数据，本质上就是被格式化的字符串。</strong>如果有同学熟悉 XML 的格式，看到 JSON 应该比较眼熟。没接触过 JSON 也不用怕，下面我们一起把 JSON 格式化成符合我们理解的参数列表。</p><h4 id="以-ak-wwise-core-object-create-为例详解-Arguments-和-Result-的含义"><a href="#以-ak-wwise-core-object-create-为例详解-Arguments-和-Result-的含义" class="headerlink" title="以 ak.wwise.core.object.create 为例详解 Arguments 和 Result 的含义"></a>以 <code>ak.wwise.core.object.create</code> 为例详解 Arguments 和 Result 的含义</h4><p>我们看一下 <code>create</code> 的文档，会发现网页中存在两个表格。<br><img src="/images/%E5%8F%82%E6%95%B01.png" alt="参数1"><br>文档页面中的 Arguments 表格<br><img src="/images/%E7%BB%93%E6%9E%9C1-1.png" alt="结果1"><br>文档页面中的 Result 表格<br>首先请大家看清表格中三列的含义，分别代表名字、值类型、描述，这些将是我们接下来讲解的基础。<br>这两个表中，Arguments（参数）是函数调用时要传入的参数，Result（结果）则是它完成远程调用后返回的结果。请注意，<strong>在 Arguments（参数）底部备注了星号代表必须提供的参数，这部分参数为必填，不带星号的部分是根据所需选填。</strong><br>我们先看 Arguments 表格，针对其中三种参数模式进行讲解：</p><ol><li><code>name *</code> 行只需要一个 string（字符串）作为参数用来定义名字，但为什么 <code>parent *</code> 却有四行参数？很简单，请看 <code>parent *</code> 的第一行表格，发现是 <code>any of:</code>，这就代表其实我们可选用下面三种参数类型的任意一种来定义参数。我们仔细观察，果然下面三行分别为父级的名字（需全局唯一）、GUID、父级完整路径。</li><li><code>notes</code> 行没有星号，这是一个非必须参数，由此可知在使用 <code>create</code> 时我们可根据需求决定是否传入笔记。</li><li><code>children</code> 可能让大家产生疑问，为什么表示方法和前面不是一个模式。其实因为它是一个数组，需要传入的参数要写在数组内。所以必须的两项参数 <code>children[...].type *</code> 和 <code>children[...].name *</code> 中的 type 和 name 实际上是要写在数组当中的。</li></ol><p>对于 Result（结果）表来说，一般只有在看不懂返回值的时候才需要看，绝大多数情况下只要你能弄明白传入的 Arguments，一般都能猜出来会有什么返回值。<br>比如我们通过 <code>create</code> 创建了一些对象，根据自然逻辑来判断， Wwise 应该会返回已创建的对象名称、GUID、层级信息。毕竟如果创建不成功肯定会报错，所以创建成功后应该返回刚创建的对象才符合逻辑。观察 Result 表后发现确实如此，的确是这三条返回值。</p><h5 id="详解-JSON-格式格式化技巧"><a href="#详解-JSON-格式格式化技巧" class="headerlink" title="详解 JSON 格式格式化技巧"></a>详解 JSON 格式格式化技巧</h5><p>对于 WAAPI 这种需传入较多参数的需求，把所有参数写在函数的括号里会非常不方便，而且不具有 JSON 的通用性，所以 WAAPI 参数的传入使用 JSON 来进行定义。为了方便大家理解，我们把 JSON 彻底拆开讲解一下。<br>下面是 <code>create</code> 的传入参数语法。<br><img src="/images/%E5%8F%82%E6%95%B02.png" alt="参数2"></p><p>哪怕不理解 JSON，应该也可能看出来这是一种数据传输模式，其中有很多参数样的东西。<strong>但是很明显，这一串东西的可读性非常之差。</strong>难道我们只能返回去看上面提到的表格吗？看起来那个的可读性也不是特别好。<br>并非如此，对于 JSON 格式数据我们可以通过工具进行格式化，这样能够有效提升可读性。<br>接下来我们使用工具对齐进行格式化，我个人习惯使用 JSON Editor（<a href="https://jsoneditoronline.org/）" target="_blank" rel="noopener">https://jsoneditoronline.org/）</a><br>还记得上图混乱的格式吗？我们用 JSON Editor 处理一下，即可得到很清晰的格式。<br><img src="/images/JSON1.png" alt="JSON1"></p><p>Arguments 经过格式化后，我们可清晰可见 required 中注明了所需参数，properties 中提供了各种参数的类型和描述。如果你仔细观察，会发现下面似乎还有两个属性。其中 <code>localDefinitions</code> 里实际就是上面提过的 <code>children</code> 里的定义，作为子类放进了这里。而 <code>patternProperties</code> 是 @propertyName 法设置创建对象属性时用的。</p><p><img src="/images/JSON2.png" alt="JSON2"></p><p>Result 经过格式化后也是同理，我们可见他默认的三个返回值、GUID、创建的子对象、名称。<br>在经过了格式化后，JSON 无论是作为参数还是返回值来说都更易读了。<strong>想要清晰的理解 JSON 和参数之间对应的关系，还是需要学习一些属性和 JSON 的对应关系的</strong>。最简单的方法是参考 Wwise Authoring API Examples Index 其中的例子，不过其中的例子比较简约，建议读透我的描述再去阅读。<br>我们看个例子，比如官方文档中提到创建一个 Random Container 并且其中有两个 Sound SFX 的例子，只给了 Arguments，实际上我们要这么使用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 示例代码里提供的 Arguments</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"parent"</span>: <span class="string">"&#123;7A12D08F-B0D9-4403-9EFA-2E6338C197C1&#125;"</span>, </span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"RandomSequenceContainer"</span>, </span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Boom"</span>, </span><br><span class="line">    <span class="string">"@RandomOrSequence"</span>: <span class="number">1</span>, </span><br><span class="line">    <span class="string">"children"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"Sound"</span>, </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"A"</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"Sound"</span>, </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"B"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 真实应用情况下的 Arguments</span></span><br><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> WaapiClient() <span class="keyword">as</span> client:</span><br><span class="line">        <span class="comment"># 把 JSON 格式的 Arguments 赋值给 args</span></span><br><span class="line">        args = &#123;</span><br><span class="line">            <span class="string">"parent"</span>: <span class="string">"&#123;7A12D08F-B0D9-4403-9EFA-2E6338C197C1&#125;"</span>, </span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"RandomSequenceContainer"</span>, </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"Boom"</span>, </span><br><span class="line">            <span class="string">"@RandomOrSequence"</span>: <span class="number">1</span>, </span><br><span class="line">            <span class="string">"children"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"Sound"</span>, </span><br><span class="line">                    <span class="string">"name"</span>: <span class="string">"A"</span></span><br><span class="line">                &#125;, </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"type"</span>: <span class="string">"Sound"</span>, </span><br><span class="line">                    <span class="string">"name"</span>: <span class="string">"B"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 执行远程调用，第一个参数为 API 名，第二个为传入的 JSON 参数</span></span><br><span class="line">        client.call(<span class="string">"ak.wwise.core.object.create"</span>, args)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">    print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 3. 远程调用结束后控制台返回的结果，包括父级 GUID、父级容器名、子级 GUID、子级名称</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"&#123;66666666-7777-8888-9999-AAAAAAAAAAAA&#125;"</span>, </span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Boom"</span>, </span><br><span class="line">    <span class="string">"children"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"id"</span>: <span class="string">"&#123;46813545-2168-3547-8328-681AB678D6F5&#125;"</span>, </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"A"</span></span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"id"</span>: <span class="string">"&#123;68465134-2548-2377-3541-321354318ABD&#125;"</span>, </span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"B"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="如何在-Python-中编解码-JSON-参数？"><a href="#如何在-Python-中编解码-JSON-参数？" class="headerlink" title="如何在 Python 中编解码 JSON 参数？"></a>如何在 Python 中编解码 JSON 参数？</h5><p>除了学明白参数后直接改写传入的 JSON 块内的参数外，你也可以使用 Python 3 的 <code>json</code> 模块来进行 JSON 的编解码。之所以要这样操作，是可以让你通过代码从用户处获取需求，并将需求先保存为 Python 的数据结构，再转为 JSON 格式。<br><img src="/images/%E5%AF%B9%E7%85%A7%E8%A1%A8.png" alt="对照表"><br>Python 和 JSON 类型对照表<br>由上表我们可以发现，虽然看起来 JSON 是个字典，但实际上是 JSON 自己的数据结构。在 Python 中看起来是最外面的字典，在 JSON 中是对象。而列表和元组被转为了数组，布尔值也要从大写变小写（None 则变成 null）等。<br>关于 <code>json</code> 模块编解码的使用只需掌握 <code>json.dumps(python_obj)</code> 和 <code>json.loads(json_str)</code> 及少量参数即可，请参考 Python 文档。</p><h3 id="4-5-来一杯-Hello-Wwise！"><a href="#4-5-来一杯-Hello-Wwise！" class="headerlink" title="4.5. 来一杯 Hello Wwise！"></a>4.5. 来一杯 Hello Wwise！</h3><p>说了这么多理论，现在“麻烦给我的爱人来一杯 Hello Wwise 吧！”</p><h4 id="确定使用哪个-API"><a href="#确定使用哪个-API" class="headerlink" title="确定使用哪个 API"></a>确定使用哪个 API</h4><p>很明显，对于 Hello World 这种需求应该使用 Functions（执行类）完成。<br>通过寻找，我们发现一条美妙的 <code>ak.soundengine.postMsgMonitor</code> 可以完成需求。</p><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><p>为了方便理解，我直接在代码里写上详细的注释，请大家对照每行的代码来阅读。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 的异常处理 try…except… 语句，为 WAAPI 连接不上的情况增加了错误输出。</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 通过默认的地址连接 Wwise，如果想连接本地不同的 Wwise 可在这里修改对应的端口</span></span><br><span class="line">    <span class="keyword">with</span> WaapiClient() <span class="keyword">as</span> client:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># WAAPI 传入和传回的参数都使用 JSON 格式，我们使用字典定义一段要打印出的信息为 "Hello Wwise!"</span></span><br><span class="line">        print_args = &#123;</span><br><span class="line">            <span class="string">"message"</span>: <span class="string">"Hello Wwise!"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 远程调用 ak.soundengine.postMsgMonitor，并传入刚才设定好的参数</span></span><br><span class="line">        client.call(<span class="string">"ak.soundengine.postMsgMonitor"</span>, print_args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">    print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br></pre></td></tr></table></figure></p><h4 id="执行效果"><a href="#执行效果" class="headerlink" title="执行效果"></a>执行效果</h4><p>运行脚本之前记住点击 Start Capture 来让 Profiler 开始采集信息。当脚本运行后，我们可获得以下信息：<br><img src="/images/%E7%BB%93%E6%9E%9C1.png" alt="结果1"><br>在 Logs 的 WAAPI 选项卡中，可看到产生了 WAMP 类型连接。</p><p><img src="/images/%E7%BB%93%E6%9E%9C2.png" alt="结果2"><code>children</code><br>在 Profiler 中可看到打印出的信息 “Hello Wwise!”</p><h2 id="WAAPI-两种应用（注释写到每一行）"><a href="#WAAPI-两种应用（注释写到每一行）" class="headerlink" title="WAAPI 两种应用（注释写到每一行）"></a>WAAPI 两种应用（注释写到每一行）</h2><h3 id="5-1-Functions（执行类）示例"><a href="#5-1-Functions（执行类）示例" class="headerlink" title="5.1. Functions（执行类）示例"></a>5.1. Functions（执行类）示例</h3><h4 id="不带参数"><a href="#不带参数" class="headerlink" title="不带参数"></a>不带参数</h4><p>通过 getInfo 功能获得当前工程的信息<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 略</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 通过默认的地址连接 Wwise</span></span><br><span class="line">    <span class="keyword">with</span> WaapiClient() <span class="keyword">as</span> client:</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 调用 ak.wwise.core.getInfo 来获取 Wwise 的全局信息并存到 result 中</span></span><br><span class="line">        result = client.call(<span class="string">"ak.wwise.core.getInfo"</span>)</span><br><span class="line">        <span class="comment"># 为了避免 print 单行打印，需通过 pprint 来打印刚得到 JSON 结果</span></span><br><span class="line">        pprint(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">    print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br></pre></td></tr></table></figure></p><p>代码执行后结果如下，如所希望的返回了工程信息<br><img src="/images/%E7%BB%93%E6%9E%9C3-1.png" alt="结果3"></p><h4 id="带参数"><a href="#带参数" class="headerlink" title="带参数"></a>带参数</h4><p>请参考“来一杯 Hello Wwise！”的例子</p><h3 id="5-2-Topics（订阅类）"><a href="#5-2-Topics（订阅类）" class="headerlink" title="5.2. Topics（订阅类）"></a>5.2. Topics（订阅类）</h3><p>通过 ak.wwise.core.object.nameChanged 功能订阅工程中对象名称被修改时的信息，当有对象被修改时返回新、旧名字及设定的返回值类型（本例中为 type）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> waapi <span class="keyword">import</span> WaapiClient, CannotConnectToWaapiException</span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 的异常处理 try…except…else… 语句</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    client = WaapiClient()</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> CannotConnectToWaapiException:</span><br><span class="line">    print(<span class="string">"Could not connect to Waapi: Is Wwise running and Wwise Authoring API enabled?"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 建立 on_name_changed() 准备在订阅中作为回调函数，用来接收字典形式的返回参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_name_changed</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 获取对象类型</span></span><br><span class="line">        obj_type = kwargs.get(<span class="string">"object"</span>, &#123;&#125;).get(<span class="string">"type"</span>)</span><br><span class="line">        <span class="comment"># 获取之前的名字</span></span><br><span class="line">        old_name = kwargs.get(<span class="string">"oldName"</span>)</span><br><span class="line">        <span class="comment"># 获取新名字</span></span><br><span class="line">        new_name = kwargs.get(<span class="string">"newName"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打印信息，告知用户XXX类型的对象从 A 改名到了 B</span></span><br><span class="line">        print(<span class="string">"Object '&#123;&#125;' (of type '&#123;&#125;') was renamed to '&#123;&#125;'\n"</span>.format(old_name, obj_type, new_name))</span><br><span class="line">        <span class="comment"># 检测完成后断开 WAMP 连接，当然，要是想一直监控信息也可以不断开</span></span><br><span class="line">        client.disconnect()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 订阅所需主题，传入回调函数，使用选项 type 以让名称修改时传回被修改的对象类型</span></span><br><span class="line">    handler = client.subscribe(<span class="string">"ak.wwise.core.object.nameChanged"</span>, on_name_changed, &#123;<span class="string">"return"</span>: [<span class="string">"type"</span>]&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印信息，提醒用户已经订阅了 ak.wwise.core.object.nameChanged 并建议用户执行重命名操作以验证脚本功能</span></span><br><span class="line">    print(<span class="string">"Subscribed 'ak.wwise.core.object.nameChanged', rename an object in Wwise"</span>)</span><br></pre></td></tr></table></figure></p><p>代码执行后结果如下，如所希望的告知了对象的名称变化及类型<br><img src="/images/%E7%BB%93%E6%9E%9C4.png" alt="结果4"></p><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2><p>在第二期中，会就执行类里比较重要的 wwise.core 分支进行分享。官网对于执行类的 API 大多提供了例子，但我可能会通过结合起来的小实例来进行演示，这样有便于大家更快掌握。如喜欢本文，请持续关注。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>写给声音设计师的敏捷 GUI 开发大法（二）进阶篇</title>
      <link href="/2020/08/30/PySimpleGUI%20%E7%AC%AC%E4%BA%8C%E7%AF%87/"/>
      <url>/2020/08/30/PySimpleGUI%20%E7%AC%AC%E4%BA%8C%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>在《写给声音设计师的敏捷 GUI 开发大法（一）》中，我们简单的讨论了 PySimpleGUI 作为一个快速且优雅的 GUI 开发库的优点和基础的代码规则，并且一起完成了一个实用的小程序。<br>在进阶篇中，就要深入讨论一些细节的内容了。比如第一篇文章中的布局代码到底是怎么产生作用的？和 Tkinter 等框架的区别具体是哪些？<br>这篇文会比较枯燥，我们会从原理上了解一些细节内容，其中用到很多术语，如果看到不太熟悉的词请翻阅文档或查询 Google。或许有些朋友已经去 PySimpleGUI 的官网“散文”文档中学习了一番，进阶篇的存在主要是为了照顾到没时间去看的朋友。<br>当然，如我之前所述，<strong>这系列文章也并非是文档“翻译官”</strong>。希望我写的东西作为引子，能让大家了解到这个简单且方便的框架。</p><p><em>本文目录：</em></p><ol><li>PySimpleGUI 原理</li><li>一些较为复杂的布局实现</li><li>使用 QT Designer 快速构建布局</li><li>如何阅读 PySimpleGUI 官方文档</li><li>一个完整的程序例子（与 WAAPI 联动）</li><li>接下来讲什么？</li></ol><h2 id="PySimpleGUI-原理"><a href="#PySimpleGUI-原理" class="headerlink" title="PySimpleGUI 原理"></a>PySimpleGUI 原理</h2><h2 id="一些较为复杂的布局实现"><a href="#一些较为复杂的布局实现" class="headerlink" title="一些较为复杂的布局实现"></a>一些较为复杂的布局实现</h2><h2 id="使用-QT-Designer-快速构建布局"><a href="#使用-QT-Designer-快速构建布局" class="headerlink" title="使用 QT Designer 快速构建布局"></a>使用 QT Designer 快速构建布局</h2><h2 id="如何阅读-PySimpleGUI-官方文档"><a href="#如何阅读-PySimpleGUI-官方文档" class="headerlink" title="如何阅读 PySimpleGUI 官方文档"></a>如何阅读 PySimpleGUI 官方文档</h2><h2 id="一个完整的程序例子（与-WAAPI-联动）"><a href="#一个完整的程序例子（与-WAAPI-联动）" class="headerlink" title="一个完整的程序例子（与 WAAPI 联动）"></a>一个完整的程序例子（与 WAAPI 联动）</h2><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>如何在20天内彻底搞定声音设计英文 Keyword？</title>
      <link href="/2020/08/28/%E4%B8%80%E7%AF%87%E6%96%87%E7%AA%81%E7%A0%B4%E9%9F%B3%E6%95%88%E5%8D%95%E8%AF%8D%E9%9A%9C%E7%A2%8D/"/>
      <url>/2020/08/28/%E4%B8%80%E7%AF%87%E6%96%87%E7%AA%81%E7%A0%B4%E9%9F%B3%E6%95%88%E5%8D%95%E8%AF%8D%E9%9A%9C%E7%A2%8D/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>游戏音频与声音设计书单一文发出后，有几个朋友专门找我探讨如何提升英文水平以阅读原版书或英文资料。这是一个值得讨论的话题，写一篇技术性“不那么重”的小文与大家分享一下我的心得。为了覆盖到更多朋友，故把标题定为《如何用20天搞定声音设计 Keyword》。<br>虽然标题如此，但还是会用一点篇幅谈谈英文学习的基础路线供诸君参考。在第二部分，会提供一种针对性的方法解决声音设计术语掌握不全这个难题。</p><p><em>本文目录：</em></p><ol><li>怎么学英文？<br> 1.1. 为什么要学英文？<br> 1.2. 英文学习的基本概念<br> 1.3. 学习路线推荐</li><li>20天搞定声音设计 Keyword<br> 2.1. 通过 AntConc 对商业音效库进行语料库提取<br> 2.2. 使用欧陆词典进行背诵<br> 2.3. 更重要的还是使用</li></ol><h2 id="怎么学英文？"><a href="#怎么学英文？" class="headerlink" title="怎么学英文？"></a>怎么学英文？</h2><p>这部分简单探讨了如何学好英文，直奔文章主题的朋友可直接翻到第二部分。</p><h3 id="1-1-为什么要学英文？"><a href="#1-1-为什么要学英文？" class="headerlink" title="1.1. 为什么要学英文？"></a>1.1. 为什么要学英文？</h3><p>不论是否在互联网行业，只要工作中需要与国外的技术进行接触，英文就是一个必不可缺的能力。<strong>对一个智慧的人来说，英文、快速学习、解决问题、复盘等都是要终身锻炼的能力</strong>。李笑来老师对于英文的重要性，以及元认知、心智等对概念在他的著作中都有所提及。大家有兴趣可以去读一下，可更深的体会到英文给人带来的影响。<br>传统音频行业就有着大型调音台进入国内无人会用，结果负责翻译说明书的人成为了业内好手的佳话。毕竟原汁原味的文档才是最准确的信息来源。别人嚼过后再输出的文章倒不一定是垃圾，但熵增后的知识一定不如直接读文档来的直接和准确。<br>英文不好的后果很多，遇到问题不敢用 Google 搜索，怕看不懂。开口讲点单词，全是错误的发音。恶性循环，职场生涯必然不顺。与其如此，倒不如将英文学习变成一种习惯。</p><h3 id="1-2-英文学习的基本概念"><a href="#1-2-英文学习的基本概念" class="headerlink" title="1.2. 英文学习的基本概念"></a>1.2. 英文学习的基本概念</h3><p>我跟晓光兄（微博：<em>恶魔奶爸</em>）认识七年，如果有早期知乎用的比较多的朋友，或许对这位传播英语学习方法论的“恶魔的奶爸”有所耳闻。他的一套英文学习方法论对大学后期的我产生了深刻的影响，也让我从一个“主谓宾”都不知是啥的渣渣，变成了还算“有点”英文能力的人。最起码能看懂些原版书，看英文说明书也毫无压力了。</p><blockquote><p>赖世雄老师说过：There’s no shortcut to good English, but we do have a right way.</p></blockquote><p>受晓光兄影响，我对 SLA（二语习得）有些许了解。其中 Stephen Krashen 博士有几条关于学习英语非常重要的假说：</p><ol><li>Input 假说：听力和阅读大量的输入才决定英文的水平，而不是漫无目的的跟老外瞎聊。</li><li>i + 1（可理解性输入假说）：学习新材料的时候，要比当前的水平 i 稍微高一点，即 i + 1，这样才是有效的可理解性输入。如果 i + 5或10，这种非可理解性的输入毫无意义。比如你单词量稀烂，看本 MIT 出版的书绝对头晕脑胀还学不到东西。</li><li>Narrow Input 假说：输入的材料要相对狭窄，不要什么领域都抓。既学音频行业术语，又刷 VOA 和经济学人，再背着本语法书，结果一事无成。</li><li>情绪机制：学习的材料一定是让人产生兴趣的，轻松自如的，这样才能激发学习热情。</li></ol><p>为了避免做战略上的矮子，需要认清英文学习的基本概念，在英语学习的路上有很大帮助。<br>但我想说，<strong>不少国人都有速成的神功大力丸思想，想要背点单词就突破阅读，口语角混半年就搞定口语，这种是绝对不可取的。</strong>虽然我用《如何用20天搞定声音设计 Keyword》作为标题，但还是希望大家明白英语学习是要长期投入的一件事。<br>有些人可能觉得来不及了，大学时算来不及吗？工作两年算来不及吗？种一棵树最好的时间是十年前，其次是现在。希望有心突破语言障碍的朋友坚持下去，经过此场全球大劫，活下来的人应该更认识到生命的潜力，而不是自暴自弃。</p><h3 id="1-3-学习路线推荐"><a href="#1-3-学习路线推荐" class="headerlink" title="1.3. 学习路线推荐"></a>1.3. 学习路线推荐</h3><p>晓光兄之前有视频录制的英语学习方法论课、发音课等，但我翻了一下发现现在全都不卖了，英语公众号更是荒废状态。周一问了一下，果然他现在已经不做这块，只在微博专做职场相关内容。<br><img src="/images/%E5%A5%B6%E7%88%B8.png" alt="奶爸"></p><p>如上所述，推荐有心系统学习英文的同学阅读晓光兄的著作《把你的英语用起来》，其中伍君仪老师关于透析法的部分可以不看。本书可能只有淘宝有货，大家也可选择去各大平台购买电子版。<br>书中方法论简单总结的话就是，音标和正确的发音是必须学的，其次是赖世雄或 ESLPod 这类播讲材料，以及后期辅佐阅读或美剧输入等。具体的部分大家可参照书中的介绍进行学习，如有精力查找奶爸微信公众号历史文章的朋友也可翻翻他后期的新文章，核心的学习路线区别不大。<br>至于书籍推荐，针对音频类英语的学习书籍国内只有《录音专业英语》一本，而《音乐英语》等书籍更偏向于音专所需的词汇。这部分只好靠大家自己积累了，对音频类书籍测词频意义也不是很大。</p><h2 id="20天搞定声音设计-Keyword"><a href="#20天搞定声音设计-Keyword" class="headerlink" title="20天搞定声音设计 Keyword"></a>20天搞定声音设计 Keyword</h2><p>不管是用商业音效库或 Freesound 这类音效网站找资源，亦或去 YouTube 找想要的声音实现过程。新手都容易遇到一个问题，不知道该用什么词去搜。<br>对于这个针对性极强的需求，我提供给大家一个训练方法。</p><h3 id="2-1-通过-AntConc-对商业音效库进行语料库提取"><a href="#2-1-通过-AntConc-对商业音效库进行语料库提取" class="headerlink" title="2.1. 通过 AntConc 对商业音效库进行语料库提取"></a>2.1. 通过 AntConc 对商业音效库进行语料库提取</h3><p>在语言学、英语教学等领域经常会通过语料库来进行专项研究。作为一种针对性极强的存在，语料库往往对某个领域的词汇研究有更精准的帮助，这里要感谢早稻田大学 Laurence Anthony 博士的作品 AntConc。<br>我使用 AntConc 把比较好找的常见的商业音效库的 PDF 元数据文档中的近40万个单词全部进行了处理<strong>（我的元数据文档不太全，如果哪位有收集完整的可以后台私信我，我处理之后把更具体的语料库分享给大家）</strong>。对得到的语料库文件根据词频（即在这份样本中单词出现的次数）进行排布，得到了一份近4000词的音效库词汇表。鉴于这个词汇量实在不算大，就不使用 BNC 进行反向剔除了，不然有可能把一些基础但重要的关键词刷掉。<br><img src="/images/%E9%9F%B3%E9%A2%91%E5%BA%93.png" alt="音频库"></p><p>其中词频1000次以上有68个，100次以上有446个，10次以上有1608个。<br>基于词频的分布，我把生成的词汇表做成完整、词频100+和词频10+三种，分别对应单词量为全部3915词、446词、1608词。<br><img src="/images/%E8%AF%8D%E9%A2%91%E8%A1%A8%E6%96%87%E4%BB%B6.png" alt="词频表文件"></p><p>大家可根据需求进行选用，如希望快速改善单词量，建议使用词频10+的版本（1608词）。词频在10次以下的虽然也有一些可用之处，但比较冷僻，若学有余力可考虑过一遍完整版长长见识。</p><p>下载地址：<br>链接：<a href="https://share.weiyun.com/zCSaXDtP" target="_blank" rel="noopener">https://share.weiyun.com/zCSaXDtP</a> 密码：pea4y5</p><h3 id="2-2-使用欧陆词典进行背诵"><a href="#2-2-使用欧陆词典进行背诵" class="headerlink" title="2.2. 使用欧陆词典进行背诵"></a>2.2. 使用欧陆词典进行背诵</h3><p>欧陆词典可以导入我整理好的词频文件进行背诵，建议大家付费，这样单词背诵记录等可云端同步。在背诵过程中，亦可添加到新的生词本，以方便添加笔记和二次整理。<br>首先打开欧陆笔记网页版（<a href="http://my.eudic.net/），登录自己的账户。" target="_blank" rel="noopener">http://my.eudic.net/），登录自己的账户。</a><br>在左边点击“导入其他软件的生词”<br><img src="/images/%E6%AC%A7%E9%99%861.png" alt="欧陆1"></p><p>使用默认的“导入其他软件生词本”，点击上传，选择所需的语料库文件。并选择合适的生词本，这里我新建了一个新的生词本。<br><img src="/images/%E6%AC%A7%E9%99%862.png" alt="欧陆2"></p><p>随后点击左侧“我的生词本”，即可看到新导入的生词本。<br><img src="/images/%E6%AC%A7%E9%99%863.png" alt="欧陆3"></p><p>在手机端同步完成后，即可看到“生词笔记”中出现了刚创建的生词本。切换到“学习”选项卡，找到刚创建的生词本，选择计划的天数即可开始学习。<br><strong>此处扣题，若选择每天背150个单词（包括新词与复习），大约正好20天左右刷一遍。</strong>因为其中有一些大家熟悉的词汇，所以每天的任务实际要比150个单词轻松，1小时左右差不多能完成。<br>欧陆词典具体的使用我就不赘述了，背单词的回忆方式多种多样。与扇贝、百词斩等无太大差异，支持多种背诵和回忆模式，请自行研究。<br><img src="/images/%E6%AC%A7%E9%99%864.jpeg" alt="欧陆4"></p><p>因为没做 BNC 剔除高频词，所以可能会有少数极简单的单词出现，在学习过程中划掉即可。<br>但请注意，<strong>快速记忆单词课本不是最终目的，这个过程主要是快速熟悉的声音设计术语。</strong>有心的同学可以在生词本中增加笔记，或使用笔记软件和思维导图等进行符合自己思维习惯的整理。</p><h3 id="2-3-最重要的还是多用"><a href="#2-3-最重要的还是多用" class="headerlink" title="2.3. 最重要的还是多用"></a>2.3. 最重要的还是多用</h3><p>背完单词表就万事大吉了吗？<br>不，一定要多用。无论是工作中还是搜索相关信息时，都要主动的联想并使用起曾经背过的单词。短期背诵带给你的是对声音设计相关术语的熟悉，让你容易出现描述失能。反复使用让其变成头脑的“肌肉记忆”才是目的。<br><strong>背单词这件事是英文学习中最不值得鼓励的一种方法，但对于词汇量极度匮乏或急需快速掌握某一领域词汇的人来说也算勉强还可以。</strong>希望大家明白什么是英语学习的正道，一时急于求成勉强可以，一直抄近路只会自讨苦吃。<br>愿本文对诸君在英语及声音设计术语的学习上有所帮助。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>写给声音设计师的敏捷 GUI 开发大法（一）</title>
      <link href="/2020/08/27/PySimpleGUI%20%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>/2020/08/27/PySimpleGUI%20%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>当作为声音设计师或技术音频的你完成了 Python 脚本时，除了感叹这门语言的便利性和丰富的第三方库，可能也会思考，<strong>为什么现有的 Python GUI 库都这么麻烦？</strong>毕竟要为团队中非程序背景的同事开发工具，看得见的界面无疑比命令行的用户体验更加友好。<br><strong>这一系列分享的目的，就是为了打通脚本和 GUI 程序之间的障碍，把开发图形界面这个浪费时间的过程彻底简单化，让技术音频工作中的小工具开发变的门槛更低一些。</strong>其实使用 Tkinter、PyQt、wxPython 等来开发 GUI 也没什么难度，参考实例几分钟就能上手，一下午就能熟悉。但它们使用起来语法繁琐，不太直观，非常浪费时间。<br>作为生产力解放狂魔，我认为<strong>应该把宝贵的精力应该放在更重要的事上，而不是费劲吧啦的在控件和语法间挣扎。</strong>这也是我个人的<strong>学习理念，其一为多向自己提问并解答之，其二是遇到重复、繁琐、有潜力被自动化的东西就喜欢思考去优化。</strong><br>希望此文能给大家提供一套高效的工作流，人人都能轻松定制自己想要的工具。</p><blockquote><p>本系列文章阅读需要的前置知识：</p><ul><li>会配置开发环境，掌握 Python、Anaconda、VS Code、PyCharm 的安装配置。</li><li>掌握简单的 Python 语法和 WAAPI 知识。作为一门写工具时要求技术水平不是很高的脚本语言，没接触过的同学可以敲几天《Python编程：从入门到实践》，或看看廖雪峰老师的课程。对于 WAAPI，照着例子调用几个 API 即可轻松上手。</li><li>掌握 GUI 基础概念。了解窗体、面板、构件等即可，有志向深入研究的朋友可翻翻 UI、UX 相关书籍。</li></ul></blockquote><p><em>文章目录：</em></p><ol><li>基本概念与示例</li><li>配置开发环境与 PySimpleGUI</li><li>一个完整的程序例子</li><li>接下来讲什么？</li></ol><h2 id="基本概念与示例"><a href="#基本概念与示例" class="headerlink" title="基本概念与示例"></a>基本概念与示例</h2><p>对于 GUI 而言，只需了解它是一个具有图形界面的应用程序外壳即可。至于事件循环、布局构建、回调函数等概念，大可先把它们当成黑箱。只管使用，不必探究深层原理。</p><h3 id="1-1-UI-和程序之间需要“钩上”才能产生互动"><a href="#1-1-UI-和程序之间需要“钩上”才能产生互动" class="headerlink" title="1.1. UI 和程序之间需要“钩上”才能产生互动"></a>1.1. UI 和程序之间需要“钩上”才能产生互动</h3><p>图形界面之所以能够让程序发挥功能，是因为其组件被用户触发后，与程序的功能代码产生了互动。<br>例如可以用一个按钮点击代表一个函数的执行，用一个弹出式窗口显示 Print() 函数的打印信息，每一个行为与背后的代码关联在一起。我们实际要做的就是设计好壳子，再用钩子把它们连接起来。</p><h3 id="1-2-举个最简单的例子（另类的-Hello-World）"><a href="#1-2-举个最简单的例子（另类的-Hello-World）" class="headerlink" title="1.2. 举个最简单的例子（另类的 Hello World）"></a>1.2. 举个最简单的例子（另类的 Hello World）</h3><p>现在讨论一个最简单的程序。用户输入内容，点击按钮后，程序会把用户输入值通过窗口打印出来。<br>我们为它设计一个 GUI 原型：<br><img src="/images/UI%20%E5%8E%9F%E5%9E%8B%E4%B8%80.png" alt="UI 原型一"><br>上图上部分是程序打开时的界面，当用户输入完内容点击 Print 后，下部分会出现弹出式窗口告知用户刚输入的值。</p><h4 id="这个例子说明了什么？"><a href="#这个例子说明了什么？" class="headerlink" title="这个例子说明了什么？"></a>这个例子说明了什么？</h4><p>看三个重要的功能组件：</p><ul><li>Input 文本框：用于暂存用户输入的数据</li><li>Print 按钮：用于把 Input 文本框中的数据传进程序内（把用户输入的值存到变量中）</li><li>Input is XXXXXXXXX：通过弹出式窗口输出用户输入值</li></ul><h4 id="通过这个例子类比到工具的真实需求上"><a href="#通过这个例子类比到工具的真实需求上" class="headerlink" title="通过这个例子类比到工具的真实需求上"></a>通过这个例子类比到工具的真实需求上</h4><p>图形界面下 Input() 和 Print() 等函数组成的程序就会是我们的功能脚本，而图形界面上的控件就是本文的讨论方向，我们要用一种高效优雅的方法将两者连接。</p><h3 id="1-3-代码实现："><a href="#1-3-代码实现：" class="headerlink" title="1.3. 代码实现："></a>1.3. 代码实现：</h3><p>下面我写两段简单的代码，分别把这个程序用 Tkinter 和 PySimpleGUI 实现，并附上效果截图。</p><h4 id="使用-Tkinter"><a href="#使用-Tkinter" class="headerlink" title="使用 Tkinter"></a>使用 Tkinter</h4><p><img src="/images/Tkinter.png" alt="Tkinter"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> messagebox</span><br><span class="line"></span><br><span class="line">window = Tk() </span><br><span class="line">window.title(<span class="string">'小刘鸭之窗'</span>) </span><br><span class="line">window.geometry(<span class="string">'200x60'</span>) </span><br><span class="line"></span><br><span class="line">user_input = StringVar()</span><br><span class="line">user = Entry(window, textvariable=user_input)</span><br><span class="line">user_input.set(<span class="string">' '</span>)</span><br><span class="line">user.pack()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">click</span><span class="params">()</span>:</span></span><br><span class="line">    duckyo = user_input.get()</span><br><span class="line">    string = str(<span class="string">'Imput is%s'</span> %(duckyo))</span><br><span class="line">    print(<span class="string">'Imput is%s'</span> %(duckyo))</span><br><span class="line">    messagebox.showinfo(title=<span class="string">'鼻孔猫输出'</span>, message=string)</span><br><span class="line"></span><br><span class="line">Button(window, text=<span class="string">'Print'</span>, command=click).pack()</span><br><span class="line"></span><br><span class="line">window.mainloop()</span><br></pre></td></tr></table></figure><h4 id="使用-PySimpleGUI"><a href="#使用-PySimpleGUI" class="headerlink" title="使用 PySimpleGUI"></a>使用 PySimpleGUI</h4><p><img src="/images/PySimpleGUI.png" alt="PySimpleGUI"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line">sg.theme(<span class="string">'Light Brown 11'</span>)   </span><br><span class="line"></span><br><span class="line">layout = [[sg.InputText(size=(<span class="number">30</span>, <span class="keyword">None</span>)), sg.Button(button_text=<span class="string">'Ok'</span>, size=(<span class="number">10</span>, <span class="number">1</span>))]]</span><br><span class="line">window = sg.Window(<span class="string">'小刘鸭之窗'</span>, layout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    event, values = window.read()</span><br><span class="line">    <span class="keyword">if</span> event == sg.WIN_CLOSED <span class="keyword">or</span> event == <span class="string">'Cancel'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    sg.popup(<span class="string">'Input is '</span> + values[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure><h4 id="大家认为谁更简单一些？"><a href="#大家认为谁更简单一些？" class="headerlink" title="大家认为谁更简单一些？"></a>大家认为谁更简单一些？</h4><p>相信诸君无论熟悉 Python 与否，都能看出 PySimpleGUI 的代码具有高度可读性，更符合自然语义。不需要过多的设置即可做到优雅的主题、窗口排布。<br>这段代码给一个从未接触过 PySimpleGUI 的人看，一般也可轻松看出上半部分是布局实现，下半部分的循环是 Event Loop。<br>回过头来再看 Tkinter 的实现，对初学者来说很容易不知所云。<br>关于 QtDesigner，其实它的操作和语法也没有 PySimpleGUI 简单直观。不过下一篇中我会提到通过 QtDesigner 快速创建 Layout 代码，也算一种另类的物尽其用。</p><h2 id="配置开发环境与-PySimpleGUI"><a href="#配置开发环境与-PySimpleGUI" class="headerlink" title="配置开发环境与 PySimpleGUI"></a>配置开发环境与 PySimpleGUI</h2><p>这部分我不会说废话重复造轮子，那样有凑字数之嫌，直接放出比较好的文章供大家参考（感谢下文中作者们的贡献）。希望读者诸君自我实现一遍，加深印象。<br>因为个人习惯用 VS Code + Anaconda 配置开发环境，使用 pip、PyCharm 等的朋友可自行配置所需组件。关于 Anaconda、VS Code 和 PyCharm 的使用疑问请自行参考下述文档解决，其中的内容比较具体。关于各种开发环境的优劣性对比，请自行用搜索引擎解答疑问。</p><h3 id="2-1-Windows-下配置"><a href="#2-1-Windows-下配置" class="headerlink" title="2.1. Windows 下配置"></a>2.1. Windows 下配置</h3><h4 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h4><p><a href="https://segmentfault.com/a/1190000022797661" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022797661</a></p><h4 id="配置-Anaconda-并在本地环境中添加-PySimpleGUI"><a href="#配置-Anaconda-并在本地环境中添加-PySimpleGUI" class="headerlink" title="配置 Anaconda 并在本地环境中添加 PySimpleGUI"></a>配置 Anaconda 并在本地环境中添加 PySimpleGUI</h4><p><a href="https://zhuanlan.zhihu.com/p/25198543" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25198543</a></p><h4 id="配置-VS-Code-开发环境"><a href="#配置-VS-Code-开发环境" class="headerlink" title="配置 VS Code 开发环境"></a>配置 VS Code 开发环境</h4><p><a href="https://zhuanlan.zhihu.com/p/30324113" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30324113</a></p><h3 id="2-2-macOS-下配置"><a href="#2-2-macOS-下配置" class="headerlink" title="2.2. macOS 下配置"></a>2.2. macOS 下配置</h3><h4 id="安装-Anaconda-1"><a href="#安装-Anaconda-1" class="headerlink" title="安装 Anaconda"></a>安装 Anaconda</h4><p><a href="https://blog.csdn.net/lq_547762983/article/details/81003528" target="_blank" rel="noopener">https://blog.csdn.net/lq_547762983/article/details/81003528</a></p><h4 id="配置-Anaconda-并在本地环境中添加-PySimpleGUI-1"><a href="#配置-Anaconda-并在本地环境中添加-PySimpleGUI-1" class="headerlink" title="配置 Anaconda 并在本地环境中添加 PySimpleGUI"></a>配置 Anaconda 并在本地环境中添加 PySimpleGUI</h4><h4 id="配置-VS-Code开发环境"><a href="#配置-VS-Code开发环境" class="headerlink" title="配置 VS Code开发环境"></a>配置 VS Code开发环境</h4><p>此两步可参考上面的链接，操作类似。</p><h2 id="绘制-GUI-原型"><a href="#绘制-GUI-原型" class="headerlink" title="绘制 GUI 原型"></a>绘制 GUI 原型</h2><p>对于绘制原型，有些人立刻会想到 Sketch 或 Axure 这样的重型武器，但它们学起来时间成本过高。还有一些 Web 端收费的原型制作工具，但那些在做 APP 原型设计才比较常用，做桌面端小工具开发也没必要。<br>在寻求解决方案的时候我发现了一个很棒的工具，对于简单的绘制 UI 原型的需求，推荐大家使用 Pencil，这是一款<strong>免费、开源、轻量、跨平台（Windows、macOS、Linux、火狐拓展）的原型设计工具</strong>。<br><img src="/images/Pencil%201.png" alt="Pencil 1"><br>附上样图一张</p><p>下载地址：<a href="https://pencil.evolus.vn/" target="_blank" rel="noopener">https://pencil.evolus.vn/</a><br>在“举个最简单的例子（另类的 Hello World）”处的黑白稿 UI 原型图，即使用 Pencil 所绘。相对于糟糕的手绘稿或请公司的 UI 设计师帮忙，不如花点时间学会 Pencil 后自己画。<br>如何学习 Pencil 呢？在官网文档中有比较简单的入门介绍。或者我建议大家可直接拖拽控件试一试，很容易上手。</p><h2 id="一个完整的例子"><a href="#一个完整的例子" class="headerlink" title="一个完整的例子"></a>一个完整的例子</h2><p>文档“翻译官“是种非常无聊的行为。下面我就直接通过一个具有实际应用意义的小工具模型，来讲述脚本代码通过 PySimpleGUI 如何优雅且快速的变成图形界面小工具。</p><h3 id="4-1-程序目的"><a href="#4-1-程序目的" class="headerlink" title="4.1. 程序目的"></a>4.1. 程序目的</h3><p>把一个文件夹内的 wav 文件根据声道数，对文件自动进行重命名加到后缀上。非常简单的需求，下面我先写出功能代码。</p><h3 id="4-2-编写功能代码"><a href="#4-2-编写功能代码" class="headerlink" title="4.2. 编写功能代码"></a>4.2. 编写功能代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nchannels_rename</span><span class="params">(input_path)</span>:</span> <span class="comment"># 重命名功能模块</span></span><br><span class="line">    f = wave.open(input_path, <span class="string">'rb'</span>)</span><br><span class="line">    params = f.getnchannels()</span><br><span class="line">    oldname=input_path</span><br><span class="line">    <span class="keyword">if</span> params == <span class="number">1</span>:</span><br><span class="line">        newname = input_path.rstrip(<span class="string">'.wav'</span>) + <span class="string">'_mono'</span> + <span class="string">'.wav'</span></span><br><span class="line">        os.rename(oldname, newname)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        newname = input_path.rstrip(<span class="string">'.wav'</span>) + <span class="string">'_stereo'</span> + <span class="string">'.wav'</span></span><br><span class="line">        os.rename(oldname, newname)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wav_rename</span><span class="params">(input_path)</span>:</span> <span class="comment"># 对目录进行判断并重命名</span></span><br><span class="line">    fileend = []</span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(input_path):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(input_path):</span><br><span class="line">            fileend.append(os.path.splitext(file)[<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">'.wav'</span>):</span><br><span class="line">                nchannels_rename(input_path + os.sep + file)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'.wav'</span> <span class="keyword">in</span> fileend:</span><br><span class="line">            print(<span class="string">'Processing Complete.'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'No wave file be found!'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'Check your input!'</span>)</span><br></pre></td></tr></table></figure><h3 id="4-3-PySimpleGUI-基础"><a href="#4-3-PySimpleGUI-基础" class="headerlink" title="4.3. PySimpleGUI 基础"></a>4.3. PySimpleGUI 基础</h3><p>那么接下来就要使用 PySimpleGUI 添加图形界面了，在这之前需要知道一些基础的概念。</p><h4 id="PySimpleGUI-基于什么构建？"><a href="#PySimpleGUI-基于什么构建？" class="headerlink" title="PySimpleGUI 基于什么构建？"></a>PySimpleGUI 基于什么构建？</h4><p>虽然 PySimpleGUI 默认基于 Tkinter，但实际上还具有 WxPython、QT 和 Remi 等版本。具体的区别可参考官方的“散文“文档。其中对于 Remi 的支持是十分方便的。这代表着当代码进行以下简单的引用库修改后，程序可直接生成 Web 端在浏览器中运行。对于某些轻需求下的开发，省去了大量的时间和精力。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="comment"># tkinter version</span></span><br><span class="line"><span class="keyword">import</span> PySimpleGUIWeb <span class="comment"># Web(Remi) version</span></span><br><span class="line"><span class="comment"># and PySimpleGUI27, PySimpleGUIWx, PySimpleGUIQt</span></span><br></pre></td></tr></table></figure></p><h4 id="如何实现一个基础的-GUI-结构"><a href="#如何实现一个基础的-GUI-结构" class="headerlink" title="如何实现一个基础的 GUI 结构"></a>如何实现一个基础的 GUI 结构</h4><p>这里我直接引用官方的示例代码并加上注释，一个简单的窗口布局结构代码其实很清晰：</p><ol><li>sg.theme 行代表使用哪个主题，这也是 PySimpleGUI 一开始就很注重的一点。程序的美观性很重要，而且要轻松的被实现。</li><li>layout 使用列表来定义布局，其中的每个子列表代表当前行的元素（即 Widgets，PySimpleGUI 中称控件为 Elements，本系列教程也会统一使用此术语），每个控件的属性中亦可设置各种所需的参数。</li><li>window 行创建了窗体，默认情况下自动适应控件所需的尺寸。</li><li>Event Loop 用于支撑软件功能运行到窗体关闭或点击 Cancel 退出。<br><img src="/images/PySimpleGUI%202.png" alt="PySimpleGUI 2"></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"></span><br><span class="line">sg.theme(<span class="string">'DarkAmber'</span>)   <span class="comment"># 设定主题为 DarkAmber</span></span><br><span class="line"><span class="comment"># 窗口内的共含三行元素，在列表中清晰可见</span></span><br><span class="line">layout = [  [sg.Text(<span class="string">'Some text on Row 1'</span>)],</span><br><span class="line">            [sg.Text(<span class="string">'Enter something on Row 2'</span>), sg.InputText()],</span><br><span class="line">            [sg.Button(<span class="string">'Ok'</span>), sg.Button(<span class="string">'Cancel'</span>)] ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建窗体，名称为 Window Title</span></span><br><span class="line">window = sg.Window(<span class="string">'Window Title'</span>, layout)</span><br><span class="line"><span class="comment"># Event Loop，不断的从窗体中读取事件与返回值，并检测窗口是否被关闭</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    event, values = window.read()</span><br><span class="line">    <span class="keyword">if</span> event == sg.WIN_CLOSED <span class="keyword">or</span> event == <span class="string">'Cancel'</span>: </span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">'You entered '</span>, values[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure><h4 id="PySimpleGUI-能做出什么样的程序？"><a href="#PySimpleGUI-能做出什么样的程序？" class="headerlink" title="PySimpleGUI 能做出什么样的程序？"></a>PySimpleGUI 能做出什么样的程序？</h4><p>在这里我放几张官方的图片供大家观看，相信诸位能看出它内置丰富控件元素及优雅设计。<br><img src="/images/pytheme.jpg" alt="pytheme"><br>所有内置的主题</p><p><img src="/images/pyml.jpg" alt="pyml"><br>引入机器学习模块判断车辆的存在</p><p><img src="/images/pywidget.jpg" alt="pywidget"><br>用到了13种元素的示例程序（实际上还有更多）</p><p><img src="/images/pywindow.png" alt="pywindow"><br>多窗口示例程序</p><h3 id="4-4-构建-GUI-代码"><a href="#4-4-构建-GUI-代码" class="headerlink" title="4.4. 构建 GUI 代码"></a>4.4. 构建 GUI 代码</h3><p>回到我们的程序设计上。对于这个简单的程序，我们需要程序中包含路径输入框、处理按钮、处理提示文本框等。为此，我简单绘制一个原型。<br><img src="/images/pyui.png" alt="pyui"></p><p>有了原型，下面我写一段简单的 GUI 实现并附上注释：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设计布局为四行元素，分别用到文字、输入框、文件夹浏览器、输出、按钮等元素。</span></span><br><span class="line">layout = [  [sg.Text(<span class="string">'Browse Folders'</span>)],</span><br><span class="line">            [sg.Input(), sg.FolderBrowse(<span class="string">'Browse'</span>, key=<span class="string">'folder'</span>)],</span><br><span class="line">            [sg.Output(size=(<span class="number">70</span>, <span class="number">20</span>), font=(<span class="string">"宋体"</span>, <span class="number">10</span>))],</span><br><span class="line">            [sg.Button(<span class="string">'Cock it'</span>), sg.Button(<span class="string">'Cancel'</span>)] ]</span><br><span class="line"><span class="comment"># 构建窗体 GUI Enemy No. 1</span></span><br><span class="line">window = sg.Window(<span class="string">'GUI Enemy No. 1'</span>, layout)</span><br><span class="line"><span class="comment"># 创建 Event Loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    event, values = window.read()</span><br><span class="line">    <span class="keyword">if</span> event <span class="keyword">in</span> (<span class="keyword">None</span>, <span class="string">'Cancel'</span>): <span class="comment"># 如果用户点击“Cancel”按钮，就退出循环并关闭窗口</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">'Cock it'</span>: <span class="comment"># 如果用户点击“Cock it”按钮，就执行判断体判断是否为文件夹输入，是的话输出文字并调用 wav_rename() 函数进行操作</span></span><br><span class="line">        <span class="keyword">if</span> values[<span class="string">'folder'</span>]:</span><br><span class="line">            print(<span class="string">'&#123;0&#125;Renaming&#123;0&#125;'</span>.format(<span class="string">'*'</span>*<span class="number">10</span>))</span><br><span class="line">            wav_rename(values[<span class="string">'folder'</span>])</span><br><span class="line">            print(<span class="string">'&#123;0&#125;Done&#123;0&#125;'</span>.format(<span class="string">'*'</span>*<span class="number">10</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'Choose some folder first!'</span>)</span><br><span class="line"></span><br><span class="line">window.close()</span><br></pre></td></tr></table></figure></p><h4 id="4-5-组装代码"><a href="#4-5-组装代码" class="headerlink" title="4.5. 组装代码"></a>4.5. 组装代码</h4><p>写完功能代码和 GUI 代码，肯定需要把它们组装到一起。根据项目的复杂程度，你也可以决定是否按模块整理代码。<br>注：为了避免浪费篇幅，其中函数体直接省略。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PySimpleGUI <span class="keyword">as</span> sg</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> wave</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nchannels_rename</span><span class="params">(input_path)</span>:</span></span><br><span class="line">    Function body</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wav_rename</span><span class="params">(input_path)</span>:</span></span><br><span class="line">    Function body</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gui</span><span class="params">()</span>:</span></span><br><span class="line">    Function body</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>    </span><br><span class="line">    gui()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><h4 id="4-6-执行效果"><a href="#4-6-执行效果" class="headerlink" title="4.6. 执行效果"></a>4.6. 执行效果</h4><p>我稍微修改了一下代码，让被修改后的文件名输出到文本框中。从输出结果可见，程序如预先构思执行，我们仅用不到20行代码就优雅的完成了这个工具。<br><img src="/images/pyresult-1.png" alt="pyresult"></p><h2 id="接下来讲什么？"><a href="#接下来讲什么？" class="headerlink" title="接下来讲什么？"></a>接下来讲什么？</h2><p>聪明的读者一定很好奇这些部分：</p><ul><li>如何添加菜单栏？</li><li>窗体内元素能否实现双栏或不对称布局？</li><li>之前你提到过用 QtDesigner 能快速生成布局？不用自己写布局代码了吗？</li><li>有没有对声音设计师来说更实用或更复杂的程序案例详解（例如跟 WAAPI 或 ReaScript 联动）？</li></ul><p>在之后的文章中我会就这些部分继续展开介绍，欢迎诸位持续关注。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>游戏音频与声音设计相关书籍推荐（第二版）</title>
      <link href="/2020/08/15/%E6%B8%B8%E6%88%8F%E9%9F%B3%E9%A2%91%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
      <url>/2020/08/15/%E6%B8%B8%E6%88%8F%E9%9F%B3%E9%A2%91%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是溪夜。<br>在游戏音频与声音设计领域的探索过程中，我发现国内的相关书籍比较匮乏。对于游戏行业中一个有趣的行业分支，我很惊讶居然没有一个像样的书单或学习路线。作为喜好钻研和分享的人，深感应该把最近一年多的挖掘与发现做成书单来分享。希望与大家交流学习，共同提高。<br>文中为我认为值得推荐的书籍（包括我已读和准备读的），少部分书籍之所以不推荐，是因为其中内容过于古老，或内容空洞没参考价值。<strong>中文书籍我认为大多数朋友应该已经读过或翻过，此部分书籍尽量省略介绍。</strong>书单这种东西，希望它不仅仅是躺在你的收藏夹里，而是对你的知识体系建设有帮助。<br>与著名的“保姆级” Unity 教程作者 Jasper Flick 相同，我对<strong>知识应该成体系的去分享这种思维表示极度的赞同。</strong>所以与直接的列书单不同，我会增加参考性的评价，供诸君选书之用。<br>诚然，作为实践中才能获取更多经验的工作类型。对于 Sound Designer 或 Audio Programmer 来说，绝大多数的经验都是难以从书籍中获取的。除非某一日出版《Wwise Implementation FAQ 要你命3000》、《游戏音效声音设计实例 For Dummies》、《21天成为 ReaScript 自动化大师》等“史诗级”书籍……<br>此书单会根据本人学习情况不定时更新，请关注公众号以获得最新版本推送。<br>希望这个书单对你有帮助，有任何疑问欢迎留言到本文下。</p><blockquote><p>约定：</p><ul><li>本文的中英文符号与书名标记，根据《夹用英文的中文文本的标点符号用法（草案）》进行标准化，如英文书名一律使用斜体英文表示。</li><li>绝大部分英文书籍可在 Amazon 购买实体书或 Kindle 版，亦可购买 Focal Press 或 CRC Press 等数字压制的 PDF 版本。中文书籍可轻松的在各大图书网站寻得购买途径，此处便不赘述。</li><li>本文不提供任何盗版获取方式，如有能力请支持正版。作为知识的载体，图书的价格已是低到不可想象。如暂时看了盗版，请记住日后有钱补票，这才是知识流动的正循环。</li><li>文中图书封面严谨的进行过横向900像素的统一，以获得公众号上最完美的阅读体验，请大家欣赏标准化带来的美感。</li></ul></blockquote><blockquote><p>第二版更新内容：</p><ol><li>改正错别字、增改介绍文字内容、增加目录</li><li>聊聊如何选择阅读顺序以及怎么读</li><li>增加“游戏音频导论”下关于求职、项目规划的书目</li><li>增加“声音设计”下更多声音设计、电影声音和空间音频的书目</li><li>增加“技术音频”下关于 Unity 音频整合及 Unity、Unreal Engine 使用相关书目</li></ol><p>注：新增加的书目一律排在每个细节分类的前面（英文书籍会排在英文书籍部分的最前面），以方便大家查看变化的部分。</p></blockquote><p>书籍目录：</p><p>1 游戏音频导论</p><ul><li>《游戏音频完全指南（第2版）》</li><li>The Bible of Getting a Job in Game Audio, 2020 Edition</li><li>Audio for Games：Planning, Process, and Production</li><li>The Beep Book: Documenting the History of Game Sound</li><li>Game Sound: An Introduction to the History, Theory, and Practice of Video Game Music and Sound Design</li><li>Principles of Game Audio and Sound Design</li><li>Playing with Sound: A Theory of Interacting with Sound and Music in Video Games</li><li>The Essential Guide to Game Audio: The Theory and Practice of Sound for Games</li><li>Creating Music and Sound for Games</li><li>The Game Audio Strategy Guide: A Practical Course</li></ul><p>2 声音设计<br>2.1 声音设计理论与实践</p><ul><li>《视听：幻觉的构建》</li><li>《放低话筒杆》</li><li>《声音》</li><li>《电影之声：电影音效师访谈录》</li><li>《声频信号的仪表计量》</li><li>《音效圣经: 好莱坞音效创作及录制技巧》</li><li>《电影电视声音（第3版）》</li><li>《电影声音实用艺术（第3版）》</li><li>《动画声音设计》</li><li>《审美空间延伸与拓展: 电影声音艺术理论》</li><li>《声音设计: 电影中语言，音乐和音响的表现（第2版）》</li><li>Sound Design and Science Fiction</li><li>Post Sound Design: The Art and Craft of Audio Post Production for the Moving Image</li><li>Hollywood Sound Design and Moviesound Newsletter: A Case Study of the End of the Analog Age</li><li>The Oxford Handbook of Interactive Audio</li><li>Producing Great Sound for Film and Video</li><li>Studying Sound: A Theory and Practice of Sound Design</li><li>Foundations in Sound Design for Interactive Media: A Multidisciplinary Approach</li><li>Foundations in Sound Design for Linear Media: A Multidisciplinary Approach</li><li>Sound Design Theory and Practice: Working with Sound</li><li>Sound Works: A Cultural Theory of Sound Design</li><li>The Fundamentals of Sonic Art and Sound Design</li><li>The Plagrave Handbook of Sound Design and Music in Screen Media</li></ul><p>2.2 拟音（Foley）</p><ul><li>《拟音圣经: 电影、游戏和动画片中的声音表演艺术》</li><li>《影视拟音技巧》</li></ul><p>2.3 Pure Data</p><ul><li>《设计声音》</li><li>《电子音乐技术》</li><li>《交互式音频程序开发》</li><li>《Pure Data 图形化音乐编程技术与应用》</li><li>Multimedia Programming with Pure Data</li><li>Programming Sound with Pure Data: Make Your Apps Come Alive with Dynamic Audio</li></ul><p>2.4 VCV Rack</p><ul><li>How to Rack</li><li>VCV Rack: How it Works</li><li>Developing Virtual Synthesizers with VCV Rack</li></ul><p>2.4 Reaktor</p><ul><li>《声音合成平台 Reaktor 操作指南》</li></ul><p>2.5 合成器</p><ul><li>《自己动手做声音: 声音合成与制作基础》</li><li>《声音合成与采样技术（第3版）》</li><li>《软件合成器技术实战手册: 音色制作与模块编程》</li><li>Creating Sounds from Scratch: A Practical Guide to Music Synthesis for Producers and Composers</li><li>The Synthesizer: A Comprehensive Guide to Understanding, Programming, Playing, and Recording the Ultimate Electronic Music Instrument</li><li>Computer Sound Design: Synthesis Techniques and Programming 2nd edition</li><li>Becoming a Synthesizer Wizard: From Presets to Power User</li><li>Welsh’s Synthesizer Cookbook: Synthesizer Programming, Sound Analysis, and Universal Patch Book 1、2</li><li>Refining Sound: A Practical Guide to Synthesis and Synthesizers</li><li>Analog Synthesizers: Understanding, Performing, Buying 2nd edition</li><li>Microsound</li></ul><p>2.6 空间音频</p><ul><li>《空间声原理》</li><li>《空间线索在3D音频中的应用研究》</li><li>Ambisonics</li><li>Immersive Sound</li></ul><p>3 技术音频<br>3.1 导论及文集</p><ul><li>《游戏引擎架构》</li><li>《游戏编程算法与技巧》</li><li>The Audio Programming Book</li><li>Game Audio Programming: Principles and Practices 1、2、3</li><li>Beep To Boom: The Development Of Advanced Runtime Sound Systems For Games And Extended Reality</li><li>Game Audio: Tales of a Technical Sound Designer 1、2</li></ul><p>3.2 引擎使用</p><ul><li>《Unity 3D 游戏开发（第二版）》</li><li>Unity Game Development Cookbook</li><li>Unreal Engine Game Development Cookbook</li></ul><p>3.3 游戏引擎音频整合</p><ul><li>Game Audio Development with Unity 5.X</li><li>Game Audio Implementation: A Practical Guide Using the Unreal Engine</li><li>Game Audio with FMOD and Unity</li><li>The Handbook of Game Audio Using Wwise</li></ul><p>3.4 插件开发</p><ul><li>Getting Started with JUCE</li><li>Audio Effects: Theory, Implementation and Application</li><li>DAFX Digital Audio Effects</li><li>Designing Audio Effect Plug-Ins in C++ With Digital Audio Signal Processing Theory</li><li>Designing Software Synthesizer Plug-Ins in C++ For RackAFX, VST3, and Audio Units</li></ul><h2 id="1-游戏音频导论"><a href="#1-游戏音频导论" class="headerlink" title="1. 游戏音频导论"></a>1. 游戏音频导论</h2><p>导论部分多为适合入门者的读物，内容偏向综合介绍游戏音频行业的工作内容与常见技巧。</p><h4 id="《游戏音频完全指南（第2版）》"><a href="#《游戏音频完全指南（第2版）》" class="headerlink" title="《游戏音频完全指南（第2版）》"></a>《游戏音频完全指南（第2版）》</h4><p><img src="/images/%E6%B8%B8%E6%88%8F%E9%9F%B3%E9%A2%91%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97_900.jpg" alt="游戏音频完全指南_900"><br>Aaron Marks，人民邮电出版社，2014<br>这本应该是想入行的绝大大多数人搜到的前几本书之一。从功利阅读角度出发，4-6章关于如何接私活的内容大可不看，只读其他部分的内容足矣。<br>作为音频技术与录音艺术译丛中不太被重视的一本，第3版被夏老师重译的几率看来很低，这也让这本书的内容略显陈旧（例如关于中间件和录音的内容几乎没有）。建议有条件的朋友翻阅原版第3版，其中新增大量诱人的内容，包括游戏音频必备技能、音效设计技巧、田野录音（Field Recording）、对白录音，以及最重要的部分——对 Wwise 等几大中间件的介绍并引入引擎整合时脚本的概念，如此升级后的内容才能让初学者对游戏音频有一套比较好的认知，而不是单纯停留在简单的资源制作层面。</p><h4 id="The-Bible-of-Getting-a-Job-in-Game-Audio-2020-Edition"><a href="#The-Bible-of-Getting-a-Job-in-Game-Audio-2020-Edition" class="headerlink" title="The Bible of Getting a Job in Game Audio, 2020 Edition"></a><em>The Bible of Getting a Job in Game Audio, 2020 Edition</em></h4><p><img src="/images/The%20Bible%20of%20Getting%20a%20Job%20in%20Game%20Audio,%202020%20Edition_900.jpg" alt="The Bible of Getting a Job in Game Audio, 2020 Edition_900"><br>Florian Titus Ardelean, 2020<br>作为一名热心的音频设计师，Florian 前几个月放出的这份如何在游戏音频行业找到工作的文档很有推荐价值。超过60多位业内专家对这份工作的方方面面都给出了有价值的见解，需要的朋友可以去 Florian 的推置顶获取下载地址。</p><h4 id="Audio-for-Games：Planning-Process-and-Production"><a href="#Audio-for-Games：Planning-Process-and-Production" class="headerlink" title="Audio for Games：Planning, Process, and Production"></a><em>Audio for Games：Planning, Process, and Production</em></h4><p><img src="/images/Audio%20for%20Games_900.jpg" alt="Audio for Games_900"><br>Alexander Brandon, New Riders, 2004<br>侯老师推荐的一本，虽然比较老，但其中对于声音资源的计划、管理方法有很好的介绍。</p><h4 id="The-Beep-Book-Documenting-the-History-of-Game-Sound"><a href="#The-Beep-Book-Documenting-the-History-of-Game-Sound" class="headerlink" title="The Beep Book: Documenting the History of Game Sound"></a><em>The Beep Book: Documenting the History of Game Sound</em></h4><p><img src="/images/The%20Beep%20Book_900.jpg" alt="The Beep Book_900"><br>Karen Collins, Chris Greening, Ehtonal, 2016<br>采访了96位著名游戏音频从业者，复现出游戏音频行业的发展历史。如果想要系统的展望一下这个行业，可以翻翻看有没有你喜欢的声音设计师。</p><h4 id="Game-Sound-An-Introduction-to-the-History-Theory-and-Practice-of-Video-Game-Music-and-Sound-Design"><a href="#Game-Sound-An-Introduction-to-the-History-Theory-and-Practice-of-Video-Game-Music-and-Sound-Design" class="headerlink" title="Game Sound: An Introduction to the History, Theory, and Practice of Video Game Music and Sound Design"></a><em>Game Sound: An Introduction to the History, Theory, and Practice of Video Game Music and Sound Design</em></h4><p><img src="/images/Game%20Sound%20-%20An%20Introduction%20to%20the%20History,%20Theory,%20and%20Practice%20of%20Video%20Game%20Music%20and%20Sound%20Design_900.jpg" alt="Game Sound - An Introduction to the History, Theory, and Practice of Video Game Music and Sound Design_900"><br>Karen Collins, The MIT Press, 2008<br>滑铁卢大学游戏学院副教授 Karen Collins N 部作品之一，简单梳理了游戏和音频的发展史。其中对音频团队构成和音频处理阶段有比较清晰的探讨。限制于篇幅，比较泛泛而谈，新手入门时跳着翻翻查漏补缺会有些启发。</p><h4 id="Principles-of-Game-Audio-and-Sound-Design"><a href="#Principles-of-Game-Audio-and-Sound-Design" class="headerlink" title="Principles of Game Audio and Sound Design"></a><em>Principles of Game Audio and Sound Design</em></h4><p><img src="/images/Principles%20of%20Game%20Audio%20and%20Sound%20Design*.jpg" alt="Principles of Game Audio and Sound Design*"><br>Jean-Luc Sinclair, Focal Press, 2020<br>一本详实的入门书籍，内容包括游戏引擎、声音引擎、编程、整合、过程式音频等对初学者很友好的概念。作者除了声音设计外还作曲，与九寸钉 Trent 叔和 RATM 乐队均有合作。</p><h4 id="Playing-with-Sound-A-Theory-of-Interacting-with-Sound-and-Music-in-Video-Games"><a href="#Playing-with-Sound-A-Theory-of-Interacting-with-Sound-and-Music-in-Video-Games" class="headerlink" title="Playing with Sound: A Theory of Interacting with Sound and Music in Video Games"></a><em>Playing with Sound: A Theory of Interacting with Sound and Music in Video Games</em></h4><p><img src="/images/Playing%20with%20Sound%20-%20A%20Theory%20of%20Interacting%20with%20Sound%20and%20Music%20in%20Video%20Games_900.jpg" alt="Playing with Sound - A Theory of Interacting with Sound and Music in Video Games_900"><br>Karen Collins, The MIT Press, 2013<br>同为 Karen Collins 的作品，这本偏向理论，探讨了各种交互式声音在游戏中的使用。从电影研究、哲学、心理学到计算机科学，综合探讨了一个交互式声音体验理论。</p><h4 id="The-Essential-Guide-to-Game-Audio-The-Theory-and-Practice-of-Sound-for-Games"><a href="#The-Essential-Guide-to-Game-Audio-The-Theory-and-Practice-of-Sound-for-Games" class="headerlink" title="The Essential Guide to Game Audio: The Theory and Practice of Sound for Games"></a><em>The Essential Guide to Game Audio: The Theory and Practice of Sound for Games</em></h4><p><img src="/images/The%20Essential%20Guide%20to%20Game%20Audio%20-%20The%20Theory%20and%20Practice%20of%20Sound%20for%20Games_900.jpg" alt="The Essential Guide to Game Audio - The Theory and Practice of Sound for Games_900"><br>Steve Horowitz, Scott Looney, Routledge, 2014<br>同样是近乎完美的一本入门读物，只可惜停留在14年的版本再无更新。从游戏历史、交互式声音、Middleman 中间件，一直讲到使用 Unity 自己的音频功能进行整合声音。非常基础。适合初学者花一天时间好好读一遍，拓宽视野（虽然本书的范围并不够）。</p><h4 id="Creating-Music-and-Sound-for-Games"><a href="#Creating-Music-and-Sound-for-Games" class="headerlink" title="Creating Music and Sound for Games"></a><em>Creating Music and Sound for Games</em></h4><p><img src="/images/Creating%20Music%20and%20Sound%20for%20Games_900.jpg" alt="Creating Music and Sound for Games_900"><br>G. W. Childs IV, Course Technology PTR, 2006<br>给星战游戏做声音设计的老前辈的老著作，因为他写过 Reason 的书，所以其中会夹带不少用 Reason 做声音设计的私货。不过看年份就知道书里不少东西已经过时，入门随便翻翻看看前辈的思路还是可以的，记住别傻乎乎的去下 GigaStudio。</p><h4 id="The-Game-Audio-Strategy-Guide-A-Practical-Course"><a href="#The-Game-Audio-Strategy-Guide-A-Practical-Course" class="headerlink" title="The Game Audio Strategy Guide: A Practical Course"></a><em>The Game Audio Strategy Guide: A Practical Course</em></h4><p><img src="/images/The%20Game%20Audio%20Strategy%20Guide_900.jpg" alt="The Game Audio Strategy Guide_900"><br>Gina Zdanowicz, Spencer Bambrick, Focal Press, 2019<br>从去年开始就颇为感兴趣的一本书，推上关注 Gina 的话能看出她是想把这本书做成非常系统的入门书籍。举些例子，在声音设计部分就分别讲了从音效库、合成、拟音和田野录音等方法获取素材加以合成，在整合部分少有的把音频和音乐整合分开讲，入门直接看这本应该也很棒。</p><h2 id="2-声音设计"><a href="#2-声音设计" class="headerlink" title="2. 声音设计"></a>2. 声音设计</h2><p>在这部分，本清单着重于考虑声音设计理论和后期制作，亦包括合成器内容。此处假设读者诸君已对录音艺术有足够的了解，故《现代录音技术》这类书目不在本清单考虑范围之内。有需要的同学请自行检索“音频技术与录音艺术译丛”、“录音技术与艺术系列丛书 ”、“录音艺术专业‘十二五’规划教材”等经典丛书。</p><h3 id="2-1-声音设计理论与实践"><a href="#2-1-声音设计理论与实践" class="headerlink" title="2.1 声音设计理论与实践"></a>2.1 声音设计理论与实践</h3><p>影视声音设计多为线性声音，但众所周知，其中大量的技巧都可运用到游戏交互式声音设计中来，故此部分含影视相关书籍。</p><h4 id="《视听：幻觉的构建》"><a href="#《视听：幻觉的构建》" class="headerlink" title="《视听：幻觉的构建》"></a>《视听：幻觉的构建》</h4><p><img src="/images/%E8%A7%86%E5%90%AC_900.jpg" alt="视听_900"><br>Michel Chion，北京联合出版公司，2014<br>后浪电影学院中关于影视声音设计的一本重要著作，从多个层面分析了声音如何带给电影图像以时间感、空间感的增值效果，如何通过声音构建了影视幻觉。</p><h4 id="《放低话筒杆》"><a href="#《放低话筒杆》" class="headerlink" title="《放低话筒杆》"></a>《放低话筒杆》</h4><p><img src="/images/%E6%94%BE%E4%BD%8E%E8%AF%9D%E7%AD%92%E6%9D%86_900.jpg" alt="放低话筒杆_900"><br>Jay Beck，Tony Grajeda，中国电影出版社，2013<br>对诸多著名电影进行了声音上的反思，如《沉默的羔羊》、《穆赫兰道》等，探索了电影声音与文化研究之间的关系。</p><h4 id="《声音》"><a href="#《声音》" class="headerlink" title="《声音》"></a>《声音》</h4><p><img src="/images/%E5%A3%B0%E9%9F%B3_900.jpg" alt="声音_900"><br>Michel Chion，北京大学出版社，2013<br>作者作为 IRCAV 的客座教授，本书汇集了他三十年来的研究成果。构建了“纯声学”这个学科。纯声学所希望研究的声音是处于认知系统中的声音，偏向声音符号学。</p><h4 id="《电影之声：电影音效师访谈录》"><a href="#《电影之声：电影音效师访谈录》" class="headerlink" title="《电影之声：电影音效师访谈录》"></a>《电影之声：电影音效师访谈录》</h4><p><img src="/images/%E7%94%B5%E5%BD%B1%E4%B9%8B%E5%A3%B0-%E7%94%B5%E5%BD%B1%E9%9F%B3%E6%95%88%E5%B8%88%E8%AE%BF%E8%B0%88%E5%BD%95_900.jpg" alt="电影之声-电影音效师访谈录_900"><br>Vincent LoBrutto，北京大学出版社，2015<br>对27位著名电影音效师的访谈，内容包括同期录音、剪辑、声音设计、对白编辑、混录等，可以从其中观看自己喜欢的电影声音设计师的思路。</p><h4 id="《声频信号的仪表计量》"><a href="#《声频信号的仪表计量》" class="headerlink" title="《声频信号的仪表计量》"></a>《声频信号的仪表计量》</h4><p><img src="/images/%E5%A3%B0%E9%A2%91%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BB%AA%E8%A1%A8%E8%AE%A1%E9%87%8F_900.jpg" alt="声频信号的仪表计量_900"><br>Eddy Bogh Brixen, 人民邮电出版社, 2012<br>之所以把这本老书放上来，是建议大家都仔细学习一下音频测量标准的相关内容。新手入门容易出现对响度、动态范围之类的概念混淆，更别看懂不同标准。不过本书比较老，英文第三版前一阵也出了，愿意看关于音频测量最新严谨标准的朋友建议翻阅一下。</p><h4 id="《音效圣经-好莱坞音效创作及录制技巧》"><a href="#《音效圣经-好莱坞音效创作及录制技巧》" class="headerlink" title="《音效圣经: 好莱坞音效创作及录制技巧》"></a>《音效圣经: 好莱坞音效创作及录制技巧》</h4><p><img src="/images/%E9%9F%B3%E6%95%88%E5%9C%A3%E7%BB%8F%20%20%E5%A5%BD%E8%8E%B1%E5%9D%9E%E9%9F%B3%E6%95%88%E5%88%9B%E4%BD%9C%E5%8F%8A%E5%BD%95%E5%88%B6%E6%8A%80%E5%B7%A7%20%20%E6%8F%92%E5%9B%BE%E7%89%88_900.jpg" alt="音效圣经  好莱坞音效创作及录制技巧  插图版_900"><br>Ric Viers，北京联合出版公司·后浪出版公司，2016<br>两个十诫值得学习，第17章稍微值得稍微一看。对有录音基础的人来说，其余部分很乏味。</p><h4 id="《电影电视声音（第3版）》"><a href="#《电影电视声音（第3版）》" class="headerlink" title="《电影电视声音（第3版）》"></a>《电影电视声音（第3版）》</h4><p><img src="/images/%E7%94%B5%E5%BD%B1%E7%94%B5%E8%A7%86%E5%A3%B0%E9%9F%B3%EF%BC%88%E7%AC%AC3%E7%89%88%EF%BC%89_900.jpg" alt="电影电视声音（第3版）_900"><br>Tomlinson Holman，人民邮电出版社，2015<br>对声音设计师来说，目光可集中在第10章附近。前面的心理声学、音频基础、扬声器技术等过于老生常谈。</p><h4 id="《电影声音实用艺术（第3版）》"><a href="#《电影声音实用艺术（第3版）》" class="headerlink" title="《电影声音实用艺术（第3版）》"></a>《电影声音实用艺术（第3版）》</h4><p><img src="/images/%E7%94%B5%E5%BD%B1%E5%A3%B0%E9%9F%B3%E5%AE%9E%E7%94%A8%E8%89%BA%E6%9C%AF_900-1.jpg" alt="电影声音实用艺术_900"><br>Davis Lewis Yewdall, 人民邮电出版社，2011<br>相对《电影电视声音》来说，对声音设计师的启发就大的多了。毕竟做声音设计的时候本质也是在反复拉片，故本书有一半以上的内容值得深入学习。看着35mm胶片上的光学声迹，你会感叹用 DAW 做 Sound Design 是多么幸福。</p><h4 id="《动画声音设计》"><a href="#《动画声音设计》" class="headerlink" title="《动画声音设计》"></a>《动画声音设计》</h4><p><img src="/images/%E5%8A%A8%E7%94%BB%E5%A3%B0%E9%9F%B3%E8%AE%BE%E8%AE%A1_900.jpg" alt="动画声音设计_900"><br>Robin Beauchamp，人民邮电出版社，2011<br>国内的第1版排版是横向的，读起来很不舒服是一大缺点。书本身的内容极好，完整的从基础带着读者过了一遍影视动画声音设计，关于画外音、节奏、知觉引导等部分很棒。随书光盘有3GB+的内容，后面两个例子非常详细。<br>对有条件阅读原版的读者，仍推荐加读第2版，新版除了内容增减外，后面的例子数量变的非常多，可仔细把作者的理论套上去研究一番。</p><h4 id="《审美空间延伸与拓展-电影声音艺术理论》"><a href="#《审美空间延伸与拓展-电影声音艺术理论》" class="headerlink" title="《审美空间延伸与拓展: 电影声音艺术理论》"></a>《审美空间延伸与拓展: 电影声音艺术理论》</h4><p><img src="/images/%E5%AE%A1%E7%BE%8E%E7%A9%BA%E9%97%B4%E5%BB%B6%E4%BC%B8%E4%B8%8E%E6%8B%93%E5%B1%95_900.jpg" alt="审美空间延伸与拓展_900"><br>姚国强、孙欣，中国电影出版社，2002<br>北电的新世纪电影学论丛中一本著名书籍，尚未读完，不敢妄加评论。但就随便翻翻带来的观感而言，令人醍醐灌顶。电影声音艺术的研究对游戏声音设计的帮助是巨大的，要多多学习。</p><h4 id="《声音设计-电影中语言，音乐和音响的表现（第2版）》"><a href="#《声音设计-电影中语言，音乐和音响的表现（第2版）》" class="headerlink" title="《声音设计: 电影中语言，音乐和音响的表现（第2版）》"></a>《声音设计: 电影中语言，音乐和音响的表现（第2版）》</h4><p><img src="/images/%E5%A3%B0%E9%9F%B3%E8%AE%BE%E8%AE%A1_900.jpg" alt="声音设计_900"><br>David Sonnenschein，浙江大学出版社，2009<br>声音和画面、声音和叙事二章非常棒，可了解电影声音设计的方法论。与《审美空间延伸与拓展: 电影声音艺术理论》类比阅读，都是影视声音设计逆向输出的经典文献，值得深入学习。</p><h4 id="Sound-Design-and-Science-Fiction"><a href="#Sound-Design-and-Science-Fiction" class="headerlink" title="Sound Design and Science Fiction"></a><em>Sound Design and Science Fiction</em></h4><p><img src="/images/Sound%20Design%20and%20Science%20Fiction_900.jpg" alt="Sound Design and Science Fiction_900"><br>William Whittington, University of Texas Press, 2007<br>如果你对科幻电影中的声音设计很有兴趣，这本书的内容会很适合你。其中的声音研讨范围霸气阔《2001太空漫游》、《星球大战》、《异形》、《黑客帝国》及《终结者2》等，是科幻类电影声音设计的详实论述。</p><h4 id="Post-Sound-Design-The-Art-and-Craft-of-Audio-Post-Production-for-the-Moving-Image"><a href="#Post-Sound-Design-The-Art-and-Craft-of-Audio-Post-Production-for-the-Moving-Image" class="headerlink" title="Post Sound Design: The Art and Craft of Audio Post Production for the Moving Image"></a><em>Post Sound Design: The Art and Craft of Audio Post Production for the Moving Image</em></h4><p><img src="/images/Post%20Sound%20Design_900.jpg" alt="Post Sound Design_900"><br>John Avarese, Bloomsbury Academic, 2017<br>一本电影声音设计的完全论述，从什么是声音设计、设备连接、麦克风选择、DAW 的原理开始，到对白剪辑、音乐编辑、效果器应用、终混等，把影视声音全套流程过了一遍。</p><h4 id="Hollywood-Sound-Design-and-Moviesound-Newsletter-A-Case-Study-of-the-End-of-the-Analog-Age"><a href="#Hollywood-Sound-Design-and-Moviesound-Newsletter-A-Case-Study-of-the-End-of-the-Analog-Age" class="headerlink" title="Hollywood Sound Design and Moviesound Newsletter: A Case Study of the End of the Analog Age"></a><em>Hollywood Sound Design and Moviesound Newsletter: A Case Study of the End of the Analog Age</em></h4><p><img src="/images/Hollywood%20Sound%20Design%20and%20Moviesound%20Newsletter_900.jpg" alt="Hollywood Sound Design and Moviesound Newsletter_900"><br>David Stone, Focal Press, 2016<br>关于电影声音设计的一本详实著作，作者 David Stone 为奥斯卡奖获得者，有100多部电影的经验（爱德华剪刀手、夺宝奇兵3、蝙蝠侠归来等）。如果对好莱坞的声音设计很感兴趣，这本书是很好的切入点。</p><h4 id="The-Oxford-Handbook-of-Interactive-Audio"><a href="#The-Oxford-Handbook-of-Interactive-Audio" class="headerlink" title="The Oxford Handbook of Interactive Audio"></a><em>The Oxford Handbook of Interactive Audio</em></h4><p><img src="/images/The%20Oxford%20Handbook%20of%20Interactive%20Audio_900.jpg" alt="The Oxford Handbook of Interactive Audio_900"><br>Karen Collins, Bill Kapralos, Holly Tessler, Oxford University Press, 2017<br>牛津出版社的一本关于交互式音频的论文集，内容包括交互式音频实践、在游戏和 VR 中的应用、互动声音装置、相关工具和技巧等。</p><h4 id="Producing-Great-Sound-for-Film-and-Video"><a href="#Producing-Great-Sound-for-Film-and-Video" class="headerlink" title="Producing Great Sound for Film and Video"></a><em>Producing Great Sound for Film and Video</em></h4><p><img src="/images/Producing%20Great%20Sound%20for%20Film%20and%20Video_900.jpg" alt="Producing Great Sound for Film and Video_900"><br>Jay Rose, Focal Press, 2014<br>比较综合的书，之所以推荐这本，是因为其中对于同期录音、对白剪辑、后期的部分对声音设计师有一些可取之处，如果能看到的话可跳读一下。</p><h4 id="Studying-Sound-A-Theory-and-Practice-of-Sound-Design"><a href="#Studying-Sound-A-Theory-and-Practice-of-Sound-Design" class="headerlink" title="Studying Sound: A Theory and Practice of Sound Design"></a><em>Studying Sound: A Theory and Practice of Sound Design</em></h4><p><img src="/images/Studying%20Sound_900.jpg" alt="Studying Sound_900"><br>Karen Collins, The MIT Press, 2020<br>Karen Collins 的一本偏向实践的书，<em>Studying Sound</em> 我还没读到，但介绍中提到有多达175个练习，是颇为偏向练手的一本。其中的练习从练耳开始，看起来相当注重基础。</p><h4 id="Foundations-in-Sound-Design-for-Interactive-Media-A-Multidisciplinary-Approach"><a href="#Foundations-in-Sound-Design-for-Interactive-Media-A-Multidisciplinary-Approach" class="headerlink" title="Foundations in Sound Design for Interactive Media: A Multidisciplinary Approach"></a><em>Foundations in Sound Design for Interactive Media: A Multidisciplinary Approach</em></h4><p><img src="/images/Foundations%20in%20Sound%20Design%20for%20Interactive%20Media_900.jpg" alt="Foundations in Sound Design for Interactive Media_900"><br>Michael Filimowicz, Routledge, 2019<br>一本交互式媒体声音设计论文集，从游戏声音设计到装置艺术声音设计和网页交互声音设计均有涉猎。</p><h4 id="Foundations-in-Sound-Design-for-Linear-Media-A-Multidisciplinary-Approach"><a href="#Foundations-in-Sound-Design-for-Linear-Media-A-Multidisciplinary-Approach" class="headerlink" title="Foundations in Sound Design for Linear Media: A Multidisciplinary Approach"></a><em>Foundations in Sound Design for Linear Media: A Multidisciplinary Approach</em></h4><p><img src="/images/Foundations%20in%20Sound%20Design%20for%20Linear%20Media%20-%20A%20Multidisciplinary%20Approach_900.jpg" alt="Foundations in Sound Design for Linear Media - A Multidisciplinary Approach_900"><br>Michael Filimowicz, Routledge, 2019<br>同上，一本线性媒体声音设计论文集（其实还有本嵌入式媒体声音设计），这本偏影视的多。</p><h4 id="Sound-Design-Theory-and-Practice-Working-with-Sound"><a href="#Sound-Design-Theory-and-Practice-Working-with-Sound" class="headerlink" title="Sound Design Theory and Practice: Working with Sound"></a><em>Sound Design Theory and Practice: Working with Sound</em></h4><p><img src="/images/Sound%20Design%20Theory%20and%20Practice_900.jpg" alt="Sound Design Theory and Practice_900"><br>Leo Murray, Routledge, 2019<br>一本简单的小书，从电影、电视、游戏分析了声音设计的理论基础，闲暇可翻（电影分析的是1933年版金刚，很有历史感）。</p><h4 id="Sound-Works-A-Cultural-Theory-of-Sound-Design"><a href="#Sound-Works-A-Cultural-Theory-of-Sound-Design" class="headerlink" title="Sound Works: A Cultural Theory of Sound Design"></a><em>Sound Works: A Cultural Theory of Sound Design</em></h4><p><img src="/images/Sound%20Works_900.jpg" alt="Sound Works_900"><br>Holger Schulze, Bloomsbury Academic, 2020<br>什么是声音设计？它在21世纪早期的功能是什么？这本书从文化理论角度出发讨论了这些问题。听起来非常理论化，其实第二部分 Sonic Labor 的插图对声音设计师的视觉化描述非常有趣。</p><h4 id="The-Fundamentals-of-Sonic-Art-and-Sound-Design"><a href="#The-Fundamentals-of-Sonic-Art-and-Sound-Design" class="headerlink" title="The Fundamentals of Sonic Art and Sound Design"></a><em>The Fundamentals of Sonic Art and Sound Design</em></h4><p><img src="/images/The%20Fundamentals%20of%20Sonic%20Art%20and%20Sound%20Design_900.jpg" alt="The Fundamentals of Sonic Art and Sound Design_900">Tony Gibbs, Fairchild Books, 2007<br>一句话：声音装置艺术爱好者的福音。想把声音设计掺和到声音艺术领域的人大可从本书中汲取营养，看看大家是怎么玩的。</p><h4 id="The-Plagrave-Handbook-of-Sound-Design-and-Music-in-Screen-Media"><a href="#The-Plagrave-Handbook-of-Sound-Design-and-Music-in-Screen-Media" class="headerlink" title="The Plagrave Handbook of Sound Design and Music in Screen Media"></a><em>The Plagrave Handbook of Sound Design and Music in Screen Media</em></h4><p><img src="/images/The%20Plagrave%20Handbook%20of%20Sound%20Design%20and%20Music%20in%20Screen%20Medi_900.jpg" alt="The Plagrave Handbook of Sound Design and Music in Screen Medi_900">Liz Greene, Danijela Kulezic-Wilson, Palgrave Macmillan, 2016<br>影视配乐与声音设计之间的关系越来越模，这本文集就集合了相关的一些文章。仅少量声音设计相关的论述值得一看。</p><h3 id="2-2-拟音（Foley）"><a href="#2-2-拟音（Foley）" class="headerlink" title="2.2 拟音（Foley）"></a>2.2 拟音（Foley）</h3><h4 id="《拟音圣经-电影、游戏和动画片中的声音表演艺术》"><a href="#《拟音圣经-电影、游戏和动画片中的声音表演艺术》" class="headerlink" title="《拟音圣经: 电影、游戏和动画片中的声音表演艺术》"></a>《拟音圣经: 电影、游戏和动画片中的声音表演艺术》</h4><p><img src="/images/%E6%8B%9F%E9%9F%B3%E5%9C%A3%E7%BB%8F_900.jpg" alt="拟音圣经_900">Vanessa Theme Ament，人民邮电出版社，2010<br>必读书籍，无需赘述，掰芹菜和砸湿抹布都是拿手好戏。</p><h4 id="《影视拟音技巧》"><a href="#《影视拟音技巧》" class="headerlink" title="《影视拟音技巧》"></a>《影视拟音技巧》</h4><p><img src="/images/%E5%BD%B1%E8%A7%86%E6%8B%9F%E9%9F%B3%E6%8A%80%E5%B7%A7_900.jpg" alt="影视拟音技巧_900"><br>魏俊华，高超，高士义，中国广播电视出版社，2012<br>虽然权威，但废话极多，且图片编辑极其不专业（直接拍照），建议跳读+一张导图完事。</p><h3 id="2-3-Pure-Data"><a href="#2-3-Pure-Data" class="headerlink" title="2.3 Pure Data"></a>2.3 Pure Data</h3><p>之所以这部分只放 Pure Data 而没有 Max、Csound、SuperCollider、ChucK 等。是因为在下着实精力有限，以后学到了再更相关资料。不过这些东西其实读文档和看 YouTube 足矣，纸质出版物远没有 Pd 多。</p><h4 id="《设计声音》"><a href="#《设计声音》" class="headerlink" title="《设计声音》"></a>《设计声音》</h4><p><img src="/images/%E8%AE%BE%E8%AE%A1%E5%A3%B0%E9%9F%B3_900.jpg" alt="设计声音_900"><br>Andy Farnell，中国邮电出版社，2017<br>过程式音频设计原理 + Pure Data 入门，很有趣的书（前面理论部分若已知悉一些跳读起来更爽快）。</p><h4 id="《电子音乐技术》"><a href="#《电子音乐技术》" class="headerlink" title="《电子音乐技术》"></a>《电子音乐技术》</h4><p><img src="/images/%E7%94%B5%E5%AD%90%E9%9F%B3%E4%B9%90%E6%8A%80%E6%9C%AF_900.jpg" alt="电子音乐技术_900"><br>Miller Puckette，人民邮电出版社，2011<br>Pure Data 作者本人写的书，从头带你玩声音合成。英语基础不好看不懂文档的同学可以先看这个。</p><h4 id="《交互式音频程序开发》"><a href="#《交互式音频程序开发》" class="headerlink" title="《交互式音频程序开发》"></a>《交互式音频程序开发》</h4><p><img src="/images/%E4%BA%A4%E4%BA%92%E5%BC%8F%E9%9F%B3%E9%A2%91%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91_900.jpg" alt="交互式音频程序开发_900"><br>童雷，韩柯，人民邮电出版社，2018<br>一本简单的 Pure Data 介绍类书籍，把基础的合成方法过了一遍，最后配置了 OSC 来应了书的主题。</p><h4 id="《Pure-Data-图形化音乐编程技术与应用》"><a href="#《Pure-Data-图形化音乐编程技术与应用》" class="headerlink" title="《Pure Data 图形化音乐编程技术与应用》"></a>《Pure Data 图形化音乐编程技术与应用》</h4><p><img src="/images/Pure%20Data%20%E5%9B%BE%E5%BD%A2%E5%8C%96%E9%9F%B3%E4%B9%90%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8_900.jpg" alt="Pure Data 图形化音乐编程技术与应用_900">杨万钧，西南师范大学出版社，2017<br>川音电子音乐理论与技术丛书中讲 Pure Data 的一本，算是本土化不错的一本详细的 Pd 介绍。本套丛书还涉及了 Kyma、Max、Csound、VVVV 等令人兴奋的内容，值得一看。</p><h4 id="Multimedia-Programming-with-Pure-Data"><a href="#Multimedia-Programming-with-Pure-Data" class="headerlink" title="Multimedia Programming with Pure Data"></a><em>Multimedia Programming with Pure Data</em></h4><p><img src="/images/Multimedia%20Programming%20with%20Pure%20Data_900.jpg" alt="Multimedia Programming with Pure Data_900">Bryan WC Chung, Packt Publishing, 2013<br>这本更着重讲 Pure Data 里视频组件做多媒体艺术的部分。</p><h4 id="Programming-Sound-with-Pure-Data-Make-Your-Apps-Come-Alive-with-Dynamic-Audio"><a href="#Programming-Sound-with-Pure-Data-Make-Your-Apps-Come-Alive-with-Dynamic-Audio" class="headerlink" title="Programming Sound with Pure Data: Make Your Apps Come Alive with Dynamic Audio"></a><em>Programming Sound with Pure Data: Make Your Apps Come Alive with Dynamic Audio</em></h4><p><img src="/images/Programming%20Sound%20with%20Pure%20Data_%20Make%20Your%20Apps%20Come%20Alive%20with%20Dynamic%20Audio_900.jpg" alt="Programming Sound with Pure Data_ Make Your Apps Come Alive with Dynamic Audio_900"><br>Tony Hillerson, Pragmatic Bookshelf, 2014<br>除了前面的基础部分，让 App 使用动态音频实际指的是对一个 Web 游戏添加 Pd Patch 来产生交互。</p><h3 id="2-4-VCV-Rack"><a href="#2-4-VCV-Rack" class="headerlink" title="2.4 VCV Rack"></a>2.4 VCV Rack</h3><p>VCV Rack 文档配合 YouTube 视频实际已经可以满足学习需求，但鉴于我一开始找到了相关资料，就一并放出供初学者参考。</p><h4 id="How-to-Rack"><a href="#How-to-Rack" class="headerlink" title="How to Rack"></a><em>How to Rack</em></h4><p><img src="/images/How%20to%20Rack_900.jpg" alt="How to Rack_900">Jim Aikin, Self-Publishing</p><h4 id="VCV-Rack-How-it-Works"><a href="#VCV-Rack-How-it-Works" class="headerlink" title="VCV Rack: How it Works"></a><em>VCV Rack: How it Works</em></h4><p><img src="/images/VCV%20Rack%20-%20How%20it%20Works_900.jpg" alt="VCV Rack - How it Works_900"><br>Edgar Rothermich, Self-Publishing, 2018<br>作者是中国女婿，册子也是非常友好的图文交互册子。</p><h4 id="Developing-Virtual-Synthesizers-with-VCV-Rack"><a href="#Developing-Virtual-Synthesizers-with-VCV-Rack" class="headerlink" title="Developing Virtual Synthesizers with VCV Rack"></a><em>Developing Virtual Synthesizers with VCV Rack</em></h4><p><img src="/images/Developing%20Virtual%20Synthesizers%20with%20VCV%20Rack_900.jpg" alt="Developing Virtual Synthesizers with VCV Rack_900"><br>Leonardo Gabrielli, Focal Press, 2020<br>开发自己的模块，对官网文档做了一个很好的整理。</p><h3 id="2-4-Reaktor"><a href="#2-4-Reaktor" class="headerlink" title="2.4 Reaktor"></a>2.4 Reaktor</h3><h4 id="《声音合成平台-Reaktor-操作指南》"><a href="#《声音合成平台-Reaktor-操作指南》" class="headerlink" title="《声音合成平台 Reaktor 操作指南》"></a>《声音合成平台 Reaktor 操作指南》</h4><p><img src="/images/%E5%A3%B0%E9%9F%B3%E5%90%88%E6%88%90%E5%B9%B3%E5%8F%B0REAKTOR%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97_900.jpg" alt="声音合成平台REAKTOR操作指南_900">夏田，人民邮电出版社，2016<br>夏老师经典之作，看不懂 Youtube 和 Kadenze 的朋友可以先看这本。虽然用的是 Reaktor 5，但对学习影响不大。</p><h3 id="2-5-合成器"><a href="#2-5-合成器" class="headerlink" title="2.5 合成器"></a>2.5 合成器</h3><h4 id="《自己动手做声音-声音合成与制作基础》"><a href="#《自己动手做声音-声音合成与制作基础》" class="headerlink" title="《自己动手做声音: 声音合成与制作基础》"></a>《自己动手做声音: 声音合成与制作基础》</h4><p><img src="/images/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%81%9A%E5%A3%B0%E9%9F%B3_900.jpg" alt="自己动手做声音_900"><br>程伊兵，中央音乐学院出版社，2009<br>程老师声音合成经典著作，唯一的缺点是例子基于 Nord Modular G2，但单纯的学思路是没有任何影响的。</p><h4 id="《声音合成与采样技术（第3版）》"><a href="#《声音合成与采样技术（第3版）》" class="headerlink" title="《声音合成与采样技术（第3版）》"></a>《声音合成与采样技术（第3版）》</h4><p><img src="/images/%E5%A3%B0%E9%9F%B3%E5%90%88%E6%88%90%E4%B8%8E%E9%87%87%E6%A0%B7%E6%8A%80%E6%9C%AF%20%20%E7%AC%AC3%E7%89%88_OCR_900.jpg" alt="声音合成与采样技术  第3版_OCR_900">Martin Russ，人民邮电出庵社，2011<br>夏老师翻译的一本对声音合成解释非常详细的制作，非常底层的从 VCA、VCO、VCF 这种初上模块容易令人困惑的概念讲起，值得深入学习的一本好书。</p><h4 id="《软件合成器技术实战手册-音色制作与模块编程》"><a href="#《软件合成器技术实战手册-音色制作与模块编程》" class="headerlink" title="《软件合成器技术实战手册: 音色制作与模块编程》"></a>《软件合成器技术实战手册: 音色制作与模块编程》</h4><p><img src="/images/%E8%BD%AF%E4%BB%B6%E5%90%88%E6%88%90%E5%99%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98%E6%89%8B%E5%86%8C_900.jpg" alt="软件合成器技术实战手册_900"><br>飞来音，清华大学出版社，2008<br>看不懂英文说明书和教程的同学可翻翻这本老书。</p><h4 id="Creating-Sounds-from-Scratch-A-Practical-Guide-to-Music-Synthesis-for-Producers-and-Composers"><a href="#Creating-Sounds-from-Scratch-A-Practical-Guide-to-Music-Synthesis-for-Producers-and-Composers" class="headerlink" title="Creating Sounds from Scratch: A Practical Guide to Music Synthesis for Producers and Composers"></a><em>Creating Sounds from Scratch: A Practical Guide to Music Synthesis for Producers and Composers</em></h4><p><img src="/images/Creating%20Sounds%20from%20Scratch_900.jpg" alt="Creating Sounds from Scratch_900"><br>Andrea Pejrolo, Scott B. Metcalfe, Oxford University Press, 2017<br>基本可以看做是《声音合成与采样技术》更符合阅读学习体验的版本，贴心的从历史到基础术语讲起。每种合成方式独占一章，且配合详细的聆听指南让读者记忆音色中所用的模块，非常人性化。</p><h4 id="The-Synthesizer-A-Comprehensive-Guide-to-Understanding-Programming-Playing-and-Recording-the-Ultimate-Electronic-Music-Instrument"><a href="#The-Synthesizer-A-Comprehensive-Guide-to-Understanding-Programming-Playing-and-Recording-the-Ultimate-Electronic-Music-Instrument" class="headerlink" title="The Synthesizer: A Comprehensive Guide to Understanding, Programming, Playing, and Recording the Ultimate Electronic Music Instrument"></a><em>The Synthesizer: A Comprehensive Guide to Understanding, Programming, Playing, and Recording the Ultimate Electronic Music Instrument</em></h4><p><img src="/images/The%20Synthesizer_900.jpg" alt="The Synthesizer_900"><br>Mark Vail, Oxford University Press, 2014<br>相比 <em>Creating Sounds from Scratch</em>，这本小书更强调介绍合成器历史，并拉人入坑到模块世界去。</p><h4 id="Computer-Sound-Design-Synthesis-Techniques-and-Programming-2nd-edition"><a href="#Computer-Sound-Design-Synthesis-Techniques-and-Programming-2nd-edition" class="headerlink" title="Computer Sound Design: Synthesis Techniques and Programming 2nd edition"></a><em>Computer Sound Design: Synthesis Techniques and Programming 2nd edition</em></h4><p><img src="/images/Computer%20Sound%20Design_900.jpg" alt="Computer Sound Design_900">Eduardo Reck Miranda, Focal Press, 2002<br>作为一本老书，前面的声音合成理论自然不会过时。但有趣的部分是，可一览当年的声音合成程序，如命令行的 pcmusic、Som-A，史前 Reaktor 等。</p><h4 id="Becoming-a-Synthesizer-Wizard-From-Presets-to-Power-User"><a href="#Becoming-a-Synthesizer-Wizard-From-Presets-to-Power-User" class="headerlink" title="Becoming a Synthesizer Wizard: From Presets to Power User"></a><em>Becoming a Synthesizer Wizard: From Presets to Power User</em></h4><p><img src="/images/Becoming%20a%20Synthesizer%20Wizard%20From%20Presets%20to%20Power%20User_900.jpg" alt="Becoming a Synthesizer Wizard From Presets to Power User_900"><br>Simon Cann, Cengage Learning PTR, 2009<br>也算一本不错的合成器教程，缺点是示例软件过老，建议用模块复刻其中的 Patch。</p><h4 id="Welsh’s-Synthesizer-Cookbook-Synthesizer-Programming-Sound-Analysis-and-Universal-Patch-Book-1、2"><a href="#Welsh’s-Synthesizer-Cookbook-Synthesizer-Programming-Sound-Analysis-and-Universal-Patch-Book-1、2" class="headerlink" title="Welsh’s Synthesizer Cookbook: Synthesizer Programming, Sound Analysis, and Universal Patch Book 1、2"></a><em>Welsh’s Synthesizer Cookbook: Synthesizer Programming, Sound Analysis, and Universal Patch Book 1、2</em></h4><p><img src="/images/Welsh&#39;s%20Synthesizer%20Cookbook_900.jpg" alt="Welsh&#39;s Synthesizer Cookbook_900"><br>Fred Welsh, 2006<br>没有废话，讲完点前置知识后直接上各种 Patch 的配置表，都是通用的参数，可直接在自己的合成器里复刻研究，十分实用。</p><h4 id="Refining-Sound-A-Practical-Guide-to-Synthesis-and-Synthesizers"><a href="#Refining-Sound-A-Practical-Guide-to-Synthesis-and-Synthesizers" class="headerlink" title="Refining Sound: A Practical Guide to Synthesis and Synthesizers"></a><em>Refining Sound: A Practical Guide to Synthesis and Synthesizers</em></h4><p><img src="/images/Refining%20Sound_900.jpg" alt="Refining Sound_900"><br>Brian K. Shepard, Oxford University Press, 2013<br>一本合成器快速入门的小册子，讲的不够详细，快速翻翻入门还不错。</p><h4 id="Analog-Synthesizers-Understanding-Performing-Buying-2nd-edition"><a href="#Analog-Synthesizers-Understanding-Performing-Buying-2nd-edition" class="headerlink" title="Analog Synthesizers: Understanding, Performing, Buying 2nd edition"></a><em>Analog Synthesizers: Understanding, Performing, Buying 2nd edition</em></h4><p><img src="/images/Analog%20Synthesizers_900.jpg" alt="Analog Synthesizers_900"><br>Mark Jenkins, Routledge, 2020<br>伴随模拟和数字合成器的历史更迭，讲述合成器的使用。</p><h4 id="Microsound"><a href="#Microsound" class="headerlink" title="Microsound"></a><em>Microsound</em></h4><p><img src="/images/Microsound_900.jpg" alt="Microsound_900"><br>Curtis Roads, The MIT Press, 2001<br>伟大的 <em>The Computer Music Tutorial</em> 的作者，这本主讲微分音与声音合成。</p><h3 id="2-6-空间音频"><a href="#2-6-空间音频" class="headerlink" title="2.6 空间音频"></a>2.6 空间音频</h3><p>关于空间音频，这几本可能是目前领域最前沿的研究材料了。</p><h4 id="《空间声原理》"><a href="#《空间声原理》" class="headerlink" title="《空间声原理》"></a>《空间声原理》</h4><p><img src="/images/%E7%A9%BA%E9%97%B4%E5%A3%B0%E5%8E%9F%E7%90%86_900_900.jpg" alt="空间声原理_900_900"><br>谢菠荪，科学出版社，2019<br>作为“现代声学科学与技术丛书”中比较贴近民用的一本（这套书里关于声呐和噪声控制的较多），由华南理工大学的谢菠荪教授所著，是国内第一本讨论空间声领域的全面著作。内容包括空间环绕声、Ambisonics、矩阵环绕声、双耳 HRTF 等诸多内容，书后附有1000多篇领域论文名，可供对空间音频有意深究的朋友阅读。</p><h4 id="《空间线索在3D音频中的应用研究》"><a href="#《空间线索在3D音频中的应用研究》" class="headerlink" title="《空间线索在3D音频中的应用研究》"></a>《空间线索在3D音频中的应用研究》</h4><p><img src="/images/%E7%A9%BA%E9%97%B4%E7%BA%BF%E7%B4%A2%E5%9C%A83D%E9%9F%B3%E9%A2%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E7%A0%94%E7%A9%B6_900.jpg" alt="空间线索在3D音频中的应用研究_900">张聪，中国水利水电出版社，2019<br>本书主要讨论的是影视下3D音频优化，通过实验手段验证合理降低多声道的参数码率。</p><h4 id="Ambisonics"><a href="#Ambisonics" class="headerlink" title="Ambisonics"></a><em>Ambisonics</em></h4><p><img src="/images/Ambisonics_900.jpg" alt="Ambisonics_900"><br>Franz Zotter, Matthias Frank, Springer, 2019<br>关于 Ambisonics 的概念和应用，一站式解决。</p><h4 id="Immersive-Sound"><a href="#Immersive-Sound" class="headerlink" title="Immersive Sound"></a><em>Immersive Sound</em></h4><p><img src="/images/Immersive%20Sound_900.jpg" alt="Immersive Sound_900"><br>Agnieszka Roginska, Paul Geluso, Routledge, 2018<br>沉浸式声音有关概念和应用。</p><h2 id="3-技术音频"><a href="#3-技术音频" class="headerlink" title="3. 技术音频"></a>3. 技术音频</h2><h3 id="3-1-导论及文集"><a href="#3-1-导论及文集" class="headerlink" title="3.1 导论及文集"></a>3.1 导论及文集</h3><p>导论与文集中大多为对引擎架构、游戏音频编程有关内容的书。作为与技术美术相仿的职位，技术音频还是应该对整个游戏的开发都有一个概念性的认知。<br>叶大有一个游戏程序员开发的书单，大家如果对游戏开发有兴趣可以寻找自己喜欢的书观看。缺点是这份书单三年没维护，且其中关于游戏音频的部分更是匮乏，这也是我这份书单存在的意义。<br>叶大书单：<a href="https://github.com/miloyip/game-programmer/" target="_blank" rel="noopener">https://github.com/miloyip/game-programmer/</a></p><h4 id="《游戏引擎架构》"><a href="#《游戏引擎架构》" class="headerlink" title="《游戏引擎架构》"></a>《游戏引擎架构》</h4><p><img src="/images/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E6%9E%B6%E6%9E%84%20_900.jpg" alt="游戏引擎架构 _900"><br>Jason Gregory, 电子工业出版社, 2014<br>叶大知名译作，虽然刚出了第2版但鉴于还没买……就先推荐第1版吧。原作在 Amazon 上也是评价颇高，对不熟悉引擎的人来说快速摸一遍结构，再读说明书也会明朗不少。</p><h4 id="《游戏编程算法与技巧》"><a href="#《游戏编程算法与技巧》" class="headerlink" title="《游戏编程算法与技巧》"></a>《游戏编程算法与技巧》</h4><p><img src="/images/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7_900.jpg" alt="游戏编程算法与技巧_900"><br>Sanjay Madhav，电子工业出版社，2016<br>侯老师推荐给我的一本，来自腾讯的瀚阳老师精心译作。作为南加州大学的本科教材，系统讲解了游戏开发中基础的各方面，4-11章中充满亮点。关于物理、声音和脚本语言的部分很不错，初学者跟着实现一遍附带的项目会很有帮助。</p><h4 id="The-Audio-Programming-Book"><a href="#The-Audio-Programming-Book" class="headerlink" title="The Audio Programming Book"></a><em>The Audio Programming Book</em></h4><p><img src="/images/The%20Audio%20Programming%20Book_900.jpg" alt="The Audio Programming Book_900"><br>Richard Boulanger, eVictor Lazzarini, The MIT Press, 2011<br>一本关于音频编程的文集，不仅探讨了 C, C++, Csound，对 DFT、FFT、卷积等经典概念也有专门的文章进行讨论。是非常好的音频编程益智类读物，适合休闲娱乐时补充营养之用。</p><h4 id="Game-Audio-Programming-Principles-and-Practices-1、2、3"><a href="#Game-Audio-Programming-Principles-and-Practices-1、2、3" class="headerlink" title="Game Audio Programming: Principles and Practices 1、2、3"></a><em>Game Audio Programming: Principles and Practices 1、2、3</em></h4><p><img src="/images/GAP%20all_900.jpg" alt="GAP all_900"><br>Guy Somberg, CRC Press, 2016 2018 2020<br>Guy 老哥作为这系列游戏音频编程文集的编者，估计技术音频们没有不知道的。之前简单翻了翻前言，说说刚出版的第三册的内容：音频资源管理、DSP 编程、语音管线、抽象游戏音频层级为 Patch Cable、声部管理等迷人的部分。<br>文中具体的作者均是行业先锋，有兴趣考据可翻翻作者介绍。</p><h4 id="Beep-To-Boom-The-Development-Of-Advanced-Runtime-Sound-Systems-For-Games-And-Extended-Reality"><a href="#Beep-To-Boom-The-Development-Of-Advanced-Runtime-Sound-Systems-For-Games-And-Extended-Reality" class="headerlink" title="Beep To Boom: The Development Of Advanced Runtime Sound Systems For Games And Extended Reality"></a><em>Beep To Boom: The Development Of Advanced Runtime Sound Systems For Games And Extended Reality</em></h4><p><img src="/images/Beep%20To%20Boom_900.jpg" alt="Beep To Boom_900"><br>Simon N Goodwin, Focal Press, 2019<br>主要内容是关于交互式音频系统的设计开发，内容详实。</p><h4 id="Game-Audio-Tales-of-a-Technical-Sound-Designer-1、2"><a href="#Game-Audio-Tales-of-a-Technical-Sound-Designer-1、2" class="headerlink" title="Game Audio: Tales of a Technical Sound Designer 1、2"></a><em>Game Audio: Tales of a Technical Sound Designer 1、2</em></h4><p><img src="/images/Game%20Audio%20Tales_900.jpg" alt="Game Audio Tales_900"><br>Damian Kastbauer, 2017<br>Audiokinetic 产品经理胡子哥，WAG 的前身 Wwise 工程大冒险的奠基人。他的两本书收集了他关于技术音频或技术声音设计师（Technical Sound Designer）的诸多博文与采访，其中关于整合工具的部分令人大开眼界。</p><h3 id="3-2-引擎使用"><a href="#3-2-引擎使用" class="headerlink" title="3.2 引擎使用"></a>3.2 引擎使用</h3><p>关于两大主流商业引擎（Unity、Unreal Engine）的使用，除了必看的文档之外，还有一些我看过蛮不错的参考书籍。</p><h4 id="《Unity-3D-游戏开发（第二版）》"><a href="#《Unity-3D-游戏开发（第二版）》" class="headerlink" title="《Unity 3D 游戏开发（第二版）》"></a>《Unity 3D 游戏开发（第二版）》</h4><p><img src="/images/Unity%203D%20%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91_900.jpg" alt="Unity 3D 游戏开发_900"><br>宣雨松，人民邮电出版社，2018<br>雨松老师是天马时空的 Unity 技术专家，这本书对 Unity 的各个方面都进行了详细的讲解。对于入门的人来说比较友好，比如对脚本、AB 包、自动打包之类的技术感兴趣可直接跳跃翻看雨松老师的讲解，部分比文档更有针对性。</p><h4 id="Unity-Game-Development-Cookbook"><a href="#Unity-Game-Development-Cookbook" class="headerlink" title="Unity Game Development Cookbook"></a><em>Unity Game Development Cookbook</em></h4><p><img src="/images/Unity%20Game%20Development%20Cookbook_900.jpg" alt="Unity Game Development Cookbook_900"><br>Paris Buttfield-Addison, Jon Manning, Tim Nugent, O’Reilly Media, 2019<br>Cookbook 是一种很棒的书籍交流形式，书中没有以章节为中心的讲述形式。相反，每个章节只代表一类问题的集合。比如 Prefab，书中提出的问题就是“想把一个游戏对象保存为文件，好方便复用”，随后给出详细的解决方案、讨论、提醒等。<br>在翻文档和搜索问题之前抽空扫一眼目录，或许你的问题就有答案。</p><h4 id="Unreal-Engine-Game-Development-Cookbook"><a href="#Unreal-Engine-Game-Development-Cookbook" class="headerlink" title="Unreal Engine Game Development Cookbook"></a><em>Unreal Engine Game Development Cookbook</em></h4><p><img src="/images/Unreal%20Engine%20Game%20Development%20Cookbook_900.jpg" alt="Unreal Engine Game Development Cookbook_900"><br>John P. Doran, Packt Publishing, 2015<br>与上一本书相同，这本针对 UE4，把常见的问题都拎出来放在目录中供你挑拣，针对需要的问题直接点对点查看解决方案。</p><h3 id="3-3-游戏引擎音频整合"><a href="#3-3-游戏引擎音频整合" class="headerlink" title="3.3 游戏引擎音频整合"></a>3.3 游戏引擎音频整合</h3><h4 id="Game-Audio-Development-with-Unity-5-X"><a href="#Game-Audio-Development-with-Unity-5-X" class="headerlink" title="Game Audio Development with Unity 5.X"></a><em>Game Audio Development with Unity 5.X</em></h4><p><img src="/images/Game%20Audio%20Development%20with%20Unity%205.X_900.jpg" alt="Game Audio Development with Unity 5.X_900"><br>Micheal Lanham, Packt Publishing, 2017<br>虽然使用的 Unity 版本比较老，但这本是少有的对 Unity 音频部分拿出整本篇幅来介绍的书。在后半部分包括对 FMOD Studio 的介绍、音频可视化、Lip Syncing、性能优化等非常有价值的内容。非常适合作为学习 Unity 整合前的引擎自带音频功能补课，远比官网文档要详细。</p><h4 id="Game-Audio-Implementation-A-Practical-Guide-Using-the-Unreal-Engine"><a href="#Game-Audio-Implementation-A-Practical-Guide-Using-the-Unreal-Engine" class="headerlink" title="Game Audio Implementation: A Practical Guide Using the Unreal Engine"></a><em>Game Audio Implementation: A Practical Guide Using the Unreal Engine</em></h4><p><img src="/images/Game%20audio%20implementation_900.jpg" alt="Game audio implementation_900">Richard Stevens, Dave Raybould, Focal Press, 2016<br>主讲使用 UE4 自带的音频功能进行声音整合。</p><h4 id="Game-Audio-with-FMOD-and-Unity"><a href="#Game-Audio-with-FMOD-and-Unity" class="headerlink" title="Game Audio with FMOD and Unity"></a><em>Game Audio with FMOD and Unity</em></h4><p><img src="/images/Game%20Audio%20with%20FMOD%20and%20Unity_900.jpg" alt="Game Audio with FMOD and Unity_900"><br>Ciarán Robinson, Routledge, 2019<br>使用 FMOD 给 Unity 进行音频整合，不过聪明的同学应该想得出，从本书学会怎么改脚本，一样能套到 Wwise Unity 整合上。（奸笑</p><h4 id="The-Handbook-of-Game-Audio-Using-Wwise"><a href="#The-Handbook-of-Game-Audio-Using-Wwise" class="headerlink" title="The Handbook of Game Audio Using Wwise"></a><em>The Handbook of Game Audio Using Wwise</em></h4><p>Gordon Durity, Aleksandar Zecevic, A K Peters, 2021<br>跳票已久的 Wwise 书，作者是 EA 的两位老哥，封面欠缺。</p><h3 id="3-4-插件开发"><a href="#3-4-插件开发" class="headerlink" title="3.4 插件开发"></a>3.4 插件开发</h3><p>鉴于在下的插件开发了解着实较少，就只列基本常见书籍，以后再更。</p><h4 id="Getting-Started-with-JUCE"><a href="#Getting-Started-with-JUCE" class="headerlink" title="Getting Started with JUCE"></a><em>Getting Started with JUCE</em></h4><p><img src="/images/Getting%20Started%20with%20JUCE_900.jpg" alt="Getting Started with JUCE_900"><br>Martin Robinson, Packt Publishing, 2013<br>关于 JUCE 的一本小书，其实看文档和 Kadenze 会更好些。</p><h4 id="Audio-Effects-Theory-Implementation-and-Application"><a href="#Audio-Effects-Theory-Implementation-and-Application" class="headerlink" title="Audio Effects: Theory, Implementation and Application"></a><em>Audio Effects: Theory, Implementation and Application</em></h4><p><img src="/images/Audio%20Effects_900.jpg" alt="Audio Effects_900"><br>Joshua D. Reiss, Andrew McPherson, CRC Press, 2014<br>跟接下来三本比，算是插件设计里比较轻松的一本读物。比较适合对新手理解效果器原理学习，每章更是友好的提供习题，最后例子的实现仍基于 JUCE。</p><h4 id="DAFX-Digital-Audio-Effects"><a href="#DAFX-Digital-Audio-Effects" class="headerlink" title="DAFX Digital Audio Effects"></a><em>DAFX Digital Audio Effects</em></h4><p><img src="/images/DAFX%20Digital%20Audio%20Effects_900.jpg" alt="DAFX Digital Audio Effects_900"><br>Udo Zölzer, Wiley, 2011<br>著名的 DAFX，目前还找不出需求读这本，不过对做音频算法的朋友来说应该是都知道的了。</p><h4 id="Designing-Audio-Effect-Plug-Ins-in-C-With-Digital-Audio-Signal-Processing-Theory"><a href="#Designing-Audio-Effect-Plug-Ins-in-C-With-Digital-Audio-Signal-Processing-Theory" class="headerlink" title="Designing Audio Effect Plug-Ins in C++ With Digital Audio Signal Processing Theory"></a><em>Designing Audio Effect Plug-Ins in C++ With Digital Audio Signal Processing Theory</em></h4><p><img src="/images/Designing%20Audio%20Effect%20Plug-Ins%20in%20C++%20With%20Digital%20Audio%20Signal%20Processing%20Theory_900.jpg" alt="Designing Audio Effect Plug-Ins in C++ With Digital Audio Signal Processing Theory_900"><br>Will C. Pirkle, Focal Press, 2012<br>DSP 开发宝典之一。</p><h4 id="Designing-Software-Synthesizer-Plug-Ins-in-C-For-RackAFX-VST3-and-Audio-Units"><a href="#Designing-Software-Synthesizer-Plug-Ins-in-C-For-RackAFX-VST3-and-Audio-Units" class="headerlink" title="Designing Software Synthesizer Plug-Ins in C++ For RackAFX, VST3, and Audio Units"></a><em>Designing Software Synthesizer Plug-Ins in C++ For RackAFX, VST3, and Audio Units</em></h4><p><img src="/images/Designing%20Software%20Synthesizer%20Plug-Ins%20in%20C++%20For%20RackAFX,%20VST3,%20and%20Audio%20Units_900.jpg" alt="Designing Software Synthesizer Plug-Ins in C++ For RackAFX, VST3, and Audio Units_900"><br>Will C. Pirkle, Focal Press, 2014<br>开发宝典之二。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/11/04/hello-world/"/>
      <url>/2018/11/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Testing </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
